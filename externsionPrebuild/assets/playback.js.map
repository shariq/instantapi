{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./content/commands-api.js","webpack:////mnt/c/yc/instantapi/selenium-ide/node_modules/scroll-into-view-if-needed/es/index.js","webpack:////mnt/c/yc/instantapi/selenium-ide/node_modules/compute-scroll-into-view/es/index.js","webpack:///./content/escape.js","webpack:///./content/selenium-api.js","webpack:///./content/selenium-browserbot.js","webpack:///./content/PatternMatcher.js","webpack:///./content/targetSelector.js","webpack:///./content/region.js","webpack:///./content/prompt-injector.js"],"names":["root","factory","exports","module","define","amd","a","i","self","this","Object","defineProperty","__webpack_exports__","value","__WEBPACK_IMPORTED_MODULE_0_webextension_polyfill__","__webpack_require__","__WEBPACK_IMPORTED_MODULE_0_webextension_polyfill___default","n","__WEBPACK_IMPORTED_MODULE_2__targetSelector__","__WEBPACK_IMPORTED_MODULE_3__selenium_api__","__WEBPACK_IMPORTED_MODULE_4__selenium_browserbot__","__WEBPACK_IMPORTED_MODULE_5__locatorBuilders__","__WEBPACK_IMPORTED_MODULE_6__region__","__WEBPACK_IMPORTED_MODULE_7__prompt_injector__","selenium","Selenium","BrowserBot","createForWindow","window","locatorBuilders","LocatorBuilders","targetSelector","contentSideexTabId","doCommands","request","_sender","sendResponse","commands","preprocessParameter","new_page","sideex_new_page","page_done","sideex_page_done","ajax_done","sideex_ajax_done","dom_time","target","result","e","message","upperCase","charAt","toUpperCase","slice","document","body","setAttribute","returnValue","Promise","then","removeAttribute","catch","reason","mySideexTabId","prepareToInteract","rect","prepareToInteract_","locator","buildLocators","element","browserbot","findElement","locators","buildAll","resolveLocator","find","loc","strat","test","selectMode","selecting","TargetSelector","win","detach","Array","browser","runtime","sendMessage","selectTarget","selectNext","cancelSelectTarget","region","cleanup","removeRegion","editRegion","attach","_listener","onMessage","addListener","showElement","targetValue","resolve","__WEBPACK_IMPORTED_MODULE_0_compute_scroll_into_view__","isOptionsObject","options","keys","length","targetIsDetached","ownerDocument","documentElement","contains","behavior","computeOptions","block","inline","getOptions","actions","canSmoothScroll","style","forEach","_ref","el","top","left","scroll","scrollTop","scrollLeft","defaultBehavior","isElement","nodeType","canOverflow","overflow","skipOverflowHiddenElements","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","getComputedStyle","overflowY","overflowX","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","scrollMode","boundary","checkBoundary","node","TypeError","scrollingElement","frames","cursor","parentNode","push","viewportWidth","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","viewportX","scrollX","pageXOffset","viewportY","scrollY","pageYOffset","_target$getBoundingCl","getBoundingClientRect","targetHeight","targetWidth","targetTop","targetRight","right","targetBottom","bottom","targetLeft","targetBlock","targetInline","computations","index","frame","_frame$getBoundingCli","_height","_width","_top","_left","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","Math","max","min","unescapeHtml","str","replace","escapeAttr","spaceS","spaceE","tempStr","tempAttr","tempValue","processedTag","flag","finishedProcessing","indexOf","substring","equal","quotS","quotE","lastIndexOf","replaceChar","dquotS","dquotE","doEscape","m","&","\"","'","<",">","checkType","cutStr","replaceStr","mode","charType","pos","doFlag","ampersandExists","escapeHTML","smallIndex","greatIndex","tempTag","processed","tempSmallIndex","tagsExists","__WEBPACK_IMPORTED_MODULE_1_scroll_into_view_if_needed__","__WEBPACK_IMPORTED_MODULE_2__SeleniumError__","__WEBPACK_IMPORTED_MODULE_3__commands_api__","__WEBPACK_IMPORTED_MODULE_4__escape__","__WEBPACK_IMPORTED_MODULE_5__selenium_browserbot__","__WEBPACK_IMPORTED_MODULE_6__closure_polyfill__","__WEBPACK_IMPORTED_MODULE_7__PatternMatcher__","__WEBPACK_IMPORTED_MODULE_8__utils__","constructor","optionLocatorFactory","OptionLocatorFactory","page","defaultTimeout","DEFAULT_TIMEOUT","mouseSpeed","DEFAULT_MOUSE_SPEED","throwIfNoVarNameProvided","varName","Error","waitUntil","condition","timeout","failureMessage","reject","count","retryInterval","interval","setInterval","clearInterval","error","x","coords","triggerMouseEvent","Number","defaultView","SeleniumError","RIGHT_MOUSE_CLICK","decorateFunctionWithTimeout","f","callback","timeoutTime","getTimeoutTime","Date","getTime","proxyInjectionMode","location","prototype","reset","selectWindow","resetPopups","eval","script","argv","scoped","isExpression","JSON","stringify","doEvaluateConditional","doVerifyChecked","type","checked","doVerifyNotChecked","doVerifyEditable","isEditable","doVerifyNotEditable","doVerifySelectedValue","doVerifyNotSelectedValue","doVerifyText","doAssertText","doVerifyNotText","doAssertNotText","doVerifyValue","doVerifyTitle","goog","string","normalizeSpaces","getTitle","doVerifyElementPresent","match","doVerifyElementNotPresent","doVerify","variableName","expected","doAssert","res","rej","getVar","variable","actual","doAssertChecked","doAssertNotChecked","doAssertEditable","doAssertNotEditable","doAssertSelectedValue","doVerifySelectedLabel","selectLocator","selectedLabel","findSelectedOptionProperty","doAssertSelectedLabel","doAssertNotSelectedValue","findElementVisible","bot","dom","isShown","visibleText","getVisibleText","trim","doAssertValue","doAssertTitle","doAssertElementPresent","doAssertElementNotPresent","doStore","storeStr","storeVar","doStoreEval","doStoreJson","json","parse","doStoreText","text","innerHTML","doStoreValue","doStoreTitle","doc","getDocument","title","doStoreXpathCount","xpath","evaluateXPathCount","doStoreAttribute","attributeValue","findAttribute","doWaitForElementPresent","isElementPresent","bind","doWaitForElementNotPresent","doWaitForElementVisible","unableToLocateTargetElementError","isNotEditable","doWaitForElementNotVisible","isVisible","doWaitForElementEditable","doWaitForElementNotEditable","doWaitPreparation","doPrePageWait","doPageWait","doAjaxWait","getCoords","coordString","action","rightClick","shiftKeyDown","core","doMetaKeyDown","doubleClick","doContextMenuAt","metaKeyDown","events","metaKeyDown_","y","doMetaKeyUp","findToggleButton","getSpeed","form","formLocator","makePageLoadCondition","ignoreResponseCode","doOpenWindow","windowID","_isNewPageLoaded","_abortXhrRequest","doOpen","url","targetWindow","opener","getCurrentWindow","readyState","doWaitForPopUp","dontCheckAlertsAndConfirms","hasAlerts","getNextAlert","getAlert","hasPrompts","Assert","fail","getNextPrompt","getLocation","getPrompt","table","rows","row","cells","col","getSelectedIndexes","getSelectedLabels","findSelectedOptionProperties","getSelectedLabel","getSelectedValues","getSelectedId","isSomethingSelected","getSelectedIndex","selectedOptions","bodyText","PatternMatcher","patternMatcher","strategy","tagName","toLowerCase","String","visibility","findEffectiveStyleProperty","_isDisplayed","matcher","strategies","globContains","pattern","exact","currentStyle","readOnlyNode","getAttributeNode","nodeValue","readOnly","getAllButtons","property","propertyValue","findEffectiveStyle","undefined","doSetMouseSpeed","getAllLinks","doDragAndDrop","getAllFields","screen","pixels","getMouseSpeed","screenX","moveTo","resizeTo","availWidth","position","focus","setSelectionRange","browserVersion","previousSibling","offsetParent","locator1","element2","locator2","element1","_isCommentOrEmptyTextNode","data","getElementPositionLeft","parentBorder","border","isNaN","getElementHeight","getAttribute","elementParent","offsetLeft","getElementPositionTop","getCursorPosition","all","clientTop","selectionStart","getExpression","elementRange","selection","isOpera","selectRange","createRange","duplicate","createTextRange","move","setEndPoint","currentKeyIndex","currentKey","doWaitForFrameToLoad","_frameAddress","getCookieByName","isCookiePresent","abortXhrRequest","doWaitForPageToLoad","absent","nameValuePair","optionsString","log","toString","replaceKeys","shift","name","doDeleteCookie","v","doExecuteScript","domain","path","cookieNames","backupManager","backup","loop","requiresCallBack","commandStarted","rollupName","kwargs","findOption","locatorType","idMatcher","doChooseCancelOnNextPrompt","label","cancelNextPrompt","setNextPromptResult","answer","doAssertPrompt","labelMatcher","getPromptMessage","actualMessage","assertSelected","selectedIndex","matches","doEditContent","contentEditable","doAnswerOnNextPrompt","__WEBPACK_IMPORTED_MODULE_5__PatternMatcher__","MozillaBrowserBot","BrowserVersion","[object Object]","topLevelApplicationWindow","topWindow","topFrame","baseUrl","href","__WEBPACK_IMPORTED_MODULE_3__closure_polyfill__","setWindow","buttonWindow","currentWindow","currentWindowName","allowNativeXpath","xpathEvaluator","XPathEvaluator","isSubFrameSelected","altKeyDown","controlKeyDown","hasConfirmations","recordedConfirmations","getNextConfirmation","relayBotToRC","screenY","canBubble","xhr","view","evt","xhrStatusText","initMouseEvent","uniqueId","pollingForLoad","permDeniedCount","windowPollers","assign","PageBot","_registerAllLocatorFunctions","recordPageLoad","newPageLoaded","isNewPageLoaded","pageLoadError","isXhrSent","isXhrDone","xhrResponseCode","xhrOpenLocation","abortXhr","__WEBPACK_IMPORTED_MODULE_1__SeleniumError__","setAllowNativeXPath","allow","setIgnoreAttributesWithoutValue","ignore","setXPathEngine","engineName","setCurrentEngine","getXPathEngine","getCurrentEngine","encodeURIComponentWithASPHack","uri","aggressiveEncoding","encodeURIComponent","triggerDragEvent","getXpathOfElement","isIE","parentElement","siblingElement","children","tagCount","totalTagCount","isFound","OperaBrowserBot","isSafari","windowName","createElement","openedWindow","myOriginalOpen","windowFeatures","replaceFlag","_windowClosed","c","closed","ignored","seleniumKey","oldMarker","isPollingForLoad","windowObject","ex","console","htaSubFrame","_isHTASubFrame","_modifyWindow","frameElement","marker","_selectTopWindow","_selectWindowByWindowId","locatorValue","_selectWindowByTitle","_selectWindowByName","selectPopUp","windowId","_selectFirstNonTopWindow","getWindowByName","getWindowNameByTitle","names","getNonTopWindowNames","selectFrame","substr","parent","_getFrameElement","contentWindow","pollForLoad","parentContainsIdenticallyNamedFrame","doesThisFrameMatchFrameExpression","t","isDom","mySandbox","currentFrameString","Components","utils","_getFrameElementByName","autWindow","permDenied","currentFrame","locateElementByName","method","status","onreadystatechange","newMarker","setRequestHeader","send","statusText","modifySeparateTestWindowToDetectPageLoads","currentlySelectedWindow","currentlySelectedWindowMarker","isHTA","child","loadFunction","openedWindows","open","setIFrameLocation","iframe","src","getCurrentPage","windowNeedsModifying","appInfo","classes","getService","interfaces","nsIXULAppInfo","currentHash","currentHref","nsIVersionComparator","originalHash","originalHref","modifyWindowToRecordPopUpDialogs","originalWindow","browserBot","markedLoc","firefox","unwrap","windowToModify","seleniumAlert","alert","recordedAlerts","call","confirm","nextConfirmResult","prompt","recordedPrompts","nextPromptResult","originalOpenReference","originalOpen","newOpen","__WEBPACK_IMPORTED_MODULE_2__commands_api__","newOpenReference","setOriginalRef","sameLoc","_isSameDocument","originalDocument","currentDocument","getElementsByTagName","getReadyState","XXXreschedulePoller","oldPollers","doNotModify","windowTitle","_isSamePage","originalLocation","rs","isSamePage","nonTopWindowNames","_handleClosedSubFrame","currentLocation","sameDoc","sameHref","testWindow","setShouldHighlightElement","shouldHighlight","isKonqueror","shouldHighlightLocatedElement","locationStrategies","cookieName","_recursivelyDeleteCookieDomains","deleted","findElementOrNull","button","buttonName","createTextNode","appendChild","tools","getElementById","onclick","removeChild","setTimeout","reschedulePoller","runScheduledPollers","locateElementById","identifier","inWindow","inDocument","elements","ok","Sandbox","domTraversal","window_","locateElementByXPath","selectSingleNode","findElementBy","locatorFunction","evaluateCssCount","selector","parse_locator","startsWith","ck","cookie","ckPairs","split","ckNameValue","decodeURIComponent","join","getAllCookieNames","ckName","getAllRawCookieNames","deleteCookie","_cookieName","expireDateInMilliseconds","rawCookieNames","rawCookieNumber","toGMTString","locateElementByLinkText","linkText","links","addSelection","option","using","checkMultiselect","EventType","FOCUS","CHANGE","inject","cache","addElement","toReturn","actualValue","clickElement","clientY","_fireEventOnElement","clientX","_modifyElementTarget","findClickableElement","attributes","getTagName","setNextConfirmationResult","selectElements","filter","confirmationResponse","postMessage","KonquerorBrowserBot","evalInSandbox","locateElementByStoredReference","prefix","locateElementByWebDriver","SafariBrowserBot","IEBrowserBot","createNSResolver","oldShowModalDialog","showModalDialog","__WEBPACK_IMPORTED_MODULE_4__utils__","findElements","runOptions","runInterval","css","testRunnerURL","canAccessThisWindow","canAccessCurrentlySelectedWindow","attributePos","elementLocator","attributeName","isDefAndNotNull","optionToSelect","fire","changed","selected","removeSelection","multiple","replaceText","stringValue","SELECT","maxLengthAttr","maxLength","designMode","doubleClickElement","contextMenuOnElement","newTarget","openWindow","hasAttribute","_handleClickingImagesInsideLinks","itrElement","_getTargetWindow","_getFrameFromGlobal","id","goBack","history","back","goForward","forward","close","selectElementsBy","filterType","filterFunction","filterFunctions","selectedElements","filterExpr","defaultFilterType","currentPath","locateElementByCss","promptResponse","direction","command","promptMessage","getConfirmationMessage","confirmationMessage","getAlertMessage","alertResponse","alertMessage","super","eventType","base_ref","fullURL","escape","modalDialogTest","args","features","pageUnloading","pageUnloadDetector","addEventListener","attachEvent","refresh","actuallyReload","reload","removeEventListener","isDefined","wasChecked","de","locateElementByIdentifer","pathname","selectStrategy","re","regexpFromGlobContains","convertGlobMetaCharsToRegexpMetaChars","strategyName","possibleNewStrategyName","RegExp","$1","possibleNewPattern","$2","matchStrategy","__WEBPACK_IMPORTED_MODULE_0__SeleniumError__","regexp","regexpString","regex","regexpi","regexi","globString","glob","regexpFromGlob","349","406","cleanupCallback","div","insertBefore","firstChild","r","banner","header","img","getURL","span","innerText","highlight","preventDefault","stopPropagation","elementFromPoint","highlightElement","or"],"mappings":"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","file":"playback.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*\r\n * Copyright 2017 SideeX committers\r\n *\r\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n *  you may not use this file except in compliance with the License.\r\n *  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\nimport browser from 'webextension-polyfill'\r\nimport './closure-polyfill'\r\nimport TargetSelector from './targetSelector'\r\nimport Selenium from './selenium-api'\r\nimport BrowserBot from './selenium-browserbot'\r\nimport LocatorBuilders from './locatorBuilders'\r\nimport { editRegion, removeRegion } from './region'\r\nimport { attach } from './prompt-injector'\r\n\r\nexport const selenium = new Selenium(BrowserBot.createForWindow(window, true))\r\nconst locatorBuilders = new LocatorBuilders(window)\r\nlet contentSideexTabId = window.contentSideexTabId\r\nlet targetSelector\r\n\r\nattach(selenium)\r\n\r\nfunction doCommands(request, _sender, sendResponse) {\r\n  if (request.commands) {\r\n    if (request.commands == 'waitPreparation') {\r\n      selenium['doWaitPreparation']('', selenium.preprocessParameter(''))\r\n      sendResponse({})\r\n    } else if (request.commands == 'prePageWait') {\r\n      selenium['doPrePageWait']('', selenium.preprocessParameter(''))\r\n      sendResponse({ new_page: window.sideex_new_page })\r\n    } else if (request.commands == 'pageWait') {\r\n      selenium['doPageWait']('', selenium.preprocessParameter(''))\r\n      sendResponse({ page_done: window.sideex_page_done })\r\n    } else if (request.commands == 'ajaxWait') {\r\n      selenium['doAjaxWait']('', selenium.preprocessParameter(''))\r\n      sendResponse({ ajax_done: window.sideex_ajax_done })\r\n    } else if (request.commands == 'domWait') {\r\n      selenium['doDomWait']('', selenium.preprocessParameter(''))\r\n      sendResponse({ dom_time: window.sideex_new_page })\r\n    } else if (request.commands === 'evaluateConditional') {\r\n      try {\r\n        let value = selenium['doEvaluateConditional'](request.target)\r\n        sendResponse({ result: 'success', value: value })\r\n      } catch (e) {\r\n        sendResponse({ result: e.message })\r\n      }\r\n    } else {\r\n      const upperCase =\r\n        request.commands.charAt(0).toUpperCase() + request.commands.slice(1)\r\n      if (selenium['do' + upperCase] != null) {\r\n        try {\r\n          document.body.setAttribute('SideeXPlayingFlag', true)\r\n          let returnValue = selenium['do' + upperCase](\r\n            selenium.preprocessParameter(request.target),\r\n            selenium.preprocessParameter(request.value)\r\n          )\r\n          if (returnValue instanceof Promise) {\r\n            // The command is a asynchronous function\r\n            returnValue\r\n              .then(function() {\r\n                // Asynchronous command completed successfully\r\n                document.body.removeAttribute('SideeXPlayingFlag')\r\n                sendResponse({ result: 'success' })\r\n              })\r\n              .catch(function(reason) {\r\n                // Asynchronous command failed\r\n                document.body.removeAttribute('SideeXPlayingFlag')\r\n                sendResponse({ result: reason })\r\n              })\r\n          } else {\r\n            // Synchronous command completed successfully\r\n            document.body.removeAttribute('SideeXPlayingFlag')\r\n            sendResponse({ result: 'success' })\r\n          }\r\n        } catch (e) {\r\n          // Synchronous command failed\r\n          document.body.removeAttribute('SideeXPlayingFlag')\r\n          sendResponse({ result: e.message })\r\n        }\r\n      } else {\r\n        sendResponse({ result: 'Unknown command: ' + request.commands })\r\n      }\r\n    }\r\n\r\n    //do every command need giving sideex id\r\n    if (contentSideexTabId === -1) {\r\n      contentSideexTabId = request.mySideexTabId\r\n    }\r\n    return true\r\n  }\r\n  if (request.prepareToInteract) {\r\n    sendResponse({\r\n      result: 'success',\r\n      rect: selenium.prepareToInteract_(request.locator),\r\n    })\r\n  }\r\n  if (request.buildLocators) {\r\n    try {\r\n      const element = selenium.browserbot.findElement(request.locator)\r\n      const locators = locatorBuilders.buildAll(element)\r\n      sendResponse({ result: 'success', locators })\r\n    } catch (e) {\r\n      sendResponse({ result: e.message })\r\n    }\r\n  }\r\n  if (request.resolveLocator) {\r\n    try {\r\n      const element = selenium.browserbot.findElement(request.locator)\r\n      const locator = locatorBuilders\r\n        .buildAll(element)\r\n        .find(([loc, strat]) => /^xpath/.test(strat))[0] //eslint-disable-line no-unused-vars\r\n      sendResponse({ result: 'success', locator })\r\n    } catch (e) {\r\n      sendResponse({ result: e.message })\r\n    }\r\n  }\r\n  if (request.selectMode) {\r\n    sendResponse(true)\r\n    if (request.selecting && request.element) {\r\n      targetSelector = new TargetSelector(\r\n        function(element, win) {\r\n          if (element && win) {\r\n            const target = locatorBuilders.buildAll(element)\r\n            locatorBuilders.detach()\r\n            if (target != null && target instanceof Array) {\r\n              if (target) {\r\n                //self.editor.treeView.updateCurrentCommand('targetCandidates', target);\r\n                browser.runtime.sendMessage({\r\n                  selectTarget: true,\r\n                  target: target,\r\n                  selectNext: request.selectNext,\r\n                })\r\n              }\r\n            }\r\n          }\r\n          targetSelector = null\r\n        },\r\n        function() {\r\n          browser.runtime.sendMessage({\r\n            cancelSelectTarget: true,\r\n          })\r\n        }\r\n      )\r\n    } else if (request.selecting && request.region) {\r\n      editRegion(request.rect, target => {\r\n        if (target) {\r\n          browser.runtime.sendMessage({\r\n            selectTarget: true,\r\n            target: [[target]],\r\n            selectNext: request.selectNext,\r\n          })\r\n        } else {\r\n          browser.runtime.sendMessage({\r\n            cancelSelectTarget: true,\r\n            selectNext: request.selectNext,\r\n          })\r\n        }\r\n      })\r\n    } else {\r\n      if (targetSelector) {\r\n        targetSelector.cleanup()\r\n        targetSelector = null\r\n        return\r\n      } else {\r\n        removeRegion()\r\n        return\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// show element\r\nfunction startShowElement(message) {\r\n  if (message.showElement) {\r\n    try {\r\n      const result = selenium['doShowElement'](message.targetValue)\r\n      return Promise.resolve({ result: result })\r\n    } catch (e) {\r\n      // If we didn't find the element, it means that another frame might have found it,\r\n      // so we don't resolve the promise. If no frame finds it, then the promise will\r\n      // get rejected.\r\n    }\r\n  }\r\n}\r\n\r\nif (!window._listener) {\r\n  window._listener = doCommands\r\n  browser.runtime.onMessage.addListener(startShowElement)\r\n  browser.runtime.onMessage.addListener(doCommands)\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/commands-api.js","import compute from 'compute-scroll-into-view';\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\n\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n\n  var canSmoothScroll = 'scrollBehavior' in document.body.style;\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n        top = _ref.top,\n        left = _ref.left;\n\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\n\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n\n  if (isOptionsObject(options)) {\n    return options;\n  }\n\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\n\nfunction scrollIntoView(target, options) {\n  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);\n\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(targetIsDetached ? [] : compute(target, options));\n  }\n\n  if (targetIsDetached) {\n    return;\n  }\n\n  var computeOptions = getOptions(options);\n  return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);\n}\n\nexport default scrollIntoView;\n\n\n//////////////////\n// WEBPACK FOOTER\n// /mnt/c/yc/instantapi/selenium-ide/node_modules/scroll-into-view-if-needed/es/index.js\n// module id = 167\n// module chunks = 1 2","function isElement(el) {\n  return el != null && typeof el === 'object' && el.nodeType === 1;\n}\n\nfunction canOverflow(overflow, skipOverflowHiddenElements) {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false;\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip';\n}\n\nfunction isScrollable(el, skipOverflowHiddenElements) {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    var style = getComputedStyle(el, null);\n    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements);\n  }\n\n  return false;\n}\n\nfunction alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n    return 0;\n  }\n\n  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n  }\n\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n  }\n\n  return 0;\n}\n\nexport default (function (target, options) {\n  var scrollMode = options.scrollMode,\n      block = options.block,\n      inline = options.inline,\n      boundary = options.boundary,\n      skipOverflowHiddenElements = options.skipOverflowHiddenElements;\n  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {\n    return node !== boundary;\n  };\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target');\n  }\n\n  var scrollingElement = document.scrollingElement || document.documentElement;\n  var frames = [];\n  var cursor = target;\n\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    cursor = cursor.parentNode;\n\n    if (cursor === scrollingElement) {\n      frames.push(cursor);\n      break;\n    }\n\n    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {\n      continue;\n    }\n\n    if (isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor);\n    }\n  }\n\n  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;\n  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;\n  var viewportX = window.scrollX || pageXOffset;\n  var viewportY = window.scrollY || pageYOffset;\n\n  var _target$getBoundingCl = target.getBoundingClientRect(),\n      targetHeight = _target$getBoundingCl.height,\n      targetWidth = _target$getBoundingCl.width,\n      targetTop = _target$getBoundingCl.top,\n      targetRight = _target$getBoundingCl.right,\n      targetBottom = _target$getBoundingCl.bottom,\n      targetLeft = _target$getBoundingCl.left;\n\n  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;\n  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;\n  var computations = [];\n\n  for (var index = 0; index < frames.length; index++) {\n    var frame = frames[index];\n\n    var _frame$getBoundingCli = frame.getBoundingClientRect(),\n        _height = _frame$getBoundingCli.height,\n        _width = _frame$getBoundingCli.width,\n        _top = _frame$getBoundingCli.top,\n        right = _frame$getBoundingCli.right,\n        bottom = _frame$getBoundingCli.bottom,\n        _left = _frame$getBoundingCli.left;\n\n    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= _top && targetBottom <= bottom && targetLeft >= _left && targetRight <= right) {\n      return computations;\n    }\n\n    var frameStyle = getComputedStyle(frame);\n    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\n    var borderTop = parseInt(frameStyle.borderTopWidth, 10);\n    var borderRight = parseInt(frameStyle.borderRightWidth, 10);\n    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\n    var blockScroll = 0;\n    var inlineScroll = 0;\n    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;\n    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;\n\n    if (scrollingElement === frame) {\n      if (block === 'start') {\n        blockScroll = targetBlock;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - viewportHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth;\n      } else {\n        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\n      }\n\n      blockScroll = Math.max(0, blockScroll + viewportY);\n      inlineScroll = Math.max(0, inlineScroll + viewportX);\n    } else {\n      if (block === 'start') {\n        blockScroll = targetBlock - _top - borderTop;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(_top, bottom, _height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - (_top + _height / 2) + scrollbarHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - _left - borderLeft;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (_left + _width / 2) + scrollbarWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth;\n      } else {\n        inlineScroll = alignNearest(_left, right, _width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\n      }\n\n      var scrollLeft = frame.scrollLeft,\n          scrollTop = frame.scrollTop;\n      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - _height + scrollbarHeight));\n      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - _width + scrollbarWidth));\n      targetBlock += scrollTop - blockScroll;\n      targetInline += scrollLeft - inlineScroll;\n    }\n\n    computations.push({\n      el: frame,\n      top: blockScroll,\n      left: inlineScroll\n    });\n  }\n\n  return computations;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// /mnt/c/yc/instantapi/selenium-ide/node_modules/compute-scroll-into-view/es/index.js\n// module id = 168\n// module chunks = 1 2","/*\r\n * Copyright 2017 SideeX committers\r\n *\r\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n *  you may not use this file except in compliance with the License.\r\n *  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\n\r\n// change HTML entities to sign\r\nexport function unescapeHtml(str) {\r\n  return str\r\n    .replace(/&amp;/gi, '&')\r\n    .replace(/&quot;/gi, '\"')\r\n    .replace(/&lt;/gi, '<')\r\n    .replace(/&gt;/gi, '>')\r\n    .replace(/&#39;/gi, \"'\")\r\n}\r\n\r\nfunction escapeAttr(str) {\r\n  let spaceS = 0\r\n  let spaceE = -1\r\n  let tempStr = str\r\n  let tempAttr = ''\r\n  let tempValue = ''\r\n  let processedTag = ''\r\n  let flag = false\r\n  let finishedProcessing = false\r\n\r\n  do {\r\n    spaceS = str.indexOf(' ')\r\n    spaceE = str.indexOf(' ', spaceS + 1)\r\n\r\n    if (spaceE >= 0) {\r\n      while (str.charAt(spaceE - 1) != \"'\" && str.charAt(spaceE - 1) != '\"') {\r\n        spaceE = str.indexOf(' ', spaceE + 1)\r\n        if (spaceE < 0) break\r\n      }\r\n    }\r\n\r\n    //if there is space, then split string\r\n    if (spaceS >= 0 && spaceE >= 0) {\r\n      tempAttr = str.substring(spaceS + 1, spaceE)\r\n      tempStr = str.substring(0, spaceS + 1)\r\n      str = str.substring(spaceE)\r\n    } else if (spaceS >= 0 && spaceE < 0) {\r\n      tempAttr = str.substring(spaceS + 1, str.length - 1)\r\n      tempStr = str.substring(0, spaceS + 1)\r\n      str = ''\r\n    } else {\r\n      //flag is check that has string been processed\r\n      if (flag) processedTag += '>'\r\n      else processedTag = str\r\n      finishedProcessing = true\r\n      break\r\n    }\r\n\r\n    flag = true\r\n    let equal = tempAttr.indexOf('=')\r\n\r\n    if (tempAttr.charAt(equal + 1) == \"'\") {\r\n      //divide the single quote\r\n      if (tempAttr.indexOf(\"'\") != -1) {\r\n        let quotS = tempAttr.indexOf(\"'\")\r\n        let quotE = tempAttr.lastIndexOf(\"'\")\r\n        tempValue = tempAttr.substring(quotS + 1, quotE)\r\n        tempAttr = tempAttr.substring(0, quotS + 1)\r\n        tempValue = replaceChar(tempValue)\r\n        tempAttr += tempValue + \"'\"\r\n      }\r\n    }\r\n    if (tempAttr.charAt(equal + 1) == '\"') {\r\n      //divide the double quote\r\n      if (tempAttr.indexOf('\"') != -1) {\r\n        let dquotS = tempAttr.indexOf('\"')\r\n        let dquotE = tempAttr.lastIndexOf('\"')\r\n        tempValue = tempAttr.substring(dquotS + 1, dquotE)\r\n        tempAttr = tempAttr.substring(0, dquotS + 1)\r\n        tempValue = replaceChar(tempValue)\r\n        tempAttr += tempValue + '\"'\r\n      }\r\n    }\r\n    //merge the splited string\r\n    processedTag += tempStr + tempAttr\r\n  } while (!finishedProcessing)\r\n\r\n  return processedTag\r\n}\r\n\r\n//escape the character \"<\".\">\".\"&\".\"'\".'\"'\r\nfunction doEscape(str) {\r\n  return str.replace(\r\n    /[&\"'<>]/g,\r\n    m =>\r\n      ({ '&': '&amp;', '\"': '&quot;', \"'\": '&#39;', '<': '&lt;', '>': '&gt;' }[\r\n        m\r\n      ])\r\n  )\r\n}\r\n\r\n//append\r\nfunction checkType(cutStr, replaceStr, mode) {\r\n  switch (mode) {\r\n    case 1:\r\n      return (cutStr += replaceStr + '&amp;')\r\n    case 2:\r\n      return (cutStr += replaceStr + '&quot;')\r\n    case 3:\r\n      return (cutStr += replaceStr + '&#39;')\r\n    case 4:\r\n      return (cutStr += replaceStr + '&lt;')\r\n    case 5:\r\n      return (cutStr += replaceStr + '&gt;')\r\n    default:\r\n      return cutStr\r\n  }\r\n}\r\n\r\n//avoid &amp; to escape &amp;amp;\r\nfunction replaceChar(str) {\r\n  //escape the character\r\n  let pos = -1\r\n  let cutStr = ''\r\n  let replaceStr = ''\r\n  let doFlag = 0\r\n  let charType\r\n  let ampersandExists = true\r\n\r\n  while (ampersandExists) {\r\n    pos = str.indexOf('&', pos + 1)\r\n    charType = 0\r\n    if (pos != -1) {\r\n      if (str.substring(pos, pos + 5) == '&amp;') {\r\n        charType = 1\r\n        replaceStr = str.substring(0, pos)\r\n        str = str.substring(pos + 5)\r\n      } else if (str.substring(pos, pos + 6) == '&quot;') {\r\n        charType = 2\r\n        replaceStr = str.substring(0, pos)\r\n        str = str.substring(pos + 6)\r\n      } else if (str.substring(pos, pos + 5) == '&#39;') {\r\n        charType = 3\r\n        replaceStr = str.substring(0, pos)\r\n        str = str.substring(pos + 5)\r\n      } else if (str.substring(pos, pos + 4) == '&lt;') {\r\n        charType = 4\r\n        replaceStr = str.substring(0, pos)\r\n        str = str.substring(pos + 4)\r\n      } else if (str.substring(pos, pos + 4) == '&gt;') {\r\n        charType = 5\r\n        replaceStr = str.substring(0, pos)\r\n        str = str.substring(pos + 4)\r\n      }\r\n\r\n      if (charType != 0) {\r\n        pos = -1\r\n        replaceStr = doEscape(replaceStr)\r\n        cutStr = checkType(cutStr, replaceStr, charType)\r\n        doFlag = 1\r\n      }\r\n    } else {\r\n      cutStr += str\r\n      ampersandExists = false\r\n    }\r\n  }\r\n  if (doFlag == 0) return doEscape(str)\r\n  else return cutStr\r\n}\r\n\r\n//check the HTML value\r\nexport function escapeHTML(str) {\r\n  let smallIndex = str.indexOf('<')\r\n  let greatIndex = str.indexOf('>')\r\n  let tempStr = ''\r\n  let tempTag = ''\r\n  let processed = ''\r\n  let tempSmallIndex = 0\r\n  let tagsExists = true\r\n\r\n  while (tagsExists) {\r\n    //find the less target\r\n    if (smallIndex >= 0) {\r\n      //find the greater target\r\n      if (greatIndex >= 0) {\r\n        do {\r\n          //split foreward string\r\n          smallIndex += tempSmallIndex\r\n          tempStr = str.substring(0, smallIndex)\r\n          //split the tags\r\n          tempTag = str.substring(smallIndex, greatIndex + 1)\r\n          tempSmallIndex = tempTag.lastIndexOf('<')\r\n        } while (tempSmallIndex != 0)\r\n\r\n        //escape attributes in the tag\r\n        tempTag = escapeAttr(tempTag)\r\n\r\n        str = str.substring(greatIndex + 1)\r\n        //check if the tag is script\r\n        // if(tempTag.toLowerCase().indexOf(\"script\")>=0)\r\n        // tempTag = replaceChar(tempTag);\r\n\r\n        //merge them up\r\n        processed += replaceChar(tempStr) + tempTag\r\n      } else {\r\n        replaceChar(str)\r\n        tagsExists = false\r\n        break\r\n      }\r\n    } else {\r\n      replaceChar(str)\r\n      tagsExists = false\r\n      break\r\n    }\r\n    //going to do next tag\r\n    smallIndex = str.indexOf('<')\r\n    greatIndex = 0\r\n    do {\r\n      //avoid other >\r\n      greatIndex = str.indexOf('>', greatIndex + 1)\r\n    } while (greatIndex < smallIndex && greatIndex != -1)\r\n  }\r\n\r\n  if (str != '') processed += replaceChar(str)\r\n\r\n  return processed\r\n}\r\n\r\nwindow.unescapeHtml = unescapeHtml\r\nwindow.escapeHTML = escapeHTML\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/escape.js","/*\r\n * Copyright 2011 Software Freedom Conservancy\r\n *\r\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n *  you may not use this file except in compliance with the License.\r\n *  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\n\r\nimport browser from 'webextension-polyfill'\r\nimport scrollIntoViewIfNeeded from 'scroll-into-view-if-needed'\r\nimport SeleniumError from './SeleniumError'\r\nimport { selenium } from './commands-api'\r\nimport { escapeHTML } from './escape'\r\nimport BrowserBot, { browserVersion } from './selenium-browserbot'\r\nimport goog, { bot, core } from './closure-polyfill'\r\nimport PatternMatcher from './PatternMatcher'\r\nimport {\r\n  getTagName,\r\n  getTimeoutTime,\r\n  extractExceptionMessage,\r\n  lowerFirstChar,\r\n} from './utils'\r\n\r\n// TODO: stop navigating this.browserbot.document() ... it breaks encapsulation\r\n\r\nexport default class Selenium {\r\n  /**\r\n   * Defines an object that runs Selenium commands.\r\n   *\r\n   * <h3><a name=\"locators\"></a>Element Locators</h3>\r\n   * <p>\r\n   * Element Locators tell Selenium which HTML element a command refers to.\r\n   * The format of a locator is:</p>\r\n   * <blockquote>\r\n   * <em>locatorType</em><strong>=</strong><em>argument</em>\r\n   * </blockquote>\r\n   *\r\n   * <p>\r\n   * We support the following strategies for locating elements:\r\n   * </p>\r\n   *\r\n   * <ul>\r\n   * <li><strong>identifier</strong>=<em>id</em>:\r\n   * Select the element with the specified &#064;id attribute. If no match is\r\n   * found, select the first element whose &#064;name attribute is <em>id</em>.\r\n   * (This is normally the default; see below.)</li>\r\n   * <li><strong>id</strong>=<em>id</em>:\r\n   * Select the element with the specified &#064;id attribute.</li>\r\n   *\r\n   * <li><strong>name</strong>=<em>name</em>:\r\n   * Select the first element with the specified &#064;name attribute.\r\n   * <ul class=\"first last simple\">\r\n   * <li>username</li>\r\n   * <li>name=username</li>\r\n   * </ul>\r\n   *\r\n   * <p>The name may optionally be followed by one or more <em>element-filters</em>, separated from the name by whitespace.  If the <em>filterType</em> is not specified, <strong>value</strong> is assumed.</p>\r\n   *\r\n   * <ul class=\"first last simple\">\r\n   * <li>name=flavour value=chocolate</li>\r\n   * </ul>\r\n   * </li>\r\n   * <li><strong>dom</strong>=<em>javascriptExpression</em>:\r\n   *\r\n   * Find an element by evaluating the specified string.  This allows you to traverse the HTML Document Object\r\n   * Model using JavaScript.  Note that you must not return a value in this string; simply make it the last expression in the block.\r\n   * <ul class=\"first last simple\">\r\n   * <li>dom=document.forms['myForm'].myDropdown</li>\r\n   * <li>dom=document.images[56]</li>\r\n   * <li>dom=function foo() { return document.links[1]; }; foo();</li>\r\n   * </ul>\r\n   *\r\n   * </li>\r\n   *\r\n   * <li><strong>xpath</strong>=<em>xpathExpression</em>:\r\n   * Locate an element using an XPath expression.\r\n   * <ul class=\"first last simple\">\r\n   * <li>xpath=//img[&#064;alt='The image alt text']</li>\r\n   * <li>xpath=//table[&#064;id='table1']//tr[4]/td[2]</li>\r\n   * <li>xpath=//a[contains(&#064;href,'#id1')]</li>\r\n   * <li>xpath=//a[contains(&#064;href,'#id1')]/&#064;class</li>\r\n   * <li>xpath=(//table[&#064;class='stylee'])//th[text()='theHeaderText']/../td</li>\r\n   * <li>xpath=//input[&#064;name='name2' and &#064;value='yes']</li>\r\n   * <li>xpath=//*[text()=\"right\"]</li>\r\n   *\r\n   * </ul>\r\n   * </li>\r\n   * <li><strong>link</strong>=<em>textPattern</em>:\r\n   * Select the link (anchor) element which contains text matching the\r\n   * specified <em>pattern</em>.\r\n   * <ul class=\"first last simple\">\r\n   * <li>link=The link text</li>\r\n   * </ul>\r\n   *\r\n   * </li>\r\n   *\r\n   * <li><strong>css</strong>=<em>cssSelectorSyntax</em>:\r\n   * Select the element using css selectors. Please refer to <a href=\"http://www.w3.org/TR/REC-CSS2/selector.html\">CSS2 selectors</a>, <a href=\"http://www.w3.org/TR/2001/CR-css3-selectors-20011113/\">CSS3 selectors</a> for more information. You can also check the TestCssLocators test in the selenium test suite for an example of usage, which is included in the downloaded selenium core package.\r\n   * <ul class=\"first last simple\">\r\n   * <li>css=a[href=\"#id3\"]</li>\r\n   * <li>css=span#firstChild + span</li>\r\n   * </ul>\r\n   * <p>Currently the css selector locator supports all css1, css2 and css3 selectors except namespace in css3, some pseudo classes(:nth-of-type, :nth-last-of-type, :first-of-type, :last-of-type, :only-of-type, :visited, :hover, :active, :focus, :indeterminate) and pseudo elements(::first-line, ::first-letter, ::selection, ::before, ::after). </p>\r\n   * </li>\r\n   *\r\n   * <li><strong>ui</strong>=<em>uiSpecifierString</em>:\r\n   * Locate an element by resolving the UI specifier string to another locator, and evaluating it. See the <a href=\"http://svn.openqa.org/fisheye/browse/~raw,r=trunk/selenium/trunk/src/main/resources/core/scripts/ui-doc.html\">Selenium UI-Element Reference</a> for more details.\r\n   * <ul class=\"first last simple\">\r\n   * <li>ui=loginPages::loginButton()</li>\r\n   * <li>ui=settingsPages::toggle(label=Hide Email)</li>\r\n   * <li>ui=forumPages::postBody(index=2)//a[2]</li>\r\n   * </ul>\r\n   * </li>\r\n   *\r\n   * </ul>\r\n   *\r\n   * <p>\r\n   * Without an explicit locator prefix, Selenium uses the following default\r\n   * strategies:\r\n   * </p>\r\n   *\r\n   * <ul class=\"simple\">\r\n   * <li><strong>dom</strong>, for locators starting with &quot;document.&quot;</li>\r\n   * <li><strong>xpath</strong>, for locators starting with &quot;//&quot;</li>\r\n   * <li><strong>identifier</strong>, otherwise</li>\r\n   * </ul>\r\n   *\r\n   * <h3><a name=\"element-filters\">Element Filters</a></h3>\r\n   * <blockquote>\r\n   * <p>Element filters can be used with a locator to refine a list of candidate elements.  They are currently used only in the 'name' element-locator.</p>\r\n   * <p>Filters look much like locators, ie.</p>\r\n   * <blockquote>\r\n   * <em>filterType</em><strong>=</strong><em>argument</em></blockquote>\r\n   *\r\n   * <p>Supported element-filters are:</p>\r\n   * <p><strong>value=</strong><em>valuePattern</em></p>\r\n   * <blockquote>\r\n   * Matches elements based on their values.  This is particularly useful for refining a list of similarly-named toggle-buttons.</blockquote>\r\n   * <p><strong>index=</strong><em>index</em></p>\r\n   * <blockquote>\r\n   * Selects a single element based on its position in the list (offset from zero).</blockquote>\r\n   * </blockquote>\r\n   *\r\n   * <h3><a name=\"patterns\"></a>String-match Patterns</h3>\r\n   *\r\n   * <p>\r\n   * Various Pattern syntaxes are available for matching string values:\r\n   * </p>\r\n   * <ul>\r\n   * <li><strong>glob:</strong><em>pattern</em>:\r\n   * Match a string against a \"glob\" (aka \"wildmat\") pattern. \"Glob\" is a\r\n   * kind of limited regular-expression syntax typically used in command-line\r\n   * shells. In a glob pattern, \"*\" represents any sequence of characters, and \"?\"\r\n   * represents any single character. Glob patterns match against the entire\r\n   * string.</li>\r\n   * <li><strong>regexp:</strong><em>regexp</em>:\r\n   * Match a string using a regular-expression. The full power of JavaScript\r\n   * regular-expressions is available.</li>\r\n   * <li><strong>regexpi:</strong><em>regexpi</em>:\r\n   * Match a string using a case-insensitive regular-expression.</li>\r\n   * <li><strong>exact:</strong><em>string</em>:\r\n   *\r\n   * Match a string exactly, verbatim, without any of that fancy wildcard\r\n   * stuff.</li>\r\n   * </ul>\r\n   * <p>\r\n   * If no pattern prefix is specified, Selenium assumes that it's a \"glob\"\r\n   * pattern.\r\n   * </p>\r\n   * <p>\r\n   * For commands that return multiple values (such as verifySelectOptions),\r\n   * the string being matched is a comma-separated list of the return values,\r\n   * where both commas and backslashes in the values are backslash-escaped.\r\n   * When providing a pattern, the optional matching syntax (i.e. glob,\r\n   * regexp, etc.) is specified once, as usual, at the beginning of the\r\n   * pattern.\r\n   * </p>\r\n   */\r\n  constructor(browserbot) {\r\n    this.browserbot = browserbot\r\n    this.optionLocatorFactory = new OptionLocatorFactory()\r\n    // DGF for backwards compatibility\r\n    this.page = function() {\r\n      return browserbot\r\n    }\r\n    this.defaultTimeout = Selenium.DEFAULT_TIMEOUT\r\n    this.mouseSpeed = Selenium.DEFAULT_MOUSE_SPEED\r\n  }\r\n}\r\n\r\nSelenium.DEFAULT_TIMEOUT = 30 * 1000\r\nSelenium.DEFAULT_MOUSE_SPEED = 10\r\nSelenium.RIGHT_MOUSE_CLICK = 2\r\n\r\nSelenium.decorateFunctionWithTimeout = function(f, timeout, callback) {\r\n  if (f == null) {\r\n    return null\r\n  }\r\n\r\n  let timeoutTime = getTimeoutTime(timeout)\r\n\r\n  return function() {\r\n    if (new Date().getTime() > timeoutTime) {\r\n      if (callback != null) {\r\n        callback()\r\n      }\r\n      throw new SeleniumError('Timed out after ' + timeout + 'ms')\r\n    }\r\n    return f()\r\n  }\r\n}\r\n\r\nSelenium.createForWindow = function(window, proxyInjectionMode) {\r\n  if (!window.location) {\r\n    throw 'error: not a window!'\r\n  }\r\n  return Selenium(BrowserBot.createForWindow(window, proxyInjectionMode))\r\n}\r\n\r\nSelenium.prototype.reset = function() {\r\n  this.defaultTimeout = Selenium.DEFAULT_TIMEOUT\r\n  // todo: this.browserbot.reset()\r\n  this.browserbot.selectWindow('null')\r\n  this.browserbot.resetPopups()\r\n}\r\n\r\nSelenium.prototype.eval = function(\r\n  script,\r\n  argv = [],\r\n  scoped = true,\r\n  isExpression = false\r\n) {\r\n  // we are still stringifying here, but we are not supporting passing HTMLElements anyway :)\r\n  // Single quotes are important! JSON.stringifies uses double quotes, to avoid syntax error we use single quotes!!\r\n  if (isExpression) {\r\n    return window.eval(\r\n      scoped\r\n        ? `((...arguments) => (${script}))(...JSON.parse('${JSON.stringify(\r\n            argv\r\n          )}'))`\r\n        : script\r\n    )\r\n  } else {\r\n    return window.eval(\r\n      scoped\r\n        ? `((...arguments) => {${script}})(...JSON.parse('${JSON.stringify(\r\n            argv\r\n          )}'))`\r\n        : script\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doEvaluateConditional = function(script) {\r\n  return !!this.eval(script.script, script.argv, true, true)\r\n}\r\n\r\nSelenium.prototype.doVerifyChecked = function(locator) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'checkbox' && element.type !== 'radio') {\r\n    throw new Error(\r\n      `Element with locator ${locator} is not a checkbox nor a radio button`\r\n    )\r\n  } else if (!element.checked) {\r\n    throw new Error(`Element with locator ${locator} is not checked`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyNotChecked = function(locator) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'checkbox' && element.type !== 'radio') {\r\n    throw new Error(\r\n      `Element with locator ${locator} is not a checkbox nor a radio button`\r\n    )\r\n  } else if (element.checked) {\r\n    throw new Error(`Element with locator ${locator} is checked`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyEditable = function(locator) {\r\n  if (!this.isEditable(locator)) {\r\n    throw new Error(`Element with locator ${locator} is not editable`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyNotEditable = function(locator) {\r\n  if (this.isEditable(locator)) {\r\n    throw new Error(`Element with locator ${locator} is editable`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifySelectedValue = function(locator, value) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'select-one') {\r\n    throw new Error(`Element with locator ${locator} is not a select`)\r\n  } else if (element.value !== value) {\r\n    throw new Error(\r\n      \"Actual value '\" + element.value + \"' did not match '\" + value + \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyNotSelectedValue = function(locator, value) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'select-one') {\r\n    throw new Error(`Element with locator ${locator} is not a select`)\r\n  } else if (element.value === value) {\r\n    throw new Error(\"Actual value '\" + element.value + \"' did match\")\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyText = function(locator, value) {\r\n  this.doAssertText(locator, value)\r\n}\r\n\r\nSelenium.prototype.doVerifyNotText = function(locator, value) {\r\n  this.doAssertNotText(locator, value)\r\n}\r\n\r\nSelenium.prototype.doVerifyValue = function(locator, value) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.value !== value) {\r\n    throw new Error(\r\n      \"Actual value '\" + element.value + \"' did not match '\" + value + \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyTitle = function(value) {\r\n  if (goog.string.normalizeSpaces(this.getTitle()) !== value) {\r\n    throw new Error(\r\n      \"Actual value '\" +\r\n        goog.string.normalizeSpaces(this.getTitle()) +\r\n        \"' did not match '\" +\r\n        value +\r\n        \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyElementPresent = function(locator) {\r\n  try {\r\n    this.browserbot.findElement(locator)\r\n  } catch (error) {\r\n    if (error.message.match(/Element[\\s\\S]*?not found/)) {\r\n      throw new Error(`Element with locator ${locator} could not be found`)\r\n    } else {\r\n      throw error\r\n    }\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifyElementNotPresent = function(locator) {\r\n  try {\r\n    this.browserbot.findElement(locator)\r\n    throw new Error(`Element with locator ${locator} was found`)\r\n  } catch (error) {\r\n    if (!error.message.match(/Element[\\s\\S]*?not found/)) {\r\n      throw error\r\n    }\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerify = function(variableName, expected) {\r\n  return this.doAssert(variableName, expected)\r\n}\r\n\r\nSelenium.prototype.doAssert = function(variableName, expected) {\r\n  return new Promise((res, rej) => {\r\n    browser.runtime\r\n      .sendMessage({\r\n        getVar: true,\r\n        variable: variableName,\r\n      })\r\n      .then(actual => {\r\n        if (`${actual}` != expected) {\r\n          return rej(\r\n            \"Actual value '\" + actual + \"' did not match '\" + expected + \"'\"\r\n          )\r\n        }\r\n        return res()\r\n      })\r\n  })\r\n}\r\n\r\nSelenium.prototype.doAssertChecked = function(locator) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'checkbox' && element.type !== 'radio') {\r\n    throw new Error(\r\n      `Element with locator ${locator} is not a checkbox nor a radio button`\r\n    )\r\n  } else if (!element.checked) {\r\n    throw new Error(`Element with locator ${locator} is not checked`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertNotChecked = function(locator) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'checkbox' && element.type !== 'radio') {\r\n    throw new Error(\r\n      `Element with locator ${locator} is not a checkbox nor a radio button`\r\n    )\r\n  } else if (element.checked) {\r\n    throw new Error(`Element with locator ${locator} is checked`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertEditable = function(locator) {\r\n  if (!this.isEditable(locator)) {\r\n    throw new Error(`Element with locator ${locator} is not editable`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertNotEditable = function(locator) {\r\n  if (this.isEditable(locator)) {\r\n    throw new Error(`Element with locator ${locator} is editable`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertSelectedValue = function(locator, value) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'select-one') {\r\n    throw new Error(`Element with locator ${locator} is not a select`)\r\n  } else if (element.value !== value) {\r\n    throw new Error(\r\n      \"Actual value '\" + element.value + \"' did not match '\" + value + \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doVerifySelectedLabel = function(selectLocator, value) {\r\n  let selectedLabel = this.findSelectedOptionProperty(selectLocator, 'text')\r\n  if (selectedLabel !== value) {\r\n    throw new Error(\r\n      \"Actual label '\" + selectedLabel + \"' did not match '\" + value + \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertSelectedLabel = function(selectLocator, value) {\r\n  let selectedLabel = this.findSelectedOptionProperty(selectLocator, 'text')\r\n  if (selectedLabel !== value) {\r\n    throw new Error(\r\n      \"Actual label '\" + selectedLabel + \"' did not match '\" + value + \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertNotSelectedValue = function(locator, value) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.type !== 'select-one') {\r\n    throw new Error(`Element with locator ${locator} is not a select`)\r\n  } else if (element.value === value) {\r\n    throw new Error(\"Actual value '\" + element.value + \"' did match\")\r\n  }\r\n}\r\n\r\nSelenium.prototype.findElementVisible = function(locator) {\r\n  const element = this.browserbot.findElement(locator)\r\n  if (!bot.dom.isShown(element))\r\n    throw new Error(`Element ${locator} not visible`)\r\n  return element\r\n}\r\n\r\nSelenium.prototype.doAssertText = function(locator, value) {\r\n  const element = this.findElementVisible(locator)\r\n  const visibleText = bot.dom.getVisibleText(element).trim()\r\n  if (visibleText !== value) {\r\n    throw new Error(`Actual value \"${visibleText}\" did not match \"${value}\"`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertNotText = function(locator, value) {\r\n  const element = this.findElementVisible(locator)\r\n  const visibleText = bot.dom.getVisibleText(element).trim()\r\n  if (visibleText === value) {\r\n    throw new Error(`Actual value \"${visibleText}\" did match \"${value}\"`)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertValue = function(locator, value) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.value !== value) {\r\n    throw new Error(\r\n      \"Actual value '\" + element.value + \"' did not match '\" + value + \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertTitle = function(value) {\r\n  if (goog.string.normalizeSpaces(this.getTitle()) !== value) {\r\n    throw new Error(\r\n      \"Actual value '\" +\r\n        goog.string.normalizeSpaces(this.getTitle()) +\r\n        \"' did not match '\" +\r\n        value +\r\n        \"'\"\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertElementPresent = function(locator) {\r\n  try {\r\n    this.browserbot.findElement(locator)\r\n  } catch (error) {\r\n    if (error.message.match(/Element[\\s\\S]*?not found/)) {\r\n      throw new Error(`Element with locator ${locator} could not be found`)\r\n    } else {\r\n      throw error\r\n    }\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAssertElementNotPresent = function(locator) {\r\n  try {\r\n    this.browserbot.findElement(locator)\r\n    throw new Error(`Element with locator ${locator} was found`)\r\n  } catch (error) {\r\n    if (!error.message.match(/Element[\\s\\S]*?not found/)) {\r\n      throw error\r\n    }\r\n  }\r\n}\r\n\r\nfunction throwIfNoVarNameProvided(varName) {\r\n  if (!varName) {\r\n    throw new Error('No variable name provided.')\r\n  }\r\n}\r\n\r\nSelenium.prototype.doStore = function(value, varName) {\r\n  throwIfNoVarNameProvided(varName)\r\n  return browser.runtime.sendMessage({ storeStr: value, storeVar: varName })\r\n}\r\n\r\nSelenium.prototype.doStoreEval = function() {\r\n  throw new Error('store eval is obsolete please migrate to execute script')\r\n}\r\n\r\nSelenium.prototype.doStoreJson = function(json, varName) {\r\n  throwIfNoVarNameProvided(varName)\r\n  const result = JSON.parse(json)\r\n  return browser.runtime.sendMessage({ storeStr: result, storeVar: varName })\r\n}\r\n\r\nSelenium.prototype.doStoreText = function(locator, varName) {\r\n  throwIfNoVarNameProvided(varName)\r\n  let text\r\n  try {\r\n    // Try to get the text if the element is visible\r\n    const element = this.findElementVisible(locator)\r\n    text = bot.dom.getVisibleText(element).trim()\r\n  } catch (e) {\r\n    // element is not visible, but it may be due to the fact that it has no text\r\n    const element = this.browserbot.findElement(locator)\r\n    if (element.innerHTML === '') {\r\n      // element is empty then return empty string\r\n      text = ''\r\n    } else {\r\n      // element has content this is indeed invisible\r\n      throw e\r\n    }\r\n  }\r\n  return browser.runtime.sendMessage({\r\n    storeStr: text,\r\n    storeVar: varName,\r\n  })\r\n}\r\n\r\nSelenium.prototype.doStoreValue = function(locator, varName) {\r\n  throwIfNoVarNameProvided(varName)\r\n  let element = this.browserbot.findElement(locator)\r\n  return browser.runtime.sendMessage({\r\n    storeStr: element.value.trim(),\r\n    storeVar: varName,\r\n  })\r\n}\r\n\r\nSelenium.prototype.doStoreTitle = function(value, varName) {\r\n  throwIfNoVarNameProvided(varName)\r\n  let doc = selenium.browserbot.getDocument()\r\n  return browser.runtime.sendMessage({\r\n    storeStr: value || doc.title,\r\n    storeVar: varName,\r\n  })\r\n}\r\n\r\nSelenium.prototype.doStoreXpathCount = function(xpath, varName) {\r\n  throwIfNoVarNameProvided(varName)\r\n  let count = this.browserbot.evaluateXPathCount(\r\n    xpath,\r\n    this.browserbot.getDocument()\r\n  )\r\n  return browser.runtime.sendMessage({\r\n    storeStr: `${count}` || '0',\r\n    storeVar: varName,\r\n  })\r\n}\r\n\r\nSelenium.prototype.doStoreAttribute = function(locator, varName) {\r\n  throwIfNoVarNameProvided(varName)\r\n  let attributeValue = this.browserbot.findAttribute(locator)\r\n  return browser.runtime.sendMessage({\r\n    storeStr: attributeValue,\r\n    storeVar: varName,\r\n  })\r\n}\r\n\r\nfunction waitUntil(condition, target, timeout, failureMessage) {\r\n  if (!timeout) {\r\n    throw new Error('Timeout not specified.')\r\n  }\r\n  return new Promise(function(resolve, reject) {\r\n    let count = 0\r\n    let retryInterval = 100\r\n    let result\r\n    let interval = setInterval(function() {\r\n      if (count > timeout) {\r\n        clearInterval(interval)\r\n        reject(failureMessage)\r\n      }\r\n      try {\r\n        result = condition(target)\r\n      } catch (error) {\r\n        clearInterval(interval)\r\n        reject(error.message)\r\n      }\r\n      if (!result) {\r\n        count += retryInterval\r\n      } else if (result) {\r\n        clearInterval(interval)\r\n        resolve()\r\n      }\r\n    }, retryInterval)\r\n  })\r\n}\r\n\r\nSelenium.prototype.doWaitForElementPresent = function(locator, timeout) {\r\n  return waitUntil(\r\n    this.isElementPresent.bind(this),\r\n    locator,\r\n    timeout,\r\n    'Unable to find the target element within the timeout specified.'\r\n  )\r\n}\r\n\r\nSelenium.prototype.doWaitForElementNotPresent = function(locator, timeout) {\r\n  return waitUntil(\r\n    isElementNotPresent.bind(this),\r\n    locator,\r\n    timeout,\r\n    'Element still present on the page within the timeout specified.'\r\n  )\r\n}\r\n\r\nSelenium.prototype.doWaitForElementVisible = function(locator, timeout) {\r\n  return waitUntil(\r\n    isDisplayed.bind(this),\r\n    locator,\r\n    timeout,\r\n    'Element not visible on the page within the timeout specified.'\r\n  )\r\n}\r\n\r\nSelenium.prototype.doWaitForElementNotVisible = function(locator, timeout) {\r\n  return waitUntil(\r\n    isNotDisplayed.bind(this),\r\n    locator,\r\n    timeout,\r\n    'Element still visible on the page within the timeout specified.'\r\n  )\r\n}\r\n\r\nSelenium.prototype.doWaitForElementEditable = function(locator, timeout) {\r\n  return waitUntil(\r\n    isEditable.bind(this),\r\n    locator,\r\n    timeout,\r\n    'Element not editable within the timeout specified.'\r\n  )\r\n}\r\n\r\nSelenium.prototype.doWaitForElementNotEditable = function(locator, timeout) {\r\n  return waitUntil(\r\n    isNotEditable.bind(this),\r\n    locator,\r\n    timeout,\r\n    'Element still editable within the timeout specified.'\r\n  )\r\n}\r\n\r\n// xian\r\nSelenium.prototype.doWaitPreparation = function() {\r\n  // function setNewPageValue(e) {\r\n  //     window.new_page = true;\r\n  // };\r\n  // window.addEventListener(\"beforeunload\", setNewPageValue, false);\r\n\r\n  // if (window.XMLHttpRequest) {\r\n  //     // only override XMLHttpRequest once\r\n  //     if (!window.origXMLHttpRequest || !window.ajax_obj) {\r\n  //         // it's new page, so set the new window's XMLHttpRequest, and all of the obj in the ajax_obj\r\n  //         // are last window's instance, so clear it\r\n  //         window.ajax_obj = [];\r\n\r\n  //         window.origXMLHttpRequest = window.XMLHttpRequest;\r\n\r\n  //         window.XMLHttpRequest = function() {\r\n  //             var xhr = new window.origXMLHttpRequest();\r\n  //             window.ajax_obj.push(xhr);\r\n  //             return xhr;\r\n  //         }\r\n  //     }\r\n  // }\r\n\r\n  // function setDOMModifiedTime() {\r\n  //     window.domModifiedTime = Date.now();\r\n  // }\r\n  // var _win = window.document.body;\r\n  // _win.addEventListener(\"DOMNodeInserted\", setDOMModifiedTime, false);\r\n  // _win.addEventListener(\"DOMNodeInsertedIntoDocument\", setDOMModifiedTime, false);\r\n  // _win.addEventListener(\"DOMNodeRemoved\", setDOMModifiedTime, false);\r\n  // _win.addEventListener(\"DOMNodeRemovedFromDocument\", setDOMModifiedTime, false);\r\n  // _win.addEventListener(\"DOMSubtreeModified\", setDOMModifiedTime, false);\r\n\r\n  this.eval(\r\n    'function setNewPageValue(e) {window.new_page = true;};\\\r\n                window.addEventListener(\"beforeunload\", setNewPageValue, false);\\\r\n                if (window.XMLHttpRequest) {if (!window.origXMLHttpRequest || !window.ajax_obj) {\\\r\n                window.ajax_obj = []; window.origXMLHttpRequest = window.XMLHttpRequest;\\\r\n                window.XMLHttpRequest = function() { var xhr = new window.origXMLHttpRequest();\\\r\n                window.ajax_obj.push(xhr); return xhr;}}} function setDOMModifiedTime() {\\\r\n                window.domModifiedTime = Date.now();}var _win = window.document.body;\\\r\n                _win.addEventListener(\"DOMNodeInserted\", setDOMModifiedTime, false);\\\r\n                _win.addEventListener(\"DOMNodeInsertedIntoDocument\", setDOMModifiedTime, false);\\\r\n                _win.addEventListener(\"DOMNodeRemoved\", setDOMModifiedTime, false);\\\r\n                _win.addEventListener(\"DOMNodeRemovedFromDocument\", setDOMModifiedTime, false);\\\r\n                _win.addEventListener(\"DOMSubtreeModified\", setDOMModifiedTime, false);',\r\n    [],\r\n    false\r\n  )\r\n}\r\n\r\nSelenium.prototype.doPrePageWait = function() {\r\n  window.sideex_new_page = this.eval(\r\n    '(function() {return window.new_page;}())',\r\n    [],\r\n    false\r\n  )\r\n}\r\n\r\nSelenium.prototype.doPageWait = function() {\r\n  // if (window.document.readyState == \"complete\") {\r\n  //     return true;\r\n  // } else {\r\n  //     return false;\r\n  // }\r\n\r\n  let expression =\r\n    'if(window.document.readyState==\"complete\"){return true;}else{return false;}'\r\n  window.sideex_page_done = this.eval(\r\n    '(function() {' + expression + '}())',\r\n    [],\r\n    false\r\n  )\r\n}\r\n\r\nSelenium.prototype.doAjaxWait = function() {\r\n  // // check ajax wait\r\n  // if (window.ajax_obj) {\r\n  //     if (window.ajax_obj.length == 0) {\r\n  //         return true;\r\n  //     } else {\r\n  //         for (var index in window.ajax_obj) {\r\n  //         // if readyState is 1~3, then keep waiting\r\n  //             if (window.ajax_obj[index].readyState !== 4 &&\r\n  //                 window.ajax_obj[index].readyState !== undefined &&\r\n  //                 window.ajax_obj[index].readyState !== 0) {\r\n  //                     return false;\r\n  //             }\r\n  //         }\r\n  //         return true;\r\n  //     }\r\n  // } else {\r\n  //     if (window.origXMLHttpRequest) {\r\n  //         window.origXMLHttpRequest = \"\";\r\n  //     }\r\n  //     return true;\r\n  // }\r\n\r\n  let expression =\r\n    'if (window.ajax_obj) { if (window.ajax_obj.length == 0) {return true;} else {\\\r\n                      for (var index in window.ajax_obj) {\\\r\n                      if (window.ajax_obj[index].readyState !== 4 &&\\\r\n                      window.ajax_obj[index].readyState !== undefined &&\\\r\n                      window.ajax_obj[index].readyState !== 0) {return false;}}return true;}}\\\r\n                      else {if (window.origXMLHttpRequest) {window.origXMLHttpRequest = \"\";}return true;}'\r\n  window.sideex_ajax_done = this.eval(\r\n    '(function() {' + expression + '}())',\r\n    [],\r\n    false\r\n  )\r\n}\r\n\r\nSelenium.prototype.doDomWait = function() {\r\n  window.sideex_dom_time = this.eval(\r\n    '(function() {return window.domModifiedTime;}())',\r\n    [],\r\n    false\r\n  )\r\n}\r\n\r\nSelenium.prototype.doClick = function(locator) {\r\n  /**\r\n   * Clicks on a link, button, checkbox or radio button. If the click action\r\n   * causes a new page to load (like a link usually does), call\r\n   * waitForPageToLoad.\r\n   *\r\n   * @param locator an element locator\r\n   *\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  bot.action.click(element)\r\n}\r\n\r\nSelenium.prototype.doDoubleClick = function(locator) {\r\n  /**\r\n   * Double clicks on a link, button, checkbox or radio button. If the double click action\r\n   * causes a new page to load (like a link usually does), call\r\n   * waitForPageToLoad.\r\n   *\r\n   * @param locator an element locator\r\n   *\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  bot.action.doubleClick(element)\r\n}\r\n\r\nSelenium.prototype.doContextMenu = function(locator) {\r\n  /**\r\n   * Simulates opening the context menu for the specified element (as might happen if the user \"right-clicked\" on the element).\r\n   *\r\n   * @param locator an element locator\r\n   *\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  bot.action.rightClick(element)\r\n}\r\n\r\nSelenium.prototype.doClickAt = function(locator, coordString) {\r\n  /**\r\n   * Clicks on a link, button, checkbox or radio button. If the click action\r\n   * causes a new page to load (like a link usually does), call\r\n   * waitForPageToLoad.\r\n   *\r\n   * @param locator an element locator\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   *\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let coords = getCoords(element, coordString)\r\n  bot.action.click(element, coords)\r\n}\r\n\r\nSelenium.prototype.doDoubleClickAt = function(locator, coordString) {\r\n  /**\r\n   * Doubleclicks on a link, button, checkbox or radio button. If the action\r\n   * causes a new page to load (like a link usually does), call\r\n   * waitForPageToLoad.\r\n   *\r\n   * @param locator an element locator\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   *\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let coords = getCoords(element, coordString)\r\n  bot.action.doubleClick(element, coords)\r\n}\r\n\r\nSelenium.prototype.doContextMenuAt = function(locator, coordString) {\r\n  /**\r\n   * Simulates opening the context menu for the specified element (as might happen if the user \"right-clicked\" on the element).\r\n   *\r\n   * @param locator an element locator\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   *\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let coords = getCoords(element, coordString)\r\n  bot.action.rightClick(element, coords)\r\n}\r\n\r\nSelenium.prototype.doFocus = function(locator) {\r\n  /** Move the focus to the specified element; for example, if the element is an input field, move the cursor to that field.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.focus) {\r\n    element.focus()\r\n  } else {\r\n    bot.events.fire(element, bot.events.EventType.FOCUS)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doShiftKeyDown = function() {\r\n  /**\r\n   * Press the shift key and hold it down until doShiftUp() is called or a new page is loaded.\r\n   *\r\n   */\r\n  this.browserbot.shiftKeyDown = true\r\n  core.events.shiftKeyDown_ = true\r\n}\r\n\r\nSelenium.prototype.doShiftKeyUp = function() {\r\n  /**\r\n   * Release the shift key.\r\n   *\r\n   */\r\n  this.browserbot.shiftKeyDown = false\r\n  core.events.shiftKeyDown_ = false\r\n}\r\n\r\nSelenium.prototype.doMetaKeyDown = function() {\r\n  /**\r\n   * Press the meta key and hold it down until doMetaUp() is called or a new page is loaded.\r\n   *\r\n   */\r\n  this.browserbot.metaKeyDown = true\r\n  core.events.metaKeyDown_ = true\r\n}\r\n\r\nSelenium.prototype.doMetaKeyUp = function() {\r\n  /**\r\n   * Release the meta key.\r\n   *\r\n   */\r\n  this.browserbot.metaKeyDown = false\r\n  core.events.metaKeyDown_ = false\r\n}\r\n\r\nSelenium.prototype.doAltKeyDown = function() {\r\n  /**\r\n   * Press the alt key and hold it down until doAltUp() is called or a new page is loaded.\r\n   *\r\n   */\r\n  this.browserbot.altKeyDown = true\r\n  core.events.altKeyDown_ = true\r\n}\r\n\r\nSelenium.prototype.doAltKeyUp = function() {\r\n  /**\r\n   * Release the alt key.\r\n   *\r\n   */\r\n  this.browserbot.altKeyDown = false\r\n  core.events.altKeyDown_ = false\r\n}\r\n\r\nSelenium.prototype.doControlKeyDown = function() {\r\n  /**\r\n   * Press the control key and hold it down until doControlUp() is called or a new page is loaded.\r\n   *\r\n   */\r\n  this.browserbot.controlKeyDown = true\r\n  core.events.controlKeyDown_ = true\r\n}\r\n\r\nSelenium.prototype.doControlKeyUp = function() {\r\n  /**\r\n   * Release the control key.\r\n   *\r\n   */\r\n  this.browserbot.controlKeyDown = false\r\n  core.events.controlKeyDown_ = false\r\n}\r\n\r\nfunction getClientXY(element, coordString) {\r\n  // Parse coordString\r\n  let coords = null\r\n  let x\r\n  let y\r\n  if (coordString) {\r\n    coords = coordString.split(/,/)\r\n    x = Number(coords[0])\r\n    y = Number(coords[1])\r\n  } else {\r\n    x = y = 0\r\n  }\r\n\r\n  // Get position of element,\r\n  // Return 2 item array with clientX and clientY\r\n  return [\r\n    Selenium.prototype.getElementPositionLeft(element) + x,\r\n    Selenium.prototype.getElementPositionTop(element) + y,\r\n  ]\r\n}\r\n\r\nfunction getCoords(_element, coordString) {\r\n  // Parse coordString\r\n  let coords = null\r\n  let x\r\n  let y\r\n  if (coordString) {\r\n    coords = coordString.split(/,/)\r\n    x = Number(coords[0])\r\n    y = Number(coords[1])\r\n  } else {\r\n    x = y = 0\r\n  }\r\n\r\n  return new goog.math.Coordinate(x, y)\r\n}\r\n\r\nSelenium.prototype.prepareToInteract_ = function(locator) {\r\n  let element = this.browserbot.findElement(locator)\r\n  let rect = element.getBoundingClientRect()\r\n  bot.action.prepareToInteractWith_(\r\n    element,\r\n    new goog.math.Coordinate(rect.width / 2, rect.height / 2)\r\n  )\r\n  return element.getBoundingClientRect()\r\n}\r\n\r\nSelenium.prototype.doMouseOver = function(locator) {\r\n  /**\r\n   * Simulates a user hovering a mouse over the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n\r\n  let element = this.browserbot.findElement(locator)\r\n  let rect = element.getBoundingClientRect()\r\n  bot.action.moveMouse(\r\n    element,\r\n    new goog.math.Coordinate(rect.width / 2, rect.height / 2)\r\n  )\r\n}\r\n\r\nSelenium.prototype.doMouseOut = function(locator) {\r\n  /**\r\n   * Simulates a user moving the mouse pointer away from the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  this.browserbot.triggerMouseEvent(element, 'mouseout', true)\r\n}\r\n\r\nSelenium.prototype.doMouseDown = function(locator) {\r\n  /**\r\n   * Simulates a user pressing the left mouse button (without releasing it yet) on\r\n   * the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  this.browserbot.triggerMouseEvent(element, 'mousedown', true)\r\n}\r\n\r\nSelenium.prototype.doMouseDownRight = function(locator) {\r\n  /**\r\n   * Simulates a user pressing the right mouse button (without releasing it yet) on\r\n   * the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mousedown',\r\n    true,\r\n    undefined,\r\n    undefined,\r\n    Selenium.RIGHT_MOUSE_CLICK\r\n  )\r\n}\r\n\r\nSelenium.prototype.doMouseDownAt = function(locator, coordString) {\r\n  /**\r\n   * Simulates a user pressing the left mouse button (without releasing it yet) at\r\n   * the specified location.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let clientXY = getClientXY(element, coordString)\r\n\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mousedown',\r\n    true,\r\n    clientXY[0],\r\n    clientXY[1]\r\n  )\r\n}\r\n\r\nSelenium.prototype.doMouseDownRightAt = function(locator, coordString) {\r\n  /**\r\n   * Simulates a user pressing the right mouse button (without releasing it yet) at\r\n   * the specified location.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let clientXY = getClientXY(element, coordString)\r\n\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mousedown',\r\n    true,\r\n    clientXY[0],\r\n    clientXY[1],\r\n    Selenium.RIGHT_MOUSE_CLICK\r\n  )\r\n}\r\n\r\nSelenium.prototype.doMouseUp = function(locator) {\r\n  /**\r\n   * Simulates the event that occurs when the user releases the mouse button (i.e., stops\r\n   * holding the button down) on the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  this.browserbot.triggerMouseEvent(element, 'mouseup', true)\r\n}\r\n\r\nSelenium.prototype.doMouseUpRight = function(locator) {\r\n  /**\r\n   * Simulates the event that occurs when the user releases the right mouse button (i.e., stops\r\n   * holding the button down) on the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mouseup',\r\n    true,\r\n    undefined,\r\n    undefined,\r\n    Selenium.RIGHT_MOUSE_CLICK\r\n  )\r\n}\r\n\r\nSelenium.prototype.doMouseUpAt = function(locator, coordString) {\r\n  /**\r\n   * Simulates the event that occurs when the user releases the mouse button (i.e., stops\r\n   * holding the button down) at the specified location.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let clientXY = getClientXY(element, coordString)\r\n\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mouseup',\r\n    true,\r\n    clientXY[0],\r\n    clientXY[1]\r\n  )\r\n}\r\n\r\nSelenium.prototype.doMouseUpRightAt = function(locator, coordString) {\r\n  /**\r\n   * Simulates the event that occurs when the user releases the right mouse button (i.e., stops\r\n   * holding the button down) at the specified location.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let clientXY = getClientXY(element, coordString)\r\n\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mouseup',\r\n    true,\r\n    clientXY[0],\r\n    clientXY[1],\r\n    Selenium.RIGHT_MOUSE_CLICK\r\n  )\r\n}\r\n\r\nSelenium.prototype.doMouseMove = function(locator) {\r\n  /**\r\n   * Simulates a user pressing the mouse button (without releasing it yet) on\r\n   * the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  this.browserbot.triggerMouseEvent(element, 'mousemove', true)\r\n}\r\n\r\nSelenium.prototype.doMouseMoveAt = function(locator, coordString) {\r\n  /**\r\n   * Simulates a user pressing the mouse button (without releasing it yet) on\r\n   * the specified element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @param coordString specifies the x,y position (i.e. - 10,20) of the mouse\r\n   *      event relative to the element returned by the locator.\r\n   */\r\n\r\n  let element = this.browserbot.findElement(locator)\r\n  let clientXY = getClientXY(element, coordString)\r\n\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mousemove',\r\n    true,\r\n    clientXY[0],\r\n    clientXY[1]\r\n  )\r\n}\r\n\r\nSelenium.prototype.doType = function(locator, value) {\r\n  /**\r\n   * Sets the value of an input field, as though you typed it in.\r\n   *\r\n   * <p>Can also be used to set the value of combo boxes, check boxes, etc. In these cases,\r\n   * value should be the value of the option selected, not the visible text.</p>\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @param value the value to type\r\n   */\r\n  if (\r\n    this.browserbot.controlKeyDown ||\r\n    this.browserbot.altKeyDown ||\r\n    this.browserbot.metaKeyDown\r\n  ) {\r\n    throw new SeleniumError(\r\n      'type not supported immediately after call to controlKeyDown() or altKeyDown() or metaKeyDown()'\r\n    )\r\n  }\r\n\r\n  let element = this.browserbot.findElement(locator)\r\n\r\n  core.events.setValue(element, '')\r\n  const type = element.type\r\n  if (type === 'number' || type === 'date') {\r\n    core.events.setValue(element, value)\r\n  } else {\r\n    bot.action.type(element, value)\r\n    if (element.value !== value) {\r\n      core.events.setValue(element, value)\r\n    }\r\n  }\r\n  bot.events.fire(element, bot.events.EventType.CHANGE)\r\n}\r\n\r\nSelenium.prototype.doSendKeys = function(locator, value) {\r\n  /**\r\n   * *Experimental* Simulates keystroke events on the specified element, as though you typed the value key-by-key.\r\n   *\r\n   * <p>This simulates a real user typing every character in the specified string; it is also bound by the limitations of a\r\n   * real user, like not being able to type into a invisible or read only elements. This is useful for dynamic UI widgets\r\n   * (like auto-completing combo boxes) that require explicit key events.</p>\r\n   * <p>Unlike the simple \"type\" command, which forces the specified value into the page directly, this command will not\r\n   * replace the existing content. If you want to replace the existing contents, you need to use the simple \"type\" command to set the value of the\r\n   * field to empty string to clear the field and then the \"sendKeys\" command to send the keystroke for what you want\r\n   * to type.</p>\r\n   * <p>This command is experimental. It may replace the typeKeys command in the future.</p>\r\n   * <p>For those who are interested in the details, unlike the typeKeys command, which tries to\r\n   * fire the keyDown, the keyUp and the keyPress events, this command is backed by the atoms from Selenium 2 and provides a\r\n   * much more robust implementation that will be maintained in the future.</p>\r\n   *\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @param value the value to type\r\n   */\r\n  if (\r\n    this.browserbot.controlKeyDown ||\r\n    this.browserbot.altKeyDown ||\r\n    this.browserbot.metaKeyDown\r\n  ) {\r\n    throw new SeleniumError(\r\n      'type not supported immediately after call to controlKeyDown() or altKeyDown() or metaKeyDown()'\r\n    )\r\n  }\r\n\r\n  let element = this.browserbot.findElement(locator)\r\n  let keys = this.replaceKeys(value)\r\n  bot.action.type(element, keys)\r\n  bot.events.fire(element, bot.events.EventType.CHANGE)\r\n}\r\n\r\nSelenium.prototype.doSetSpeed = function() {\r\n  /**\r\n   * Set execution speed (i.e., set the millisecond length of a delay which will follow each selenium operation).  By default, there is no such delay, i.e.,\r\n   * the delay is 0 milliseconds.\r\n   *\r\n   * @param value the number of milliseconds to pause after operation\r\n   */\r\n  throw new SeleniumError(\r\n    'this operation is only implemented in selenium-rc, and should never result in a request making it across the wire'\r\n  )\r\n}\r\n\r\nSelenium.prototype.getSpeed = function() {\r\n  /**\r\n   * Get execution speed (i.e., get the millisecond length of the delay following each selenium operation).  By default, there is no such delay, i.e.,\r\n   * the delay is 0 milliseconds.\r\n   *\r\n   * See also setSpeed.\r\n   *\r\n   * @return string the execution speed in milliseconds.\r\n   */\r\n  throw new SeleniumError(\r\n    'this operation is only implemented in selenium-rc, and should never result in a request making it across the wire'\r\n  )\r\n}\r\n\r\nSelenium.prototype.findToggleButton = function(locator) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.checked == null) {\r\n    throw new Error('Element ' + locator + ' is not a toggle-button.') // eslint-disable-line no-undef\r\n  }\r\n  return element\r\n}\r\n\r\nSelenium.prototype.doCheck = function(locator) {\r\n  /**\r\n   * Check a toggle-button (checkbox/radio)\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  this.findToggleButton(locator).checked = true\r\n}\r\n\r\nSelenium.prototype.doUncheck = function(locator) {\r\n  /**\r\n   * Uncheck a toggle-button (checkbox/radio)\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   */\r\n  this.findToggleButton(locator).checked = false\r\n}\r\n\r\nSelenium.prototype.doSelect = function(selectLocator, optionLocator) {\r\n  /**\r\n   * Select an option from a drop-down using an option locator.\r\n   *\r\n   * <p>\r\n   * Option locators provide different ways of specifying options of an HTML\r\n   * Select element (e.g. for selecting a specific option, or for asserting\r\n   * that the selected option satisfies a specification). There are several\r\n   * forms of Select Option Locator.\r\n   * </p>\r\n   * <ul>\r\n   * <li><strong>label</strong>=<em>labelPattern</em>:\r\n   * matches options based on their labels, i.e. the visible text. (This\r\n   * is the default.)\r\n   * <ul class=\"first last simple\">\r\n   * <li>label=regexp:^[Oo]ther</li>\r\n   * </ul>\r\n   * </li>\r\n   * <li><strong>value</strong>=<em>valuePattern</em>:\r\n   * matches options based on their values.\r\n   * <ul class=\"first last simple\">\r\n   * <li>value=other</li>\r\n   * </ul>\r\n   *\r\n   *\r\n   * </li>\r\n   * <li><strong>id</strong>=<em>id</em>:\r\n   *\r\n   * matches options based on their ids.\r\n   * <ul class=\"first last simple\">\r\n   * <li>id=option1</li>\r\n   * </ul>\r\n   * </li>\r\n   * <li><strong>index</strong>=<em>index</em>:\r\n   * matches an option based on its index (offset from zero).\r\n   * <ul class=\"first last simple\">\r\n   *\r\n   * <li>index=2</li>\r\n   * </ul>\r\n   * </li>\r\n   * </ul>\r\n   * <p>\r\n   * If no option locator prefix is provided, the default behaviour is to match on <strong>label</strong>.\r\n   * </p>\r\n   *\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @param optionLocator an option locator (a label by default)\r\n   */\r\n  let element = this.browserbot.findElement(selectLocator)\r\n  if (!('options' in element)) {\r\n    throw new SeleniumError(\r\n      'Specified element is not a Select (has no options)'\r\n    )\r\n  }\r\n  let locator = this.optionLocatorFactory.fromLocatorString(optionLocator)\r\n  let option = locator.findOption(element)\r\n  this.browserbot.selectOption(element, option)\r\n}\r\n\r\nSelenium.prototype.doAddSelection = function(locator, optionLocator) {\r\n  /**\r\n   * Add a selection to the set of selected options in a multi-select element using an option locator.\r\n   *\r\n   * @see #doSelect for details of option locators\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> identifying a multi-select box\r\n   * @param optionLocator an option locator (a label by default)\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  if (!('options' in element)) {\r\n    throw new SeleniumError(\r\n      'Specified element is not a Select (has no options)'\r\n    )\r\n  }\r\n  let currLocator = this.optionLocatorFactory.fromLocatorString(optionLocator)\r\n  let option = currLocator.findOption(element)\r\n  this.browserbot.addSelection(element, option)\r\n}\r\n\r\nSelenium.prototype.doRemoveSelection = function(locator, optionLocator) {\r\n  /**\r\n   * Remove a selection from the set of selected options in a multi-select element using an option locator.\r\n   *\r\n   * @see #doSelect for details of option locators\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> identifying a multi-select box\r\n   * @param optionLocator an option locator (a label by default)\r\n   */\r\n\r\n  let element = this.browserbot.findElement(locator)\r\n  if (!('options' in element)) {\r\n    throw new SeleniumError(\r\n      'Specified element is not a Select (has no options)'\r\n    )\r\n  }\r\n  let currLocator = this.optionLocatorFactory.fromLocatorString(optionLocator)\r\n  let option = currLocator.findOption(element)\r\n  this.browserbot.removeSelection(element, option)\r\n}\r\n\r\nSelenium.prototype.doRemoveAllSelections = function(locator) {\r\n  /**\r\n   * Unselects all of the selected options in a multi-select element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> identifying a multi-select box\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  if (!('options' in element)) {\r\n    throw new SeleniumError(\r\n      'Specified element is not a Select (has no options)'\r\n    )\r\n  }\r\n  for (let i = 0; i < element.options.length; i++) {\r\n    this.browserbot.removeSelection(element, element.options[i])\r\n  }\r\n}\r\n\r\nSelenium.prototype.doSubmit = function(formLocator) {\r\n  /**\r\n   * Submit the specified form. This is particularly useful for forms without\r\n   * submit buttons, e.g. single-input \"Search\" forms.\r\n   *\r\n   * @param formLocator an <a href=\"#locators\">element locator</a> for the form you want to submit\r\n   */\r\n  browser.runtime.sendMessage({\r\n    log: {\r\n      type: 'warn',\r\n      message:\r\n        'submit is deprecated and will be removed from later versions of Selenium IDE, please re-record the step.',\r\n    },\r\n  })\r\n  let form = this.browserbot.findElement(formLocator)\r\n  return bot.action.submit(form)\r\n}\r\n\r\nSelenium.prototype.makePageLoadCondition = function(timeout) {\r\n  if (timeout == null) {\r\n    timeout = this.defaultTimeout\r\n  }\r\n  // if the timeout is zero, we won't wait for the page to load before returning\r\n  if (timeout == 0) {\r\n    // abort XHR request\r\n    this._abortXhrRequest()\r\n    return\r\n  }\r\n  return Selenium.decorateFunctionWithTimeout(\r\n    this._isNewPageLoaded.bind(this),\r\n    timeout,\r\n    this._abortXhrRequest.bind(this)\r\n  )\r\n}\r\n\r\nSelenium.prototype.doOpen = function(url, ignoreResponseCode) {\r\n  /**\r\n   * Opens an URL in the test frame. This accepts both relative and absolute\r\n   * URLs.\r\n   *\r\n   * The &quot;open&quot; command waits for the page to load before proceeding,\r\n   * ie. the &quot;AndWait&quot; suffix is implicit.\r\n   *\r\n   * <em>Note</em>: The URL must be on the same domain as the runner HTML\r\n   * due to security restrictions in the browser (Same Origin Policy). If you\r\n   * need to open an URL on another domain, use the Selenium Server to start a\r\n   * new browser session on that domain.\r\n   *\r\n   * @param url the URL to open; may be relative or absolute\r\n   * @param ignoreResponseCode (optional) turn off ajax head request functionality\r\n   *\r\n   */\r\n  if (ignoreResponseCode == null || ignoreResponseCode.length == 0) {\r\n    this.browserbot.ignoreResponseCode = true\r\n  } else if (ignoreResponseCode.toLowerCase() == 'true') {\r\n    this.browserbot.ignoreResponseCode = true\r\n  } else {\r\n    this.browserbot.ignoreResponseCode = false\r\n  }\r\n  this.browserbot.openLocation(url)\r\n  if (window['proxyInjectionMode'] == null || !window['proxyInjectionMode']) {\r\n    return this.makePageLoadCondition()\r\n  } // in PI mode, just return \"OK\"; the server will waitForLoad\r\n}\r\n\r\nSelenium.prototype.doOpenWindow = function(url, windowID) {\r\n  /**\r\n   * Opens a popup window (if a window with that ID isn't already open).\r\n   * After opening the window, you'll need to select it using the selectWindow\r\n   * command.\r\n   *\r\n   * <p>This command can also be a useful workaround for bug SEL-339.  In some cases, Selenium will be unable to intercept a call to window.open (if the call occurs during or before the \"onLoad\" event, for example).\r\n   * In those cases, you can force Selenium to notice the open window's name by using the Selenium openWindow command, using\r\n   * an empty (blank) url, like this: openWindow(\"\", \"myFunnyWindow\").</p>\r\n   *\r\n   * @param url the URL to open, which can be blank\r\n   * @param windowID the JavaScript window ID of the window to select\r\n   */\r\n  this.browserbot.openWindow(url, windowID)\r\n}\r\n\r\nSelenium.prototype.doSelectWindow = function(windowID) {\r\n  /**\r\n   * Selects a popup window using a window locator; once a popup window has been selected, all\r\n   * commands go to that window. To select the main window again, use null\r\n   * as the target.\r\n   *\r\n   * <p>\r\n   *\r\n   * Window locators provide different ways of specifying the window object:\r\n   * by title, by internal JavaScript \"name,\" or by JavaScript variable.\r\n   * </p>\r\n   * <ul>\r\n   * <li><strong>title</strong>=<em>My Special Window</em>:\r\n   * Finds the window using the text that appears in the title bar.  Be careful;\r\n   * two windows can share the same title.  If that happens, this locator will\r\n   * just pick one.\r\n   * </li>\r\n   * <li><strong>name</strong>=<em>myWindow</em>:\r\n   * Finds the window using its internal JavaScript \"name\" property.  This is the second\r\n   * parameter \"windowName\" passed to the JavaScript method window.open(url, windowName, windowFeatures, replaceFlag)\r\n   * (which Selenium intercepts).\r\n   * </li>\r\n   * <li><strong>var</strong>=<em>variableName</em>:\r\n   * Some pop-up windows are unnamed (anonymous), but are associated with a JavaScript variable name in the current\r\n   * application window, e.g. \"window.foo = window.open(url);\".  In those cases, you can open the window using\r\n   * \"var=foo\".\r\n   * </li>\r\n   * </ul>\r\n   * <p>\r\n   * If no window locator prefix is provided, we'll try to guess what you mean like this:</p>\r\n   * <p>1.) if windowID is null, (or the string \"null\") then it is assumed the user is referring to the original window instantiated by the browser).</p>\r\n   * <p>2.) if the value of the \"windowID\" parameter is a JavaScript variable name in the current application window, then it is assumed\r\n   * that this variable contains the return value from a call to the JavaScript window.open() method.</p>\r\n   * <p>3.) Otherwise, selenium looks in a hash it maintains that maps string names to window \"names\".</p>\r\n   * <p>4.) If <em>that</em> fails, we'll try looping over all of the known windows to try to find the appropriate \"title\".\r\n   * Since \"title\" is not necessarily unique, this may have unexpected behavior.</p>\r\n   *\r\n   * <p>If you're having trouble figuring out the name of a window that you want to manipulate, look at the Selenium log messages\r\n   * which identify the names of windows created via window.open (and therefore intercepted by Selenium).  You will see messages\r\n   * like the following for each window as it is opened:</p>\r\n   *\r\n   * <p><code>debug: window.open call intercepted; window ID (which you can use with selectWindow()) is \"myNewWindow\"</code></p>\r\n   *\r\n   * <p>In some cases, Selenium will be unable to intercept a call to window.open (if the call occurs during or before the \"onLoad\" event, for example).\r\n   * (This is bug SEL-339.)  In those cases, you can force Selenium to notice the open window's name by using the Selenium openWindow command, using\r\n   * an empty (blank) url, like this: openWindow(\"\", \"myFunnyWindow\").</p>\r\n   *\r\n   * @param windowID the JavaScript window ID of the window to select\r\n   */\r\n  this.browserbot.selectWindow(windowID)\r\n}\r\n\r\nSelenium.prototype.doSelectPopUp = function(windowID) {\r\n  /**\r\n   * Simplifies the process of selecting a popup window (and does not offer\r\n   * functionality beyond what <code>selectWindow()</code> already provides).\r\n   * <ul>\r\n   * <li>If <code>windowID</code> is either not specified, or specified as\r\n   * \"null\", the first non-top window is selected. The top window is the one\r\n   * that would be selected by <code>selectWindow()</code> without providing a\r\n   * <code>windowID</code> . This should not be used when more than one popup\r\n   * window is in play.</li>\r\n   * <li>Otherwise, the window will be looked up considering\r\n   * <code>windowID</code> as the following in order: 1) the \"name\" of the\r\n   * window, as specified to <code>window.open()</code>; 2) a javascript\r\n   * variable which is a reference to a window; and 3) the title of the\r\n   * window. This is the same ordered lookup performed by\r\n   * <code>selectWindow</code> .</li>\r\n   * </ul>\r\n   *\r\n   * @param windowID  an identifier for the popup window, which can take on a\r\n   *                  number of different meanings\r\n   */\r\n  this.browserbot.selectPopUp(windowID)\r\n}\r\n\r\nSelenium.prototype.doDeselectPopUp = function() {\r\n  /**\r\n   * Selects the main window. Functionally equivalent to using\r\n   * <code>selectWindow()</code> and specifying no value for\r\n   * <code>windowID</code>.\r\n   */\r\n  this.browserbot.selectWindow()\r\n}\r\n\r\nSelenium.prototype.doSelectFrame = function(locator) {\r\n  /**\r\n   * Selects a frame within the current window.  (You may invoke this command\r\n   * multiple times to select nested frames.)  To select the parent frame, use\r\n   * \"relative=parent\" as a locator; to select the top frame, use \"relative=top\".\r\n   * You can also select a frame by its 0-based index number; select the first frame with\r\n   * \"index=0\", or the third frame with \"index=2\".\r\n   *\r\n   * <p>You may also use a DOM expression to identify the frame you want directly,\r\n   * like this: <code>dom=frames[\"main\"].frames[\"subframe\"]</code></p>\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> identifying a frame or iframe\r\n   */\r\n  this.browserbot.selectFrame(locator)\r\n}\r\n\r\nSelenium.prototype.getWhetherThisFrameMatchFrameExpression = function(\r\n  currentFrameString,\r\n  target\r\n) {\r\n  /**\r\n   * Determine whether current/locator identify the frame containing this running code.\r\n   *\r\n   * <p>This is useful in proxy injection mode, where this code runs in every\r\n   * browser frame and window, and sometimes the selenium server needs to identify\r\n   * the \"current\" frame.  In this case, when the test calls selectFrame, this\r\n   * routine is called for each frame to figure out which one has been selected.\r\n   * The selected frame will return true, while all others will return false.</p>\r\n   *\r\n   * @param currentFrameString starting frame\r\n   * @param target new frame (which might be relative to the current one)\r\n   * @return boolean true if the new frame is this code's window\r\n   */\r\n  return this.browserbot.doesThisFrameMatchFrameExpression(\r\n    currentFrameString,\r\n    target\r\n  )\r\n}\r\n\r\nSelenium.prototype.getWhetherThisWindowMatchWindowExpression = function(\r\n  _currentWindowString,\r\n  target\r\n) {\r\n  /**\r\n   * Determine whether currentWindowString plus target identify the window containing this running code.\r\n   *\r\n   * <p>This is useful in proxy injection mode, where this code runs in every\r\n   * browser frame and window, and sometimes the selenium server needs to identify\r\n   * the \"current\" window.  In this case, when the test calls selectWindow, this\r\n   * routine is called for each window to figure out which one has been selected.\r\n   * The selected window will return true, while all others will return false.</p>\r\n   *\r\n   * @param currentWindowString starting window\r\n   * @param target new window (which might be relative to the current one, e.g., \"_parent\")\r\n   * @return boolean true if the new window is this code's window\r\n   */\r\n  if (\r\n    window.opener != null &&\r\n    window.opener[target] != null &&\r\n    window.opener[target] == window\r\n  ) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nSelenium.prototype.doWaitForPopUp = function(windowID, timeout) {\r\n  /**\r\n   * Waits for a popup window to appear and load up.\r\n   *\r\n   * @param windowID the JavaScript window \"name\" of the window that will appear (not the text of the title bar)\r\n   *                 If unspecified, or specified as \"null\", this command will\r\n   *                 wait for the first non-top window to appear (don't rely\r\n   *                 on this if you are working with multiple popups\r\n   *                 simultaneously).\r\n   * @param timeout a timeout in milliseconds, after which the action will return with an error.\r\n   *                If this value is not specified, the default Selenium\r\n   *                timeout will be used. See the setTimeout() command.\r\n   */\r\n  if (!timeout) {\r\n    timeout = this.defaultTimeout\r\n  }\r\n  let timeoutTime = getTimeoutTime(timeout)\r\n\r\n  let popupLoadedPredicate = function() {\r\n    let targetWindow\r\n    try {\r\n      if (windowID && windowID != 'null') {\r\n        targetWindow = selenium.browserbot.getWindowByName(windowID, true)\r\n      } else {\r\n        let names = selenium.browserbot.getNonTopWindowNames()\r\n        targetWindow = selenium.browserbot.getWindowByName(names[0], true)\r\n      }\r\n    } catch (e) {\r\n      if (new Date().getTime() > timeoutTime) {\r\n        throw e\r\n      }\r\n    }\r\n\r\n    if (!targetWindow) return false\r\n    try {\r\n      if (!targetWindow.location) return false\r\n      if ('about:blank' == targetWindow.location) return false\r\n    } catch (e) {\r\n      //LOG.debug(\"Location exception (\" + e.message + \")!\");\r\n      return false\r\n    }\r\n    if (browserVersion.isKonqueror) {\r\n      if ('/' == targetWindow.location.href) {\r\n        // apparently Konqueror uses this as the temporary location, instead of about:blank\r\n        return false\r\n      }\r\n    }\r\n    if (browserVersion.isSafari) {\r\n      if (\r\n        targetWindow.location.href ==\r\n        selenium.browserbot.buttonWindow.location.href\r\n      ) {\r\n        // Apparently Safari uses this as the temporary location, instead of about:blank\r\n        // what a world!\r\n        //LOG.debug(\"DGF what a world!\");\r\n        return false\r\n      }\r\n    }\r\n    if (!targetWindow.document) return false\r\n    if (!selenium.browserbot.getCurrentWindow().document.readyState) {\r\n      // This is Firefox, with no readyState extension\r\n      return true\r\n    }\r\n    if ('complete' != targetWindow.document.readyState) return false\r\n    return true\r\n  }\r\n\r\n  return Selenium.decorateFunctionWithTimeout(popupLoadedPredicate, timeout)\r\n}\r\n\r\nSelenium.prototype.doWaitForPopUp.dontCheckAlertsAndConfirms = true\r\n\r\n//Selenium.prototype.doChooseCancelOnNextConfirmation = function() {\r\n/**\r\n * <p>\r\n * By default, Selenium's overridden window.confirm() function will\r\n * return true, as if the user had manually clicked OK; after running\r\n * this command, the next call to confirm() will return false, as if\r\n * the user had clicked Cancel.  Selenium will then resume using the\r\n * default behavior for future confirmations, automatically returning\r\n * true (OK) unless/until you explicitly call this command for each\r\n * confirmation.\r\n * </p>\r\n * <p>\r\n * Take note - every time a confirmation comes up, you must\r\n * consume it with a corresponding getConfirmation, or else\r\n * the next selenium operation will fail.\r\n * </p>\r\n */\r\n//this.browserbot.cancelNextConfirmation(false);\r\n//};\r\n\r\n//Selenium.prototype.doChooseOkOnNextConfirmation = function() {\r\n/**\r\n * <p>\r\n * Undo the effect of calling chooseCancelOnNextConfirmation.  Note\r\n * that Selenium's overridden window.confirm() function will normally automatically\r\n * return true, as if the user had manually clicked OK, so you shouldn't\r\n * need to use this command unless for some reason you need to change\r\n * your mind prior to the next confirmation.  After any confirmation, Selenium will resume using the\r\n * default behavior for future confirmations, automatically returning\r\n * true (OK) unless/until you explicitly call chooseCancelOnNextConfirmation for each\r\n * confirmation.\r\n * </p>\r\n * <p>\r\n * Take note - every time a confirmation comes up, you must\r\n * consume it with a corresponding getConfirmation, or else\r\n * the next selenium operation will fail.\r\n * </p>\r\n *\r\n */\r\n//this.browserbot.cancelNextConfirmation(true);\r\n//};\r\n\r\n//Selenium.prototype.doAnswerOnNextPrompt = function(answer) {\r\n/**\r\n * Instructs Selenium to return the specified answer string in response to\r\n * the next JavaScript prompt [window.prompt()].\r\n *\r\n *\r\n * @param answer the answer to give in response to the prompt pop-up\r\n */\r\n//this.browserbot.setNextPromptResult(answer);\r\n//};\r\n\r\nSelenium.prototype.doGoBack = function() {\r\n  /**\r\n   * Simulates the user clicking the \"back\" button on their browser.\r\n   *\r\n   */\r\n  this.browserbot.goBack()\r\n}\r\n\r\nSelenium.prototype.doRefresh = function() {\r\n  /**\r\n   * Simulates the user clicking the \"Refresh\" button on their browser.\r\n   *\r\n   */\r\n  this.browserbot.refresh()\r\n}\r\n\r\nSelenium.prototype.doClose = function() {\r\n  /**\r\n   * Simulates the user clicking the \"close\" button in the titlebar of a popup\r\n   * window or tab.\r\n   */\r\n  this.browserbot.close()\r\n}\r\n\r\nSelenium.prototype.ensureNoUnhandledPopups = function() {\r\n  if (this.browserbot.hasAlerts()) {\r\n    throw new SeleniumError(\r\n      'There was an unexpected Alert! [' + this.browserbot.getNextAlert() + ']'\r\n    )\r\n  }\r\n  if (this.browserbot.hasConfirmations()) {\r\n    throw new SeleniumError(\r\n      'There was an unexpected Confirmation! [' +\r\n        this.browserbot.getNextConfirmation() +\r\n        ']'\r\n    )\r\n  }\r\n}\r\n\r\nSelenium.prototype.isAlertPresent = function() {\r\n  /**\r\n   * Has an alert occurred?\r\n   *\r\n   * <p>\r\n   * This function never throws an exception\r\n   * </p>\r\n   * @return boolean true if there is an alert\r\n   */\r\n  return this.browserbot.hasAlerts()\r\n}\r\n\r\nSelenium.prototype.isPromptPresent = function() {\r\n  /**\r\n   * Has a prompt occurred?\r\n   *\r\n   * <p>\r\n   * This function never throws an exception\r\n   * </p>\r\n   * @return boolean true if there is a pending prompt\r\n   */\r\n  return this.browserbot.hasPrompts()\r\n}\r\n\r\nSelenium.prototype.isConfirmationPresent = function() {\r\n  /**\r\n   * Has confirm() been called?\r\n   *\r\n   * <p>\r\n   * This function never throws an exception\r\n   * </p>\r\n   * @return boolean true if there is a pending confirmation\r\n   */\r\n  return this.browserbot.hasConfirmations()\r\n}\r\nSelenium.prototype.getAlert = function() {\r\n  /**\r\n     * Retrieves the message of a JavaScript alert generated during the previous action, or fail if there were no alerts.\r\n     *\r\n     * <p>Getting an alert has the same effect as manually clicking OK. If an\r\n     * alert is generated but you do not consume it with getAlert, the next Selenium action\r\n     * will fail.</p>\r\n     *\r\n     * <p>Under Selenium, JavaScript alerts will NOT pop up a visible alert\r\n     * dialog.</p>\r\n     *\r\n     * <p>Selenium does NOT support JavaScript alerts that are generated in a\r\n     * page's onload() event handler. In this case a visible dialog WILL be\r\n     * generated and Selenium will hang until someone manually clicks OK.</p>\r\n     * @return string The message of the most recent JavaScript alert\r\n\r\n     */\r\n  if (!this.browserbot.hasAlerts()) {\r\n    Assert.fail('There were no alerts') // eslint-disable-line no-undef\r\n  }\r\n  return this.browserbot.getNextAlert()\r\n}\r\nSelenium.prototype.getAlert.dontCheckAlertsAndConfirms = true\r\n\r\nSelenium.prototype.getConfirmation = function() {\r\n  /**\r\n   * Retrieves the message of a JavaScript confirmation dialog generated during\r\n   * the previous action.\r\n   *\r\n   * <p>\r\n   * By default, the confirm function will return true, having the same effect\r\n   * as manually clicking OK. This can be changed by prior execution of the\r\n   * chooseCancelOnNextConfirmation command.\r\n   * </p>\r\n   * <p>\r\n   * If an confirmation is generated but you do not consume it with getConfirmation,\r\n   * the next Selenium action will fail.\r\n   * </p>\r\n   *\r\n   * <p>\r\n   * NOTE: under Selenium, JavaScript confirmations will NOT pop up a visible\r\n   * dialog.\r\n   * </p>\r\n   *\r\n   * <p>\r\n   * NOTE: Selenium does NOT support JavaScript confirmations that are\r\n   * generated in a page's onload() event handler. In this case a visible\r\n   * dialog WILL be generated and Selenium will hang until you manually click\r\n   * OK.\r\n   * </p>\r\n   *\r\n   * @return string the message of the most recent JavaScript confirmation dialog\r\n   */\r\n  if (!this.browserbot.hasConfirmations()) {\r\n    Assert.fail('There were no confirmations') // eslint-disable-line no-undef\r\n  }\r\n  return this.browserbot.getNextConfirmation()\r\n}\r\nSelenium.prototype.getConfirmation.dontCheckAlertsAndConfirms = true\r\n\r\nSelenium.prototype.getPrompt = function() {\r\n  /**\r\n   * Retrieves the message of a JavaScript question prompt dialog generated during\r\n   * the previous action.\r\n   *\r\n   * <p>Successful handling of the prompt requires prior execution of the\r\n   * answerOnNextPrompt command. If a prompt is generated but you\r\n   * do not get/verify it, the next Selenium action will fail.</p>\r\n   *\r\n   * <p>NOTE: under Selenium, JavaScript prompts will NOT pop up a visible\r\n   * dialog.</p>\r\n   *\r\n   * <p>NOTE: Selenium does NOT support JavaScript prompts that are generated in a\r\n   * page's onload() event handler. In this case a visible dialog WILL be\r\n   * generated and Selenium will hang until someone manually clicks OK.</p>\r\n   * @return string the message of the most recent JavaScript question prompt\r\n   */\r\n  if (!this.browserbot.hasPrompts()) {\r\n    Assert.fail('There were no prompts') // eslint-disable-line no-undef\r\n  }\r\n  return this.browserbot.getNextPrompt()\r\n}\r\n\r\nSelenium.prototype.getLocation = function() {\r\n  /** Gets the absolute URL of the current page.\r\n   *\r\n   * @return string the absolute URL of the current page\r\n   */\r\n  return this.browserbot.getCurrentWindow().location.href\r\n}\r\n\r\nSelenium.prototype.getTitle = function() {\r\n  /** Gets the title of the current page.\r\n   *\r\n   * @return string the title of the current page\r\n   */\r\n  return this.browserbot.getTitle()\r\n}\r\n\r\nSelenium.prototype.getBodyText = function() {\r\n  /**\r\n   * Gets the entire text of the page.\r\n   * @return string the entire text of the page\r\n   */\r\n  return this.browserbot.bodyText()\r\n}\r\n\r\nSelenium.prototype.getValue = function(locator) {\r\n  /**\r\n   * Gets the (whitespace-trimmed) value of an input field (or anything else with a value parameter).\r\n   * For checkbox/radio elements, the value will be \"on\" or \"off\" depending on\r\n   * whether the element is checked or not.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @return string the element value, or \"on/off\" for checkbox/radio elements\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  return element.value.trim()\r\n}\r\n\r\nSelenium.prototype.getText = function(locator) {\r\n  /**\r\n   * Gets the text of an element. This works for any element that contains\r\n   * text. This command uses either the textContent (Mozilla-like browsers) or\r\n   * the innerText (IE-like browsers) of the element, which is the rendered\r\n   * text shown to the user.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @return string the text of the element\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  return bot.dom.getVisibleText(element).trim()\r\n}\r\n\r\nSelenium.prototype.getEval = function(script) {\r\n  /** Gets the result of evaluating the specified JavaScript snippet.  The snippet may\r\n   * have multiple lines, but only the result of the last line will be returned.\r\n   *\r\n   * <p>Note that, by default, the snippet will run in the context of the \"selenium\"\r\n   * object itself, so <code>this</code> will refer to the Selenium object.  Use <code>window</code> to\r\n   * refer to the window of your application, e.g. <code>window.document.getElementById('foo')</code></p>\r\n   *\r\n   * <p>If you need to use\r\n   * a locator to refer to a single element in your application page, you can\r\n   * use <code>this.browserbot.findElement(\"id=foo\")</code> where \"id=foo\" is your locator.</p>\r\n   *\r\n   * @param script the JavaScript snippet to run\r\n   * @return string the results of evaluating the snippet\r\n   */\r\n  try {\r\n    //LOG.info('script is: ' + script);\r\n    let result = this.eval(script)\r\n    // Selenium RC doesn't allow returning null\r\n    if (null == result) return 'null'\r\n    return result\r\n  } catch (e) {\r\n    throw new SeleniumError('Threw an exception: ' + extractExceptionMessage(e))\r\n  }\r\n}\r\n\r\nSelenium.prototype.isChecked = function(locator) {\r\n  /**\r\n   * Gets whether a toggle-button (checkbox/radio) is checked.  Fails if the specified element doesn't exist or isn't a toggle-button.\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to a checkbox or radio button\r\n   * @return boolean true if the checkbox is checked, false otherwise\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.checked == null) {\r\n    throw new SeleniumError('Element ' + locator + ' is not a toggle-button.')\r\n  }\r\n  return element.checked\r\n}\r\n\r\nSelenium.prototype.getTable = function(tableCellAddress) {\r\n  /**\r\n   * Gets the text from a cell of a table. The cellAddress syntax\r\n   * tableLocator.row.column, where row and column start at 0.\r\n   *\r\n   * @param tableCellAddress a cell address, e.g. \"foo.1.4\"\r\n   * @return string the text from the specified cell\r\n   */\r\n  // This regular expression matches \"tableName.row.column\"\r\n  // For example, \"mytable.3.4\"\r\n  let pattern = /(.*)\\.(\\d+)\\.(\\d+)/\r\n\r\n  if (!pattern.test(tableCellAddress)) {\r\n    throw new SeleniumError(\r\n      'Invalid target format. Correct format is tableName.rowNum.columnNum'\r\n    )\r\n  }\r\n\r\n  let pieces = tableCellAddress.match(pattern)\r\n\r\n  let tableName = pieces[1]\r\n  let row = pieces[2]\r\n  let col = pieces[3]\r\n\r\n  let table = this.browserbot.findElement(tableName)\r\n  if (row > table.rows.length) {\r\n    // eslint-disable-next-line no-undef\r\n    Assert.fail(\r\n      'Cannot access row ' + row + ' - table has ' + table.rows.length + ' rows'\r\n    )\r\n  } else if (col > table.rows[row].cells.length) {\r\n    // eslint-disable-next-line no-undef\r\n    Assert.fail(\r\n      'Cannot access column ' +\r\n        col +\r\n        ' - table row has ' +\r\n        table.rows[row].cells.length +\r\n        ' columns'\r\n    )\r\n  } else {\r\n    let actualContent = bot.dom.getVisibleText(table.rows[row].cells[col])\r\n    return actualContent.trim()\r\n  }\r\n  return null\r\n}\r\n\r\nSelenium.prototype.getSelectedLabels = function(selectLocator) {\r\n  /** Gets all option labels (visible text) for selected options in the specified select or multi-select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string[] an array of all selected option labels in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperties(selectLocator, 'text')\r\n}\r\n\r\nSelenium.prototype.getSelectedLabel = function(selectLocator) {\r\n  /** Gets option label (visible text) for selected option in the specified select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string the selected option label in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperty(selectLocator, 'text')\r\n}\r\n\r\nSelenium.prototype.getSelectedValues = function(selectLocator) {\r\n  /** Gets all option values (value attributes) for selected options in the specified select or multi-select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string[] an array of all selected option values in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperties(selectLocator, 'value')\r\n}\r\n\r\nSelenium.prototype.getSelectedValue = function(selectLocator) {\r\n  /** Gets option value (value attribute) for selected option in the specified select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string the selected option value in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperty(selectLocator, 'value')\r\n}\r\n\r\nSelenium.prototype.getSelectedIndexes = function(selectLocator) {\r\n  /** Gets all option indexes (option number, starting at 0) for selected options in the specified select or multi-select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string[] an array of all selected option indexes in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperties(selectLocator, 'index')\r\n}\r\n\r\nSelenium.prototype.getSelectedIndex = function(selectLocator) {\r\n  /** Gets option index (option number, starting at 0) for selected option in the specified select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string the selected option index in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperty(selectLocator, 'index')\r\n}\r\n\r\nSelenium.prototype.getSelectedIds = function(selectLocator) {\r\n  /** Gets all option element IDs for selected options in the specified select or multi-select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string[] an array of all selected option IDs in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperties(selectLocator, 'id')\r\n}\r\n\r\nSelenium.prototype.getSelectedId = function(selectLocator) {\r\n  /** Gets option element ID for selected option in the specified select element.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string the selected option ID in the specified select drop-down\r\n   */\r\n  return this.findSelectedOptionProperty(selectLocator, 'id')\r\n}\r\n\r\nSelenium.prototype.isSomethingSelected = function(selectLocator) {\r\n  /** Determines whether some option in a drop-down menu is selected.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return boolean true if some option has been selected, false otherwise\r\n   */\r\n  let element = this.browserbot.findElement(selectLocator)\r\n  if (!('options' in element)) {\r\n    throw new SeleniumError(\r\n      'Specified element is not a Select (has no options)'\r\n    )\r\n  }\r\n\r\n  for (let i = 0; i < element.options.length; i++) {\r\n    if (element.options[i].selected) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nSelenium.prototype.findSelectedOptionProperties = function(locator, property) {\r\n  let element = this.browserbot.findElement(locator)\r\n  if (!('options' in element)) {\r\n    throw new SeleniumError(\r\n      'Specified element is not a Select (has no options)'\r\n    )\r\n  }\r\n\r\n  let selectedOptions = []\r\n\r\n  for (let i = 0; i < element.options.length; i++) {\r\n    if (element.options[i].selected) {\r\n      let propVal = element.options[i][property]\r\n      selectedOptions.push(propVal)\r\n    }\r\n  }\r\n  if (selectedOptions.length == 0) Assert.fail('No option selected') // eslint-disable-line no-undef\r\n  return selectedOptions\r\n}\r\n\r\nSelenium.prototype.findSelectedOptionProperty = function(locator, property) {\r\n  let selectedOptions = this.findSelectedOptionProperties(locator, property)\r\n  if (selectedOptions.length > 1) {\r\n    Assert.fail('More than one selected option!') // eslint-disable-line no-undef\r\n  }\r\n  return selectedOptions[0]\r\n}\r\n\r\nSelenium.prototype.getSelectOptions = function(selectLocator) {\r\n  /** Gets all option labels in the specified select drop-down.\r\n   *\r\n   * @param selectLocator an <a href=\"#locators\">element locator</a> identifying a drop-down menu\r\n   * @return string[] an array of all option labels in the specified select drop-down\r\n   */\r\n  let element = this.browserbot.findElement(selectLocator)\r\n\r\n  let selectOptions = []\r\n\r\n  for (let i = 0; i < element.options.length; i++) {\r\n    let option = element.options[i].text\r\n    selectOptions.push(option)\r\n  }\r\n\r\n  return selectOptions\r\n}\r\n\r\nSelenium.prototype.getAttribute = function(attributeLocator) {\r\n  /**\r\n   * Gets the value of an element attribute. The value of the attribute may\r\n   * differ across browsers (this is the case for the \"style\" attribute, for\r\n   * example).\r\n   *\r\n   * @param attributeLocator an element locator followed by an &#064; sign and then the name of the attribute, e.g. \"foo&#064;bar\"\r\n   * @return string the value of the specified attribute\r\n   */\r\n  let result = this.browserbot.findAttribute(attributeLocator)\r\n  if (result == null) {\r\n    throw new SeleniumError(\r\n      'Could not find element attribute: ' + attributeLocator\r\n    )\r\n  }\r\n  return result\r\n}\r\n\r\nSelenium.prototype.isTextPresent = function(pattern) {\r\n  /**\r\n   * Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.\r\n   * @param pattern a <a href=\"#patterns\">pattern</a> to match with the text of the page\r\n   * @return boolean true if the pattern matches the text, false otherwise\r\n   */\r\n  let allText = this.browserbot.bodyText()\r\n\r\n  let patternMatcher = new PatternMatcher(pattern)\r\n  if (patternMatcher.strategy == PatternMatcher.strategies.glob) {\r\n    if (pattern.indexOf('glob:') == 0) {\r\n      pattern = pattern.substring('glob:'.length) // strip off \"glob:\"\r\n    }\r\n    patternMatcher.matcher = new PatternMatcher.strategies.globContains(pattern)\r\n  } else if (patternMatcher.strategy == PatternMatcher.strategies.exact) {\r\n    pattern = pattern.substring('exact:'.length) // strip off \"exact:\"\r\n    return allText.indexOf(pattern) != -1\r\n  }\r\n  return patternMatcher.matches(allText)\r\n}\r\n\r\nfunction isElementNotPresent(locator) {\r\n  return !this.isElementPresent(locator)\r\n}\r\n\r\nSelenium.prototype.isElementPresent = function(locator) {\r\n  /**\r\n   * Verifies that the specified element is somewhere on the page.\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @return boolean true if the element is present, false otherwise\r\n   */\r\n  let element = this.browserbot.findElementOrNull(locator)\r\n  if (element == null) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction unableToLocateTargetElementError() {\r\n  throw new Error('Unable to locate target element.')\r\n}\r\n\r\nfunction isNotDisplayed(locator) {\r\n  try {\r\n    return !this.isVisible(locator)\r\n  } catch (error) {\r\n    unableToLocateTargetElementError()\r\n  }\r\n}\r\n\r\nfunction isDisplayed(locator) {\r\n  try {\r\n    return this.isVisible(locator)\r\n  } catch (error) {\r\n    return false\r\n  }\r\n}\r\n\r\nSelenium.prototype.isVisible = function(locator) {\r\n  /**\r\n   * Determines if the specified element is visible. An\r\n   * element can be rendered invisible by setting the CSS \"visibility\"\r\n   * property to \"hidden\", or the \"display\" property to \"none\", either for the\r\n   * element itself or one if its ancestors.  This method will fail if\r\n   * the element is not present.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @return boolean true if the specified element is visible, false otherwise\r\n   */\r\n  let element\r\n  element = this.browserbot.findElement(locator)\r\n  // DGF if it's an input tag of type \"hidden\" then it's not visible\r\n  if (element.tagName) {\r\n    let tagName = new String(element.tagName).toLowerCase()\r\n    if (tagName == 'input') {\r\n      if (element.type) {\r\n        let elementType = new String(element.type).toLowerCase()\r\n        if (elementType == 'hidden') {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n  }\r\n  let visibility = this.findEffectiveStyleProperty(element, 'visibility')\r\n  let _isDisplayed = this._isDisplayed(element)\r\n  return visibility != 'hidden' && _isDisplayed\r\n}\r\n\r\nSelenium.prototype.findEffectiveStyleProperty = function(element, property) {\r\n  let effectiveStyle = this.findEffectiveStyle(element)\r\n  let propertyValue = effectiveStyle[property]\r\n  if (propertyValue == 'inherit' && element.parentNode.style) {\r\n    return this.findEffectiveStyleProperty(element.parentNode, property)\r\n  }\r\n  return propertyValue\r\n}\r\n\r\nSelenium.prototype._isDisplayed = function(element) {\r\n  let display = this.findEffectiveStyleProperty(element, 'display')\r\n  if (display == 'none') return false\r\n  if (element.parentNode.style) {\r\n    return this._isDisplayed(element.parentNode)\r\n  }\r\n  return true\r\n}\r\n\r\nSelenium.prototype.findEffectiveStyle = function(element) {\r\n  if (element.style == undefined) {\r\n    return undefined // not a styled element\r\n  }\r\n  let window = this.browserbot.getCurrentWindow()\r\n  if (window.getComputedStyle) {\r\n    // DOM-Level-2-CSS\r\n    return window.getComputedStyle(element, null)\r\n  }\r\n  if (element.currentStyle) {\r\n    // non-standard IE alternative\r\n    return element.currentStyle\r\n    // TODO: this won't really work in a general sense, as\r\n    //   currentStyle is not identical to getComputedStyle()\r\n    //   ... but it's good enough for \"visibility\"\r\n  }\r\n\r\n  if (\r\n    window.document.defaultView &&\r\n    window.document.defaultView.getComputedStyle\r\n  ) {\r\n    return window.document.defaultView.getComputedStyle(element, null)\r\n  }\r\n\r\n  throw new SeleniumError(\r\n    'cannot determine effective stylesheet in this browser'\r\n  )\r\n}\r\n\r\nfunction isEditable(locator) {\r\n  try {\r\n    return this.isEditable(locator)\r\n  } catch (error) {\r\n    unableToLocateTargetElementError()\r\n  }\r\n}\r\n\r\nfunction isNotEditable(locator) {\r\n  try {\r\n    return !this.isEditable(locator)\r\n  } catch (error) {\r\n    unableToLocateTargetElementError()\r\n  }\r\n}\r\n\r\nSelenium.prototype.isEditable = function(locator) {\r\n  /**\r\n   * Determines whether the specified input element is editable, ie hasn't been disabled.\r\n   * This method will fail if the specified element isn't an input element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a>\r\n   * @return boolean true if the input element is editable, false otherwise\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.value == undefined) {\r\n    Assert.fail('Element ' + locator + ' is not an input.') // eslint-disable-line no-undef\r\n  }\r\n  if (element.disabled) {\r\n    return false\r\n  }\r\n  // DGF \"readonly\" is a bit goofy... it doesn't necessarily have a value\r\n  // You can write <input readonly value=\"black\">\r\n  let readOnlyNode = element.getAttributeNode('readonly')\r\n  if (readOnlyNode) {\r\n    // DGF on IE, every input element has a readOnly node, but it may be false\r\n    if (typeof readOnlyNode.nodeValue == 'boolean') {\r\n      let readOnly = readOnlyNode.nodeValue\r\n      if (readOnly) {\r\n        return false\r\n      }\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nSelenium.prototype.getAllButtons = function() {\r\n  /** Returns the IDs of all buttons on the page.\r\n   *\r\n   * <p>If a given button has no ID, it will appear as \"\" in this array.</p>\r\n   *\r\n   * @return string[] the IDs of all buttons on the page\r\n   */\r\n  return this.browserbot.getAllButtons()\r\n}\r\n\r\nSelenium.prototype.getAllLinks = function() {\r\n  /** Returns the IDs of all links on the page.\r\n   *\r\n   * <p>If a given link has no ID, it will appear as \"\" in this array.</p>\r\n   *\r\n   * @return string[] the IDs of all links on the page\r\n   */\r\n  return this.browserbot.getAllLinks()\r\n}\r\n\r\nSelenium.prototype.getAllFields = function() {\r\n  /** Returns the IDs of all input fields on the page.\r\n   *\r\n   * <p>If a given field has no ID, it will appear as \"\" in this array.</p>\r\n   *\r\n   * @return string[] the IDs of all field on the page\r\n   */\r\n  return this.browserbot.getAllFields()\r\n}\r\n\r\nSelenium.prototype.doSetMouseSpeed = function(pixels) {\r\n  /** Configure the number of pixels between \"mousemove\" events during dragAndDrop commands (default=10).\r\n   * <p>Setting this value to 0 means that we'll send a \"mousemove\" event to every single pixel\r\n   * in between the start location and the end location; that can be very slow, and may\r\n   * cause some browsers to force the JavaScript to timeout.</p>\r\n   *\r\n   * <p>If the mouse speed is greater than the distance between the two dragged objects, we'll\r\n   * just send one \"mousemove\" at the start location and then one final one at the end location.</p>\r\n   * @param pixels the number of pixels between \"mousemove\" events\r\n   */\r\n  let intValue = new Number(pixels)\r\n  if (intValue.constructor != Number || intValue < 0) {\r\n    this.mouseSpeed = Selenium.DEFAULT_MOUSE_SPEED\r\n  } else {\r\n    this.mouseSpeed = pixels\r\n  }\r\n}\r\n\r\nSelenium.prototype.getMouseSpeed = function() {\r\n  /** Returns the number of pixels between \"mousemove\" events during dragAndDrop commands (default=10).\r\n   *\r\n   * @return number the number of pixels between \"mousemove\" events during dragAndDrop commands (default=10)\r\n   */\r\n  return this.mouseSpeed\r\n}\r\n\r\nSelenium.prototype.doDragAndDrop = function(locator, movementsString) {\r\n  /** Drags an element a certain distance and then drops it\r\n   * @param locator an element locator\r\n   * @param movementsString offset in pixels from the current location to which the element should be moved, e.g., \"+70,-300\"\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let clientStartXY = getClientXY(element)\r\n  let clientStartX = clientStartXY[0]\r\n  let clientStartY = clientStartXY[1]\r\n\r\n  let movements = movementsString.split(/,/)\r\n  let movementX = Number(movements[0])\r\n  let movementY = Number(movements[1])\r\n\r\n  let clientFinishX =\r\n    clientStartX + movementX < 0 ? 0 : clientStartX + movementX\r\n  let clientFinishY =\r\n    clientStartY + movementY < 0 ? 0 : clientStartY + movementY\r\n\r\n  let mouseSpeed = this.mouseSpeed\r\n  let move = function(current, dest) {\r\n    if (current == dest) return current\r\n    if (Math.abs(current - dest) < mouseSpeed) return dest\r\n    return current < dest ? current + mouseSpeed : current - mouseSpeed\r\n  }\r\n\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mousedown',\r\n    true,\r\n    clientStartX,\r\n    clientStartY\r\n  )\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mousemove',\r\n    true,\r\n    clientStartX,\r\n    clientStartY\r\n  )\r\n  let clientX = clientStartX\r\n  let clientY = clientStartY\r\n\r\n  while (clientX != clientFinishX || clientY != clientFinishY) {\r\n    clientX = move(clientX, clientFinishX)\r\n    clientY = move(clientY, clientFinishY)\r\n    this.browserbot.triggerMouseEvent(\r\n      element,\r\n      'mousemove',\r\n      true,\r\n      clientX,\r\n      clientY\r\n    )\r\n  }\r\n\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mousemove',\r\n    true,\r\n    clientFinishX,\r\n    clientFinishY\r\n  )\r\n  this.browserbot.triggerMouseEvent(\r\n    element,\r\n    'mouseup',\r\n    true,\r\n    clientFinishX,\r\n    clientFinishY\r\n  )\r\n}\r\n\r\nSelenium.prototype.doDragAndDropToObject = function(\r\n  locatorOfObjectToBeDragged,\r\n  locatorOfDragDestinationObject\r\n) {\r\n  /** Drags an element and drops it on another element\r\n   *\r\n   * @param locatorOfObjectToBeDragged an element to be dragged\r\n   * @param locatorOfDragDestinationObject an element whose location (i.e., whose center-most pixel) will be the point where locatorOfObjectToBeDragged  is dropped\r\n   */\r\n  if (!this.browserbot.findElement(locatorOfObjectToBeDragged).draggable) {\r\n    //origin code\r\n    let startX = this.getElementPositionLeft(locatorOfObjectToBeDragged)\r\n    let startY = this.getElementPositionTop(locatorOfObjectToBeDragged)\r\n\r\n    let destinationLeftX = this.getElementPositionLeft(\r\n      locatorOfDragDestinationObject\r\n    )\r\n    let destinationTopY = this.getElementPositionTop(\r\n      locatorOfDragDestinationObject\r\n    )\r\n    let destinationWidth = this.getElementWidth(locatorOfDragDestinationObject)\r\n    let destinationHeight = this.getElementHeight(\r\n      locatorOfDragDestinationObject\r\n    )\r\n\r\n    let endX = Math.round(destinationLeftX + destinationWidth / 2)\r\n    let endY = Math.round(destinationTopY + destinationHeight / 2)\r\n\r\n    let deltaX = endX - startX\r\n    let deltaY = endY - startY\r\n\r\n    let movementsString = '' + deltaX + ',' + deltaY\r\n    this.doDragAndDrop(locatorOfObjectToBeDragged, movementsString)\r\n  } else {\r\n    //DragAndDropExt, Shuo-Heng Shih, SELAB, CSIE, NCKU, 2016/09/29\r\n    let element = this.browserbot.findElement(locatorOfObjectToBeDragged)\r\n    let target = this.browserbot.findElement(locatorOfDragDestinationObject)\r\n    this.browserbot.triggerDragEvent(element, target)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doWindowFocus = function() {\r\n  /** Gives focus to the currently selected window\r\n   *\r\n   */\r\n  this.browserbot.getCurrentWindow().focus()\r\n}\r\n\r\nSelenium.prototype.doWindowMaximize = function() {\r\n  /** Resize currently selected window to take up the entire screen\r\n   *\r\n   */\r\n  let window = this.browserbot.getCurrentWindow()\r\n  if (window != null && window.screen) {\r\n    window.moveTo(0, 0)\r\n\r\n    // It appears Firefox on Mac won't move a window to (0,0).  But, you can move it to (0,1), which\r\n    // seems to do basically the same thing.  In my (KJM - 6/20/10) tests, anything less than (0, 22)\r\n    // pushed the browser to (0,0), so it seems it's improperly accounting for something in the browser chrome.\r\n    if (window.screenX != 0) {\r\n      window.moveTo(0, 1)\r\n    }\r\n\r\n    window.resizeTo(screen.availWidth, screen.availHeight)\r\n  }\r\n}\r\n\r\nSelenium.prototype.getHtmlSource = function() {\r\n  /** Returns the entire HTML source between the opening and\r\n   * closing \"html\" tags.\r\n   *\r\n   * @return string the entire HTML source\r\n   */\r\n  return this.browserbot.getDocument().getElementsByTagName('html')[0].innerHTML\r\n}\r\n\r\nSelenium.prototype.doSetCursorPosition = function(locator, position) {\r\n  /**\r\n   * Moves the text cursor to the specified position in the given input element or textarea.\r\n   * This method will fail if the specified element isn't an input element or textarea.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an input element or textarea\r\n   * @param position the numerical position of the cursor in the field; position should be 0 to move the position to the beginning of the field.  You can also set the cursor to -1 to move it to the end of the field.\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  if (element.value == undefined) {\r\n    Assert.fail('Element ' + locator + ' is not an input.') // eslint-disable-line no-undef\r\n  }\r\n  if (position == -1) {\r\n    position = element.value.length\r\n  }\r\n\r\n  if (element.setSelectionRange && !browserVersion.isOpera) {\r\n    element.focus()\r\n    element.setSelectionRange(/*start*/ position, /*end*/ position)\r\n  } else if (element.createTextRange) {\r\n    bot.events.fire(element, bot.events.EventType.FOCUS)\r\n    let range = element.createTextRange()\r\n    range.collapse(true)\r\n    range.moveEnd('character', position)\r\n    range.moveStart('character', position)\r\n    range.select()\r\n  }\r\n}\r\n\r\nSelenium.prototype.getElementIndex = function(locator) {\r\n  /**\r\n   * Get the relative index of an element to its parent (starting from 0). The comment node and empty text node\r\n   * will be ignored.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an element\r\n   * @return number of relative index of the element to its parent (starting from 0)\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let previousSibling\r\n  let index = 0\r\n  while ((previousSibling = element.previousSibling) != null) {\r\n    if (!this._isCommentOrEmptyTextNode(previousSibling)) {\r\n      index++\r\n    }\r\n    element = previousSibling\r\n  }\r\n  return index\r\n}\r\n\r\nSelenium.prototype.isOrdered = function(locator1, locator2) {\r\n  /**\r\n   * Check if these two elements have same parent and are ordered siblings in the DOM. Two same elements will\r\n   * not be considered ordered.\r\n   *\r\n   * @param locator1 an <a href=\"#locators\">element locator</a> pointing to the first element\r\n   * @param locator2 an <a href=\"#locators\">element locator</a> pointing to the second element\r\n   * @return boolean true if element1 is the previous sibling of element2, false otherwise\r\n   */\r\n  let element1 = this.browserbot.findElement(locator1)\r\n  let element2 = this.browserbot.findElement(locator2)\r\n  if (element1 === element2) return false\r\n\r\n  let previousSibling\r\n  while ((previousSibling = element2.previousSibling) != null) {\r\n    if (previousSibling === element1) {\r\n      return true\r\n    }\r\n    element2 = previousSibling\r\n  }\r\n  return false\r\n}\r\n\r\nSelenium.prototype._isCommentOrEmptyTextNode = function(node) {\r\n  return (\r\n    node.nodeType == 8 || (node.nodeType == 3 && !/[^\\t\\n\\r ]/.test(node.data))\r\n  )\r\n}\r\n\r\nSelenium.prototype.getElementPositionLeft = function(locator) {\r\n  /**\r\n   * Retrieves the horizontal position of an element\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an element OR an element itself\r\n   * @return number of pixels from the edge of the frame.\r\n   */\r\n  let element\r\n  if ('string' == typeof locator) {\r\n    element = this.browserbot.findElement(locator)\r\n  } else {\r\n    element = locator\r\n  }\r\n  let x = element.offsetLeft\r\n  let elementParent = element.offsetParent\r\n\r\n  while (elementParent != null) {\r\n    if (document.all) {\r\n      if (elementParent.tagName != 'TABLE' && elementParent.tagName != 'BODY') {\r\n        x += elementParent.clientLeft\r\n      }\r\n    } // Netscape/DOM\r\n    else {\r\n      if (elementParent.tagName == 'TABLE') {\r\n        let parentBorder = parseInt(elementParent.border)\r\n        if (isNaN(parentBorder)) {\r\n          let parentFrame = elementParent.getAttribute('frame')\r\n          if (parentFrame != null) {\r\n            x += 1\r\n          }\r\n        } else if (parentBorder > 0) {\r\n          x += parentBorder\r\n        }\r\n      }\r\n    }\r\n    x += elementParent.offsetLeft\r\n    elementParent = elementParent.offsetParent\r\n  }\r\n  return x\r\n}\r\n\r\nSelenium.prototype.getElementPositionTop = function(locator) {\r\n  /**\r\n   * Retrieves the vertical position of an element\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an element OR an element itself\r\n   * @return number of pixels from the edge of the frame.\r\n   */\r\n  let element\r\n  if ('string' == typeof locator) {\r\n    element = this.browserbot.findElement(locator)\r\n  } else {\r\n    element = locator\r\n  }\r\n\r\n  let y = 0\r\n\r\n  while (element != null) {\r\n    if (document.all) {\r\n      if (element.tagName != 'TABLE' && element.tagName != 'BODY') {\r\n        y += element.clientTop\r\n      }\r\n    } // Netscape/DOM\r\n    else {\r\n      if (element.tagName == 'TABLE') {\r\n        let parentBorder = parseInt(element.border)\r\n        if (isNaN(parentBorder)) {\r\n          let parentFrame = element.getAttribute('frame')\r\n          if (parentFrame != null) {\r\n            y += 1\r\n          }\r\n        } else if (parentBorder > 0) {\r\n          y += parentBorder\r\n        }\r\n      }\r\n    }\r\n    y += element.offsetTop\r\n\r\n    // Netscape can get confused in some cases, such that the height of the parent is smaller\r\n    // than that of the element (which it shouldn't really be). If this is the case, we need to\r\n    // exclude this element, since it will result in too large a 'top' return value.\r\n    if (\r\n      element.offsetParent &&\r\n      element.offsetParent.offsetHeight &&\r\n      element.offsetParent.offsetHeight < element.offsetHeight\r\n    ) {\r\n      // skip the parent that's too small\r\n      element = element.offsetParent.offsetParent\r\n    } else {\r\n      // Next up...\r\n      element = element.offsetParent\r\n    }\r\n  }\r\n  return y\r\n}\r\n\r\nSelenium.prototype.getElementWidth = function(locator) {\r\n  /**\r\n   * Retrieves the width of an element\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an element\r\n   * @return number width of an element in pixels\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  return element.offsetWidth\r\n}\r\n\r\nSelenium.prototype.getElementHeight = function(locator) {\r\n  /**\r\n   * Retrieves the height of an element\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an element\r\n   * @return number height of an element in pixels\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  return element.offsetHeight\r\n}\r\n\r\nSelenium.prototype.getCursorPosition = function(locator) {\r\n  /**\r\n   * Retrieves the text cursor position in the given input element or textarea; beware, this may not work perfectly on all browsers.\r\n   *\r\n   * <p>Specifically, if the cursor/selection has been cleared by JavaScript, this command will tend to\r\n   * return the position of the last location of the cursor, even though the cursor is now gone from the page.  This is filed as <a href=\"http://jira.openqa.org/browse/SEL-243\">SEL-243</a>.</p>\r\n   * This method will fail if the specified element isn't an input element or textarea, or there is no cursor in the element.\r\n   *\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an input element or textarea\r\n   * @return number the numerical position of the cursor in the field\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let doc = this.browserbot.getDocument()\r\n  let win = this.browserbot.getCurrentWindow()\r\n  let elementRange\r\n  if (doc.selection && !browserVersion.isOpera) {\r\n    try {\r\n      let selectRange = doc.selection.createRange().duplicate()\r\n      elementRange = element.createTextRange()\r\n      selectRange.move('character', 0)\r\n      elementRange.move('character', 0)\r\n      elementRange.setEndPoint('EndToEnd', selectRange)\r\n    } catch (e) {\r\n      Assert.fail('There is no cursor on this page!') // eslint-disable-line no-undef\r\n    }\r\n    let answer = String(elementRange.text).replace(/\\r/g, '').length\r\n    return answer\r\n  } else {\r\n    if (typeof element.selectionStart != 'undefined') {\r\n      if (\r\n        win.getSelection &&\r\n        typeof win.getSelection().rangeCount != undefined &&\r\n        win.getSelection().rangeCount == 0\r\n      ) {\r\n        Assert.fail('There is no cursor on this page!') // eslint-disable-line no-undef\r\n      }\r\n      return element.selectionStart\r\n    }\r\n  }\r\n  throw new Error(\"Couldn't detect cursor position on this browser!\")\r\n}\r\n\r\nSelenium.prototype.getExpression = function(expression) {\r\n  /**\r\n   * Returns the specified expression.\r\n   *\r\n   * <p>This is useful because of JavaScript preprocessing.\r\n   * It is used to generate commands like assertExpression and waitForExpression.</p>\r\n   *\r\n   * @param expression the value to return\r\n   * @return string the value passed in\r\n   */\r\n  return expression\r\n}\r\n\r\nSelenium.prototype.getXpathCount = function(xpath) {\r\n  /**\r\n   * Returns the number of nodes that match the specified xpath, eg. \"//table\" would give\r\n   * the number of tables.\r\n   *\r\n   * @param xpath the xpath expression to evaluate. do NOT wrap this expression in a 'count()' function; we will do that for you.\r\n   * @return number the number of nodes that match the specified xpath\r\n   */\r\n  let result = this.browserbot.evaluateXPathCount(\r\n    xpath,\r\n    this.browserbot.getDocument()\r\n  )\r\n  return result\r\n}\r\n\r\nSelenium.prototype.getCssCount = function(css) {\r\n  /**\r\n   * Returns the number of nodes that match the specified css selector, eg. \"css=table\" would give\r\n   * the number of tables.\r\n   *\r\n   * @param css the css selector to evaluate. do NOT wrap this expression in a 'count()' function; we will do that for you.\r\n   * @return the number of nodes that match the specified selector\r\n   */\r\n  let result = this.browserbot.evaluateCssCount(\r\n    css,\r\n    this.browserbot.getDocument()\r\n  )\r\n  return result\r\n}\r\n\r\nSelenium.prototype.doAssignId = function(locator, identifier) {\r\n  /**\r\n   * Temporarily sets the \"id\" attribute of the specified element, so you can locate it in the future\r\n   * using its ID rather than a slow/complicated XPath.  This ID will disappear once the page is\r\n   * reloaded.\r\n   * @param locator an <a href=\"#locators\">element locator</a> pointing to an element\r\n   * @param identifier a string to be used as the ID of the specified element\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  element.id = identifier\r\n}\r\n\r\nSelenium.prototype.doAllowNativeXpath = function(allow) {\r\n  /**\r\n   * Specifies whether Selenium should use the native in-browser implementation\r\n   * of XPath (if any native version is available); if you pass \"false\" to\r\n   * this function, we will always use our pure-JavaScript xpath library.\r\n   * Using the pure-JS xpath library can improve the consistency of xpath\r\n   * element locators between different browser vendors, but the pure-JS\r\n   * version is much slower than the native implementations.\r\n   * @param allow boolean, true means we'll prefer to use native XPath; false means we'll only use JS XPath\r\n   */\r\n  if ('false' == allow || '0' == allow) {\r\n    // The strings \"false\" and \"0\" are true values in JS\r\n    allow = false\r\n  }\r\n  this.browserbot.setAllowNativeXPath(allow)\r\n}\r\n\r\nSelenium.prototype.doIgnoreAttributesWithoutValue = function(ignore) {\r\n  /**\r\n   * Specifies whether Selenium will ignore xpath attributes that have no\r\n   * value, i.e. are the empty string, when using the non-native xpath\r\n   * evaluation engine. You'd want to do this for performance reasons in IE.\r\n   * However, this could break certain xpaths, for example an xpath that looks\r\n   * for an attribute whose value is NOT the empty string.\r\n   *\r\n   * The hope is that such xpaths are relatively rare, but the user should\r\n   * have the option of using them. Note that this only influences xpath\r\n   * evaluation when using the ajaxslt engine (i.e. not \"javascript-xpath\").\r\n   *\r\n   * @param ignore boolean, true means we'll ignore attributes without value\r\n   *                        at the expense of xpath \"correctness\"; false means\r\n   *                        we'll sacrifice speed for correctness.\r\n   */\r\n  if ('false' == ignore || '0' == ignore) {\r\n    ignore = false\r\n  }\r\n  this.browserbot.setIgnoreAttributesWithoutValue(ignore)\r\n}\r\n\r\nSelenium.prototype.doWaitForCondition = function(script, timeout) {\r\n  /**\r\n   * Runs the specified JavaScript snippet repeatedly until it evaluates to \"true\".\r\n   * The snippet may have multiple lines, but only the result of the last line\r\n   * will be considered.\r\n   *\r\n   * <p>Note that, by default, the snippet will be run in the runner's test window, not in the window\r\n   * of your application.  To get the window of your application, you can use\r\n   * the JavaScript snippet <code>selenium.browserbot.getCurrentWindow()</code>, and then\r\n   * run your JavaScript in there</p>\r\n   * @param script the JavaScript snippet to run\r\n   * @param timeout a timeout in milliseconds, after which this command will return with an error\r\n   */\r\n\r\n  return Selenium.decorateFunctionWithTimeout(function() {\r\n    return this.eval(script)\r\n  }, timeout)\r\n}\r\n\r\nSelenium.prototype.doWaitForCondition.dontCheckAlertsAndConfirms = true\r\n\r\nSelenium.prototype.doSetTimeout = function(timeout) {\r\n  /**\r\n   * Specifies the amount of time that Selenium will wait for actions to complete.\r\n   *\r\n   * <p>Actions that require waiting include \"open\" and the \"waitFor*\" actions.</p>\r\n   * The default timeout is 30 seconds.\r\n   * @param timeout a timeout in milliseconds, after which the action will return with an error\r\n   */\r\n  if (!timeout) {\r\n    timeout = Selenium.DEFAULT_TIMEOUT\r\n  }\r\n  this.defaultTimeout = timeout\r\n}\r\n\r\nSelenium.prototype.doWaitForPageToLoad = function(timeout) {\r\n  /**\r\n   * Waits for a new page to load.\r\n   *\r\n   * <p>You can use this command instead of the \"AndWait\" suffixes, \"clickAndWait\", \"selectAndWait\", \"typeAndWait\" etc.\r\n   * (which are only available in the JS API).</p>\r\n   *\r\n   * <p>Selenium constantly keeps track of new pages loading, and sets a \"newPageLoaded\"\r\n   * flag when it first notices a page load.  Running any other Selenium command after\r\n   * turns the flag to false.  Hence, if you want to wait for a page to load, you must\r\n   * wait immediately after a Selenium command that caused a page-load.</p>\r\n   * @param timeout a timeout in milliseconds, after which this command will return with an error\r\n   */\r\n  // in pi-mode, the test and the harness share the window; thus if we are executing this code, then we have loaded\r\n  if (window['proxyInjectionMode'] == null || !window['proxyInjectionMode']) {\r\n    return this.makePageLoadCondition(timeout)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doWaitForFrameToLoad = function(_frameAddress, timeout) {\r\n  /**\r\n   * Waits for a new frame to load.\r\n   *\r\n   * <p>Selenium constantly keeps track of new pages and frames loading,\r\n   * and sets a \"newPageLoaded\" flag when it first notices a page load.</p>\r\n   *\r\n   * See waitForPageToLoad for more information.\r\n   *\r\n   * @param frameAddress FrameAddress from the server side\r\n   * @param timeout a timeout in milliseconds, after which this command will return with an error\r\n   */\r\n  // in pi-mode, the test and the harness share the window; thus if we are executing this code, then we have loaded\r\n  if (window['proxyInjectionMode'] == null || !window['proxyInjectionMode']) {\r\n    return this.makePageLoadCondition(timeout)\r\n  }\r\n}\r\n\r\nSelenium.prototype._isNewPageLoaded = function() {\r\n  return this.browserbot.isNewPageLoaded()\r\n}\r\n\r\nSelenium.prototype._abortXhrRequest = function() {\r\n  return this.browserbot.abortXhrRequest()\r\n}\r\n\r\nSelenium.prototype.doWaitForPageToLoad.dontCheckAlertsAndConfirms = true\r\n\r\n/**\r\n * Evaluate a parameter, performing JavaScript evaluation and variable substitution.\r\n * If the string matches the pattern \"javascript{ ... }\", evaluate the string between the braces.\r\n */\r\nSelenium.prototype.preprocessParameter = function(value) {\r\n  if (!value.script) {\r\n    // only for non-scripts\r\n    let match = value.match(/^javascript\\{((.|\\r?\\n)+)\\}$/)\r\n    if (match && match[1]) {\r\n      browser.runtime.sendMessage({\r\n        log: {\r\n          type: 'warn',\r\n          message:\r\n            'parameter preprocessing using javascript{} tag is deprecated, please use execute script',\r\n        },\r\n      })\r\n      let result = this.eval(match[1])\r\n      return result == null ? null : result.toString()\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\nSelenium.prototype.replaceKeys = function(str) {\r\n  let keys = []\r\n  let match = str.match(/\\$\\{\\w+\\}/g)\r\n  if (!match) {\r\n    keys.push(str)\r\n  } else {\r\n    let i = 0\r\n    while (i < str.length) {\r\n      let currentKey = match.shift(),\r\n        currentKeyIndex = str.indexOf(currentKey, i)\r\n      if (currentKeyIndex > i) {\r\n        // push the string before the current key\r\n        keys.push(str.substr(i, currentKeyIndex - i))\r\n        i = currentKeyIndex\r\n      }\r\n      if (currentKey) {\r\n        if (/^\\$\\{KEY_\\w+\\}/.test(currentKey)) {\r\n          // is a key\r\n          let keyName = currentKey.match(/\\$\\{KEY_(\\w+)\\}/)[1]\r\n          let key = bot.Keyboard.Keys[keyName]\r\n          if (key) {\r\n            keys.push(key)\r\n          } else {\r\n            throw new Error(`Unrecognised key ${keyName}`)\r\n          }\r\n        } else {\r\n          // not a key, and not a stored variable, push it as-is\r\n          keys.push(currentKey)\r\n        }\r\n        i += currentKey.length\r\n      } else if (i < str.length) {\r\n        // push the rest of the string\r\n        keys.push(str.substr(i, str.length))\r\n        i = str.length\r\n      }\r\n    }\r\n  }\r\n  return keys\r\n}\r\n\r\nSelenium.prototype.getCookie = function() {\r\n  /**\r\n   * Return all cookies of the current page under test.\r\n   *\r\n   * @return string all cookies of the current page under test\r\n   */\r\n  let doc = this.browserbot.getDocument()\r\n  return doc.cookie\r\n}\r\n\r\nSelenium.prototype.getCookieByName = function(name) {\r\n  /**\r\n   * Returns the value of the cookie with the specified name, or throws an error if the cookie is not present.\r\n   * @param name the name of the cookie\r\n   * @return string the value of the cookie\r\n   */\r\n  let v = this.browserbot.getCookieByName(name)\r\n  if (v === null) {\r\n    throw new SeleniumError(\"Cookie '\" + name + \"' was not found\")\r\n  }\r\n  return v\r\n}\r\n\r\nSelenium.prototype.isCookiePresent = function(name) {\r\n  /**\r\n   * Returns true if a cookie with the specified name is present, or false otherwise.\r\n   * @param name the name of the cookie\r\n   * @return boolean true if a cookie with the specified name is present, or false otherwise.\r\n   */\r\n  let v = this.browserbot.getCookieByName(name)\r\n  let absent = v === null\r\n  return !absent\r\n}\r\n\r\nSelenium.prototype.doCreateCookie = function(nameValuePair, optionsString) {\r\n  /**\r\n   * Create a new cookie whose path and domain are same with those of current page\r\n   * under test, unless you specified a path for this cookie explicitly.\r\n   *\r\n   * @param nameValuePair name and value of the cookie in a format \"name=value\"\r\n   * @param optionsString options for the cookie. Currently supported options include 'path', 'max_age' and 'domain'.\r\n   *      the optionsString's format is \"path=/path/, max_age=60, domain=.foo.com\". The order of options are irrelevant, the unit\r\n   *      of the value of 'max_age' is second.  Note that specifying a domain that isn't a subset of the current domain will\r\n   *      usually fail.\r\n   */\r\n  // eslint-disable-next-line no-useless-escape\r\n  let results = /[^\\s=\\[\\]\\(\\),\"\\/\\?@:;]+=[^\\s=\\[\\]\\(\\),\"\\/\\?@:;]*/.test(\r\n    nameValuePair\r\n  )\r\n  if (!results) {\r\n    throw new SeleniumError('Invalid parameter.')\r\n  }\r\n  let cookie = nameValuePair.trim()\r\n  results = /max_age=(\\d+)/.exec(optionsString)\r\n  if (results) {\r\n    let expireDateInMilliseconds = new Date().getTime() + results[1] * 1000\r\n    cookie += '; expires=' + new Date(expireDateInMilliseconds).toGMTString()\r\n  }\r\n  results = /path=([^\\s,]+)[,]?/.exec(optionsString)\r\n  if (results) {\r\n    let path = results[1]\r\n    if (browserVersion.khtml) {\r\n      // Safari and conquerer don't like paths with / at the end\r\n      if ('/' != path) {\r\n        path = path.replace(/\\/$/, '')\r\n      }\r\n    }\r\n    cookie += '; path=' + path\r\n  }\r\n  results = /domain=([^\\s,]+)[,]?/.exec(optionsString)\r\n  if (results) {\r\n    let domain = results[1]\r\n    cookie += '; domain=' + domain\r\n  }\r\n  //LOG.debug(\"Setting cookie to: \" + cookie);\r\n  this.browserbot.getDocument().cookie = cookie\r\n}\r\n\r\nSelenium.prototype.doDeleteCookie = function(name, optionsString) {\r\n  /**\r\n   * Delete a named cookie with specified path and domain.  Be careful; to delete a cookie, you\r\n   * need to delete it using the exact same path and domain that were used to create the cookie.\r\n   * If the path is wrong, or the domain is wrong, the cookie simply won't be deleted.  Also\r\n   * note that specifying a domain that isn't a subset of the current domain will usually fail.\r\n   *\r\n   * Since there's no way to discover at runtime the original path and domain of a given cookie,\r\n   * we've added an option called 'recurse' to try all sub-domains of the current domain with\r\n   * all paths that are a subset of the current path.  Beware; this option can be slow.  In\r\n   * big-O notation, it operates in O(n*m) time, where n is the number of dots in the domain\r\n   * name and m is the number of slashes in the path.\r\n   *\r\n   * @param name the name of the cookie to be deleted\r\n   * @param optionsString options for the cookie. Currently supported options include 'path', 'domain'\r\n   *      and 'recurse.' The optionsString's format is \"path=/path/, domain=.foo.com, recurse=true\".\r\n   *      The order of options are irrelevant. Note that specifying a domain that isn't a subset of\r\n   *      the current domain will usually fail.\r\n   */\r\n  // set the expire time of the cookie to be deleted to one minute before now.\r\n  let path = ''\r\n  let domain = ''\r\n  let recurse = false\r\n  let matched = false\r\n  let results = /path=([^\\s,]+)[,]?/.exec(optionsString)\r\n  if (results) {\r\n    matched = true\r\n    path = results[1]\r\n  }\r\n  results = /domain=([^\\s,]+)[,]?/.exec(optionsString)\r\n  if (results) {\r\n    matched = true\r\n    domain = results[1]\r\n  }\r\n  results = /recurse=([^\\s,]+)[,]?/.exec(optionsString)\r\n  if (results) {\r\n    matched = true\r\n    recurse = results[1]\r\n    if ('false' == recurse) {\r\n      recurse = false\r\n    }\r\n  }\r\n  // Treat the entire optionsString as a path (for backwards compatibility)\r\n  if (optionsString && !matched) {\r\n    //LOG.warn(\"Using entire optionsString as a path; please change the argument to deleteCookie to use path=\" + optionsString);\r\n    path = optionsString\r\n  }\r\n  if (browserVersion.khtml) {\r\n    // Safari and conquerer don't like paths with / at the end\r\n    if ('/' != path) {\r\n      path = path.replace(/\\/$/, '')\r\n    }\r\n  }\r\n  path = path.trim()\r\n  domain = domain.trim()\r\n  let cookieName = name.trim()\r\n  if (recurse) {\r\n    this.browserbot.recursivelyDeleteCookie(cookieName, domain, path)\r\n  } else {\r\n    this.browserbot.deleteCookie(cookieName, domain, path)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doDeleteAllVisibleCookies = function() {\r\n  /** Calls deleteCookie with recurse=true on all cookies visible to the current page.\r\n   * As noted on the documentation for deleteCookie, recurse=true can be much slower\r\n   * than simply deleting the cookies using a known domain/path.\r\n   */\r\n  let win = this.browserbot.getCurrentWindow()\r\n  let doc = win.document\r\n  let cookieNames = this.browserbot.getAllCookieNames(doc)\r\n  let domain = doc.domain\r\n  let path = win.location.pathname\r\n  for (let i = 0; i < cookieNames.length; i++) {\r\n    this.browserbot.recursivelyDeleteCookie(cookieNames[i], domain, path, win)\r\n  }\r\n}\r\n\r\n//Selenium.prototype.doSetBrowserLogLevel = function(logLevel) {\r\n/**\r\n * Sets the threshold for browser-side logging messages; log messages beneath this threshold will be discarded.\r\n * Valid logLevel strings are: \"debug\", \"info\", \"warn\", \"error\" or \"off\".\r\n * To see the browser logs, you need to\r\n * either show the log window in GUI mode, or enable browser-side logging in Selenium RC.\r\n *\r\n * @param logLevel one of the following: \"debug\", \"info\", \"warn\", \"error\" or \"off\"\r\n */\r\n/*    if (logLevel == null || logLevel == \"\") {\r\n        throw new SeleniumError(\"You must specify a log level\");\r\n    }\r\n    logLevel = logLevel.toLowerCase();\r\n    if (//LOG.logLevels[logLevel] == null) {\r\n        throw new SeleniumError(\"Invalid log level: \" + logLevel);\r\n    }\r\n    //LOG.setLogLevelThreshold(logLevel);\r\n}*/\r\n\r\nSelenium.prototype.doExecuteScript = function(script, varName) {\r\n  const value = this.eval(script.script, script.argv)\r\n  if (value && value.constructor.name === 'Promise') {\r\n    throw new Error('Expected sync operation, instead received Promise')\r\n  }\r\n  if (varName) {\r\n    return browser.runtime.sendMessage({ storeStr: value, storeVar: varName })\r\n  }\r\n}\r\n\r\nSelenium.prototype.doExecuteAsyncScript = function(script, varName) {\r\n  const value = this.eval(script.script, script.argv)\r\n  if (value && value.constructor.name !== 'Promise') {\r\n    throw new Error(\r\n      `Expected async operation, instead received ${\r\n        value ? value.constructor.name : value\r\n      }`\r\n    )\r\n  }\r\n  return Promise.resolve(value).then(v => {\r\n    if (varName) {\r\n      return browser.runtime.sendMessage({ storeStr: v, storeVar: varName })\r\n    }\r\n  })\r\n}\r\n\r\nSelenium.prototype.doRunScript = function(script) {\r\n  /**\r\n   * Creates a new \"script\" tag in the body of the current test window, and\r\n   * adds the specified text into the body of the command.  Scripts run in\r\n   * this way can often be debugged more easily than scripts executed using\r\n   * Selenium's \"getEval\" command.  Beware that JS exceptions thrown in these script\r\n   * tags aren't managed by Selenium, so you should probably wrap your script\r\n   * in try/catch blocks if there is any chance that the script will throw\r\n   * an exception.\r\n   * @param script the JavaScript snippet to run\r\n   */\r\n  this.eval(script.script, script.argv)\r\n}\r\n\r\nSelenium.prototype.doRollup = function(rollupName, kwargs) {\r\n  /**\r\n   * Executes a command rollup, which is a series of commands with a unique\r\n   * name, and optionally arguments that control the generation of the set of\r\n   * commands. If any one of the rolled-up commands fails, the rollup is\r\n   * considered to have failed. Rollups may also contain nested rollups.\r\n   *\r\n   * @param rollupName  the name of the rollup command\r\n   * @param kwargs      keyword arguments string that influences how the\r\n   *                    rollup expands into commands\r\n   */\r\n  // we have to temporarily hijack the commandStarted, nextCommand(),\r\n  // commandComplete(), and commandError() methods of the TestLoop object.\r\n  // When the expanded rollup commands are done executing (or an error has\r\n  // occurred), we'll restore them to their original values.\r\n  let loop = currentTest || htmlTestRunner.currentTest // eslint-disable-line no-undef\r\n  let backupManager = {\r\n    backup: function() {\r\n      for (let item in this.data) {\r\n        this.data[item] = loop[item]\r\n      }\r\n    },\r\n    restore: function() {\r\n      for (let item in this.data) {\r\n        loop[item] = this.data[item]\r\n      }\r\n    },\r\n    data: {\r\n      requiresCallBack: null,\r\n      commandStarted: null,\r\n      nextCommand: null,\r\n      commandComplete: null,\r\n      commandError: null,\r\n      pendingRollupCommands: null,\r\n      rollupFailed: null,\r\n      rollupFailedMessage: null,\r\n    },\r\n  }\r\n\r\n  // eslint-disable-next-line no-undef\r\n  let rule = RollupManager.getInstance().getRollupRule(rollupName)\r\n  let expandedCommands = rule.getExpandedCommands(kwargs)\r\n\r\n  // hold your breath ...\r\n  try {\r\n    backupManager.backup()\r\n    loop.requiresCallBack = false\r\n    loop.commandStarted = function() {}\r\n    loop.nextCommand = function() {\r\n      if (this.pendingRollupCommands.length == 0) {\r\n        return null\r\n      }\r\n      let command = this.pendingRollupCommands.shift()\r\n      return command\r\n    }\r\n    loop.commandComplete = function(result) {\r\n      if (result.failed) {\r\n        this.rollupFailed = true\r\n        this.rollupFailureMessages.push(result.failureMessage)\r\n      }\r\n\r\n      if (this.pendingRollupCommands.length == 0) {\r\n        result = {\r\n          failed: this.rollupFailed,\r\n          failureMessage: this.rollupFailureMessages.join('; '),\r\n        }\r\n        //LOG.info('Rollup execution complete: ' + (result.failed ? 'failed! (see error messages below)' : 'ok'));\r\n        backupManager.restore()\r\n        this.commandComplete(result)\r\n      }\r\n    }\r\n    loop.commandError = function(errorMessage) {\r\n      //LOG.info('Rollup execution complete: bombed!');\r\n      backupManager.restore()\r\n      this.commandError(errorMessage)\r\n    }\r\n\r\n    loop.pendingRollupCommands = expandedCommands\r\n    loop.rollupFailed = false\r\n    loop.rollupFailureMessages = []\r\n  } catch (e) {\r\n    //LOG.error('Rollup error: ' + e);\r\n    backupManager.restore()\r\n  }\r\n}\r\n\r\nSelenium.prototype.doAddScript = function(scriptContent, scriptTagId) {\r\n  /**\r\n   * Loads script content into a new script tag in the Selenium document. This\r\n   * differs from the runScript command in that runScript adds the script tag\r\n   * to the document of the AUT, not the Selenium document. The following\r\n   * entities in the script content are replaced by the characters they\r\n   * represent:\r\n   *\r\n   *     &lt;\r\n   *     &gt;\r\n   *     &amp;\r\n   *\r\n   * The corresponding remove command is removeScript.\r\n   *\r\n   * @param scriptContent  the Javascript content of the script to add\r\n   * @param scriptTagId    (optional) the id of the new script tag. If\r\n   *                       specified, and an element with this id already\r\n   *                       exists, this operation will fail.\r\n   */\r\n  if (scriptTagId && document.getElementById(scriptTagId)) {\r\n    let msg = \"Element with id '\" + scriptTagId + \"' already exists!\"\r\n    throw new SeleniumError(msg)\r\n  }\r\n\r\n  let head = document.getElementsByTagName('head')[0]\r\n  let script = document.createElement('script')\r\n\r\n  script.type = 'text/javascript'\r\n\r\n  if (scriptTagId) {\r\n    script.id = scriptTagId\r\n  }\r\n\r\n  // replace some entities\r\n  scriptContent = scriptContent\r\n    .replace(/&lt;/g, '<')\r\n    .replace(/&gt;/g, '>')\r\n    .replace(/&amp;/g, '&')\r\n\r\n  script.text = scriptContent\r\n  head.appendChild(script)\r\n}\r\n\r\nSelenium.prototype.doRemoveScript = function(scriptTagId) {\r\n  /**\r\n   * Removes a script tag from the Selenium document identified by the given\r\n   * id. Does nothing if the referenced tag doesn't exist.\r\n   *\r\n   * @param scriptTagId  the id of the script element to remove.\r\n   */\r\n  let script = document.getElementById(scriptTagId)\r\n\r\n  if (script && getTagName(script) == 'script') {\r\n    script.parentNode.removeChild(script)\r\n  }\r\n}\r\n\r\nSelenium.prototype.doUseXpathLibrary = function(libraryName) {\r\n  /**\r\n   * Allows choice of one of the available libraries.\r\n   * @param libraryName name of the desired library\r\n   * Only the following can be chosen:\r\n   * <ul>\r\n   *   <li>\"ajaxslt\" - Google's library</li>\r\n   *   <li>\"javascript-xpath\" - Cybozu Labs' faster library</li>\r\n   *   <li>\"rpc-optimizing-ajaxslt\" - the RPC optimizing strategy, delegating to ajaxslt</li>\r\n   *   <li>\"rpc-optimizing-jsxpath\" - the RPC optimizing strategy, delegating to javascript-xpath</li>\r\n   *   <li>\"default\" - The default library.  Currently the default library is \"ajaxslt\" .</li>\r\n   * </ul>\r\n   * If libraryName isn't one of these, it may be the name of another engine\r\n   * registered to the browserbot's XPathEvaluator, for example by overriding\r\n   * XPathEvaluator.prototype.init() . If it is not a registered engine\r\n   * either, then no change will be made.\r\n   */\r\n\r\n  if (!this.browserbot.getXPathEngine(libraryName)) {\r\n    return\r\n  }\r\n\r\n  this.browserbot.setXPathEngine(libraryName)\r\n}\r\n\r\n/**\r\n *  Factory for creating \"Option Locators\".\r\n *  An OptionLocator is an object for dealing with Select options (e.g. for\r\n *  finding a specified option, or asserting that the selected option of\r\n *  Select element matches some condition.\r\n *  The type of locator returned by the factory depends on the locator string:\r\n *     label=<exp>  (OptionLocatorByLabel)\r\n *     value=<exp>  (OptionLocatorByValue)\r\n *     index=<exp>  (OptionLocatorByIndex)\r\n *     id=<exp>     (OptionLocatorById)\r\n *     <exp> (default is OptionLocatorByLabel).\r\n */\r\nfunction OptionLocatorFactory() {}\r\n\r\nOptionLocatorFactory.prototype.fromLocatorString = function(locatorString) {\r\n  let locatorType = 'label'\r\n  let locatorValue = locatorString\r\n  // If there is a locator prefix, use the specified strategy\r\n  let result = locatorString.match(/^([a-zA-Z]+)=(.*)/)\r\n  if (result) {\r\n    locatorType = result[1]\r\n    locatorValue = result[2]\r\n  }\r\n  if (this.optionLocators == undefined) {\r\n    this.registerOptionLocators()\r\n  }\r\n  if (this.optionLocators[locatorType]) {\r\n    return new this.optionLocators[locatorType](locatorValue)\r\n  }\r\n  throw new SeleniumError('Unknown option locator type: ' + locatorType)\r\n}\r\n\r\n/**\r\n * To allow for easy extension, all of the option locators are found by\r\n * searching for all methods of OptionLocatorFactory.prototype that start\r\n * with \"OptionLocatorBy\".\r\n * TODO: Consider using the term \"Option Specifier\" instead of \"Option Locator\".\r\n */\r\nOptionLocatorFactory.prototype.registerOptionLocators = function() {\r\n  this.optionLocators = {}\r\n  for (let functionName in this) {\r\n    let result = /OptionLocatorBy([A-Z].+)$/.exec(functionName)\r\n    if (result != null) {\r\n      let locatorName = lowerFirstChar(result[1])\r\n      this.optionLocators[locatorName] = this[functionName]\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *  OptionLocator for options identified by their labels.\r\n */\r\nOptionLocatorFactory.prototype.OptionLocatorByLabel = function(label) {\r\n  this.label = label\r\n  this.labelMatcher = new PatternMatcher(this.label)\r\n  this.findOption = function(element) {\r\n    for (let i = 0; i < element.options.length; i++) {\r\n      if (this.labelMatcher.matches(element.options[i].text)) {\r\n        return element.options[i]\r\n      }\r\n    }\r\n    throw new SeleniumError(\"Option with label '\" + this.label + \"' not found\")\r\n  }\r\n\r\n  this.assertSelected = function(element) {\r\n    let selectedLabel = element.options[element.selectedIndex].text\r\n    Assert.matches(this.label, selectedLabel) // eslint-disable-line no-undef\r\n  }\r\n}\r\n\r\n/**\r\n *  OptionLocator for options identified by their values.\r\n */\r\nOptionLocatorFactory.prototype.OptionLocatorByValue = function(value) {\r\n  this.value = value\r\n  this.valueMatcher = new PatternMatcher(this.value)\r\n  this.findOption = function(element) {\r\n    for (let i = 0; i < element.options.length; i++) {\r\n      if (this.valueMatcher.matches(element.options[i].value)) {\r\n        return element.options[i]\r\n      }\r\n    }\r\n    throw new SeleniumError(\"Option with value '\" + this.value + \"' not found\")\r\n  }\r\n\r\n  this.assertSelected = function(element) {\r\n    let selectedValue = element.options[element.selectedIndex].value\r\n    Assert.matches(this.value, selectedValue) // eslint-disable-line no-undef\r\n  }\r\n}\r\n\r\n/**\r\n *  OptionLocator for options identified by their index.\r\n */\r\nOptionLocatorFactory.prototype.OptionLocatorByIndex = function(index) {\r\n  this.index = Number(index)\r\n  if (isNaN(this.index) || this.index < 0) {\r\n    throw new SeleniumError('Illegal Index: ' + index)\r\n  }\r\n\r\n  this.findOption = function(element) {\r\n    if (element.options.length <= this.index) {\r\n      throw new SeleniumError(\r\n        'Index out of range.  Only ' +\r\n          element.options.length +\r\n          ' options available'\r\n      )\r\n    }\r\n    return element.options[this.index]\r\n  }\r\n\r\n  this.assertSelected = function(element) {\r\n    Assert.equals(this.index, element.selectedIndex) // eslint-disable-line no-undef\r\n  }\r\n}\r\n\r\n/**\r\n *  OptionLocator for options identified by their id.\r\n */\r\nOptionLocatorFactory.prototype.OptionLocatorById = function(id) {\r\n  this.id = id\r\n  this.idMatcher = new PatternMatcher(this.id)\r\n  this.findOption = function(element) {\r\n    for (let i = 0; i < element.options.length; i++) {\r\n      if (this.idMatcher.matches(element.options[i].id)) {\r\n        return element.options[i]\r\n      }\r\n    }\r\n    throw new SeleniumError(\"Option with id '\" + this.id + \"' not found\")\r\n  }\r\n\r\n  this.assertSelected = function(element) {\r\n    let selectedId = element.options[element.selectedIndex].id\r\n    Assert.matches(this.id, selectedId) // eslint-disable-line no-undef\r\n  }\r\n}\r\n\r\n//EditContentExt, Lin Yun Wen, SELAB, CSIE, NCKU, 2016/11/17\r\nSelenium.prototype.doEditContent = function(locator, value) {\r\n  /**\r\n   *to set text in the element which's conentEditable attribute is true\r\n   *@param locator an element locator\r\n   *@param value the context of the element in html\r\n   */\r\n  let element = this.browserbot.findElement(locator)\r\n  let editable = element.contentEditable\r\n\r\n  if (editable == 'true') {\r\n    element.innerHTML = escapeHTML(value)\r\n  } else {\r\n    throw new SeleniumError(\r\n      'The value of contentEditable attribute of this element is not true.'\r\n    )\r\n  }\r\n}\r\n\r\n// Modified prompt by SideeX comitters (Copyright 2017)\r\nSelenium.prototype.doChooseCancelOnNextPrompt = function() {\r\n  return this.browserbot.cancelNextPrompt()\r\n}\r\n\r\nSelenium.prototype.doAnswerOnNextPrompt = function(answer) {\r\n  return this.browserbot.setNextPromptResult(answer)\r\n}\r\n\r\nSelenium.prototype.doAssertPrompt = function(message) {\r\n  return this.browserbot.getPromptMessage().then(function(actualMessage) {\r\n    if (message != actualMessage)\r\n      return Promise.reject(\"Prompt message doesn't match actual message\")\r\n    else return Promise.resolve(true)\r\n  })\r\n}\r\n\r\n// Modified alert by SideeX comitters (Copyright 2017)\r\nSelenium.prototype.doAssertAlert = function(message) {\r\n  return this.browserbot.getAlertMessage().then(function(actualMessage) {\r\n    if (message != actualMessage)\r\n      return Promise.reject(\"Alert message doesn't match actual message\")\r\n    else return Promise.resolve(true)\r\n  })\r\n}\r\n\r\n// Modified confirm by SideeX comitters (Copyright 2017)\r\nSelenium.prototype.doChooseCancelOnNextConfirmation = function() {\r\n  return this.browserbot.setNextConfirmationResult(false)\r\n}\r\n\r\nSelenium.prototype.doChooseOkOnNextConfirmation = function() {\r\n  return this.browserbot.setNextConfirmationResult(true)\r\n}\r\n\r\nSelenium.prototype.doAssertConfirmation = function(value) {\r\n  return this.browserbot.getConfirmationMessage().then(function(actualMessage) {\r\n    if (value != actualMessage)\r\n      return Promise.reject(\"Confirmation message doesn't match actual message\")\r\n    else return Promise.resolve(true)\r\n  })\r\n}\r\n\r\nSelenium.prototype.doShowElement = function(locator) {\r\n  const elementForInjectingStyle = document.createElement('link')\r\n  elementForInjectingStyle.rel = 'stylesheet'\r\n  elementForInjectingStyle.href = browser.runtime.getURL(\r\n    '/assets/highlight.css'\r\n  )\r\n  ;(document.head || document.documentElement).appendChild(\r\n    elementForInjectingStyle\r\n  )\r\n  const highlightElement = document.createElement('div')\r\n  highlightElement.id = 'selenium-highlight'\r\n  document.body.appendChild(highlightElement)\r\n  if (locator.x) {\r\n    highlightElement.style.left = parseInt(locator.x) + 'px'\r\n    highlightElement.style.top = parseInt(locator.y) + 'px'\r\n    highlightElement.style.width = parseInt(locator.width) + 'px'\r\n    highlightElement.style.height = parseInt(locator.height) + 'px'\r\n  } else {\r\n    const bodyRects = document.documentElement.getBoundingClientRect()\r\n    const element = this.browserbot.findElement(locator)\r\n    const elementRects = element.getBoundingClientRect()\r\n    highlightElement.style.left =\r\n      parseInt(elementRects.left - bodyRects.left) + 'px'\r\n    highlightElement.style.top =\r\n      parseInt(elementRects.top - bodyRects.top) + 'px'\r\n    highlightElement.style.width = parseInt(elementRects.width) + 'px'\r\n    highlightElement.style.height = parseInt(elementRects.height) + 'px'\r\n  }\r\n  highlightElement.style.position = 'absolute'\r\n  highlightElement.style.zIndex = '100'\r\n  highlightElement.style.display = 'block'\r\n  highlightElement.style.pointerEvents = 'none'\r\n  scrollIntoViewIfNeeded(highlightElement, { centerIfNeeded: true })\r\n  highlightElement.className = 'active-selenium-highlight'\r\n  setTimeout(() => {\r\n    document.body.removeChild(highlightElement)\r\n    elementForInjectingStyle.parentNode.removeChild(elementForInjectingStyle)\r\n  }, 500)\r\n  return 'element found'\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/selenium-api.js","/*\r\n * Copyright 2011 Software Freedom Conservancy\r\n *\r\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n *  you may not use this file except in compliance with the License.\r\n *  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\n\r\n/*\r\n * This script provides the Javascript API to drive the test application contained within\r\n * a Browser Window.\r\n * TODO:\r\n *    Add support for more events (keyboard and mouse)\r\n *    Allow to switch \"user-entry\" mode from mouse-based to keyboard-based, firing different\r\n *          events in different modes.\r\n */\r\n\r\nimport _Selenium from './selenium-api'\r\nimport SeleniumError from './SeleniumError'\r\nimport { selenium } from './commands-api'\r\nimport goog, { bot, core } from './closure-polyfill'\r\nimport { getTagName, parse_locator } from './utils'\r\nimport PatternMatcher from './PatternMatcher'\r\n\r\nexport const browserVersion = new window.global.BrowserVersion()\r\nwindow.global.browserVersion = browserVersion\r\n\r\n// The window to which the commands will be sent.  For example, to click on a\r\n// popup window, first select that window, and then do a normal click command.\r\nexport default class BrowserBot {\r\n  constructor(topLevelApplicationWindow) {\r\n    this.topWindow = topLevelApplicationWindow\r\n    this.topFrame = this.topWindow\r\n    this.baseUrl = window.location.href\r\n    bot.setWindow(window)\r\n\r\n    //UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/05/26\r\n    this.count = 1\r\n\r\n    // the buttonWindow is the Selenium window\r\n    // it contains the Run/Pause buttons... this should *not* be the AUT window\r\n    this.buttonWindow = window\r\n    this.currentWindow = this.topWindow\r\n    this.currentWindowName = null\r\n    this.allowNativeXpath = true\r\n    this.xpathEvaluator = new XPathEvaluator('ajaxslt') // change to \"javascript-xpath\" for the newer, faster engine\r\n\r\n    // We need to know this in advance, in case the frame closes unexpectedly\r\n    this.isSubFrameSelected = false\r\n\r\n    this.altKeyDown = false\r\n    this.controlKeyDown = false\r\n    this.shiftKeyDown = false\r\n    this.metaKeyDown = false\r\n\r\n    this.modalDialogTest = null\r\n    this.recordedAlerts = new Array()\r\n    this.recordedConfirmations = new Array()\r\n    this.recordedPrompts = new Array()\r\n    this.openedWindows = {}\r\n    //UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/05/26\r\n    this.openedWindows['win_ser_local'] = this.topWindow\r\n\r\n    this.nextConfirmResult = true\r\n    this.nextPromptResult = ''\r\n    this.newPageLoaded = false\r\n    this.pageLoadError = null\r\n\r\n    this.ignoreResponseCode = false\r\n    this.xhr = null\r\n    this.abortXhr = false\r\n    this.isXhrSent = false\r\n    this.isXhrDone = false\r\n    this.xhrOpenLocation = null\r\n    this.xhrResponseCode = null\r\n    this.xhrStatusText = null\r\n\r\n    this.shouldHighlightLocatedElement = false\r\n\r\n    this.uniqueId = 'seleniumMarker' + new Date().getTime()\r\n    this.pollingForLoad = new Object()\r\n    this.permDeniedCount = new Object()\r\n    this.windowPollers = new Array()\r\n    // DGF for backwards compatibility\r\n    this.browserbot = this\r\n\r\n    let self = this\r\n\r\n    Object.assign(this, PageBot.prototype)\r\n    this._registerAllLocatorFunctions()\r\n\r\n    this.recordPageLoad = function() {\r\n      self.newPageLoaded = true\r\n    }\r\n\r\n    this.isNewPageLoaded = function() {\r\n      let e\r\n\r\n      if (this.pageLoadError) {\r\n        e = this.pageLoadError\r\n        this.pageLoadError = null\r\n        throw e\r\n      }\r\n\r\n      if (self.ignoreResponseCode) {\r\n        return self.newPageLoaded\r\n      } else {\r\n        if (self.isXhrSent && self.isXhrDone) {\r\n          if (\r\n            !(\r\n              (self.xhrResponseCode >= 200 && self.xhrResponseCode <= 399) ||\r\n              self.xhrResponseCode == 0\r\n            )\r\n          ) {\r\n            // TODO: for IE status like: 12002, 12007, ... provide corresponding statusText messages also.\r\n            e =\r\n              'XHR ERROR: URL = ' +\r\n              self.xhrOpenLocation +\r\n              ' Response_Code = ' +\r\n              self.xhrResponseCode +\r\n              ' Error_Message = ' +\r\n              self.xhrStatusText\r\n            self.abortXhr = false\r\n            self.isXhrSent = false\r\n            self.isXhrDone = false\r\n            self.xhrResponseCode = null\r\n            self.xhrStatusText = null\r\n            throw new SeleniumError(e)\r\n          }\r\n        }\r\n        return (\r\n          self.newPageLoaded &&\r\n          (self.isXhrSent ? self.abortXhr || self.isXhrDone : true)\r\n        )\r\n      }\r\n    }\r\n\r\n    this.setAllowNativeXPath = function(allow) {\r\n      this.xpathEvaluator.setAllowNativeXPath(allow)\r\n    }\r\n\r\n    this.setIgnoreAttributesWithoutValue = function(ignore) {\r\n      this.xpathEvaluator.setIgnoreAttributesWithoutValue(ignore)\r\n    }\r\n\r\n    this.setXPathEngine = function(engineName) {\r\n      this.xpathEvaluator.setCurrentEngine(engineName)\r\n    }\r\n\r\n    this.getXPathEngine = function() {\r\n      return this.xpathEvaluator.getCurrentEngine()\r\n    }\r\n  }\r\n}\r\n\r\n// DGF PageBot exists for backwards compatibility with old user-extensions\r\nconst PageBot = function() {}\r\n\r\nBrowserBot.createForWindow = function(window, proxyInjectionMode) {\r\n  let browserbot\r\n  if (browserVersion.isIE) {\r\n    browserbot = new IEBrowserBot(window)\r\n  } else if (browserVersion.isKonqueror) {\r\n    browserbot = new KonquerorBrowserBot(window)\r\n  } else if (browserVersion.isOpera) {\r\n    browserbot = new OperaBrowserBot(window)\r\n  } else if (browserVersion.isSafari) {\r\n    browserbot = new SafariBrowserBot(window)\r\n  } else {\r\n    // Use mozilla by default\r\n    browserbot = new MozillaBrowserBot(window)\r\n  }\r\n  // getCurrentWindow has the side effect of modifying it to handle page loads etc\r\n  browserbot.proxyInjectionMode = proxyInjectionMode\r\n  browserbot.getCurrentWindow() // for modifyWindow side effect.  This is not a transparent style\r\n  return browserbot\r\n}\r\n\r\n// todo: rename?  This doesn't actually \"do\" anything.\r\nBrowserBot.prototype.doModalDialogTest = function(test) {\r\n  this.modalDialogTest = test\r\n}\r\n\r\nBrowserBot.prototype.cancelNextConfirmation = function(result) {\r\n  this.nextConfirmResult = result\r\n}\r\n\r\n//BrowserBot.prototype.setNextPromptResult = function(result) {\r\n//this.nextResult = result;\r\n//};\r\n\r\nBrowserBot.prototype.hasAlerts = function() {\r\n  return this.recordedAlerts.length > 0\r\n}\r\n\r\nBrowserBot.prototype.relayBotToRC = function(s) {\r\n  // DGF need to do this funny trick to see if we're in PI mode, because\r\n  // \"this\" might be the window, rather than the browserbot (e.g. during window.alert)\r\n  let piMode = this.proxyInjectionMode\r\n  if (!piMode) {\r\n    if (typeof selenium != 'undefined') {\r\n      piMode = selenium.browserbot && selenium.browserbot.proxyInjectionMode\r\n    }\r\n  }\r\n  if (piMode) {\r\n    this.relayToRC('selenium.' + s)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.relayToRC = function() {\r\n  return null\r\n}\r\n\r\nBrowserBot.prototype.resetPopups = function() {\r\n  this.recordedAlerts = []\r\n  this.recordedConfirmations = []\r\n  this.recordedPrompts = []\r\n}\r\n\r\nBrowserBot.prototype.getNextAlert = function() {\r\n  let t = this.recordedAlerts.shift()\r\n  if (t) {\r\n    t = t.replace(/\\n/g, ' ') // because Selenese loses \\n's when retrieving text from HTML table\r\n  }\r\n  this.relayBotToRC('browserbot.recordedAlerts')\r\n  return t\r\n}\r\n\r\nBrowserBot.prototype.hasConfirmations = function() {\r\n  return this.recordedConfirmations.length > 0\r\n}\r\n\r\nBrowserBot.prototype.getNextConfirmation = function() {\r\n  let t = this.recordedConfirmations.shift()\r\n  this.relayBotToRC('browserbot.recordedConfirmations')\r\n  return t\r\n}\r\n\r\nBrowserBot.prototype.hasPrompts = function() {\r\n  return this.recordedPrompts.length > 0\r\n}\r\n\r\nBrowserBot.prototype.getNextPrompt = function() {\r\n  let t = this.recordedPrompts.shift()\r\n  this.relayBotToRC('browserbot.recordedPrompts')\r\n  return t\r\n}\r\n\r\n/* Fire a mouse event in a browser-compatible manner */\r\n\r\nBrowserBot.prototype.triggerMouseEvent = function(\r\n  element,\r\n  eventType,\r\n  canBubble,\r\n  clientX,\r\n  clientY,\r\n  button\r\n) {\r\n  clientX = clientX ? clientX : 0\r\n  clientY = clientY ? clientY : 0\r\n\r\n  //LOG.debug(\"triggerMouseEvent assumes setting screenX and screenY to 0 is ok\");\r\n  let screenX = 0\r\n  let screenY = 0\r\n\r\n  canBubble = typeof canBubble == undefined ? true : canBubble\r\n  let doc = goog.dom.getOwnerDocument(element)\r\n  let view = goog.dom.getWindow(doc)\r\n\r\n  let evt = doc.createEvent('MouseEvents')\r\n  if (evt.initMouseEvent) {\r\n    // see http://developer.mozilla.org/en/docs/DOM:event.button and\r\n    // http://developer.mozilla.org/en/docs/DOM:event.initMouseEvent for button ternary logic logic\r\n    //Safari\r\n    evt.initMouseEvent(\r\n      eventType,\r\n      canBubble,\r\n      true,\r\n      view,\r\n      1,\r\n      screenX,\r\n      screenY,\r\n      clientX,\r\n      clientY,\r\n      this.controlKeyDown,\r\n      this.altKeyDown,\r\n      this.shiftKeyDown,\r\n      this.metaKeyDown,\r\n      button ? button : 0,\r\n      null\r\n    )\r\n  } else {\r\n    //LOG.warn(\"element doesn't have initMouseEvent; firing an event which should -- but doesn't -- have other mouse-event related attributes here, as well as controlKeyDown, altKeyDown, shiftKeyDown, metaKeyDown\");\r\n    evt.initEvent(eventType, canBubble, true)\r\n\r\n    evt.shiftKey = this.shiftKeyDown\r\n    evt.metaKey = this.metaKeyDown\r\n    evt.altKey = this.altKeyDown\r\n    evt.ctrlKey = this.controlKeyDown\r\n    if (button) {\r\n      evt.button = button\r\n    }\r\n  }\r\n  element.dispatchEvent(evt)\r\n}\r\n\r\n//DragAndDropExt, Shuo-Heng Shih, SELAB, CSIE, NCKU, 2016/10/17\r\nBrowserBot.prototype.triggerDragEvent = function(element, target) {\r\n  const getXpathOfElement = function(element) {\r\n    if (element == null) {\r\n      return 'null'\r\n    }\r\n    if (element.parentElement == null) {\r\n      return '/' + element.tagName\r\n    }\r\n\r\n    let siblingElement = element.parentElement.children\r\n    let tagCount = 0\r\n    let totalTagCount = 0\r\n    let isFound = false\r\n\r\n    for (let i = 0; i < siblingElement.length; i++) {\r\n      if (siblingElement[i].tagName == element.tagName && !isFound) {\r\n        tagCount++\r\n        totalTagCount++\r\n      } else if (siblingElement[i].tagName == element.tagName) {\r\n        totalTagCount++\r\n      }\r\n      if (siblingElement[i] == element) {\r\n        isFound = true\r\n      }\r\n    }\r\n\r\n    if (totalTagCount > 1) {\r\n      return (\r\n        getXpathOfElement(element.parentElement) +\r\n        '/' +\r\n        element.tagName +\r\n        '[' +\r\n        tagCount +\r\n        ']'\r\n      )\r\n    }\r\n\r\n    return getXpathOfElement(element.parentElement) + '/' + element.tagName\r\n  }\r\n  let script =\r\n    \"                                              \\\r\n        function simulateDragDrop(sourceNode, destinationNode){\\\r\n        function createCustomEvent(type) {                     \\\r\n            var event = new CustomEvent('CustomEvent');        \\\r\n            event.initCustomEvent(type, true, true, null);     \\\r\n            event.dataTransfer = {                             \\\r\n                data: {                                        \\\r\n                },                                             \\\r\n                setData: function(type, val) {                 \\\r\n                    this.data[type] = val;                     \\\r\n                },                                             \\\r\n                getData: function(type) {                      \\\r\n                    return this.data[type];                    \\\r\n                }                                              \\\r\n            };                                                 \\\r\n            return event;                                      \\\r\n        }                                                      \\\r\n        function dispatchEvent(node, type, event) {            \\\r\n            if (node.dispatchEvent) {                          \\\r\n                return node.dispatchEvent(event);              \\\r\n            }                                                  \\\r\n            if (node.fireEvent) {                              \\\r\n                return node.fireEvent('on' + type, event);     \\\r\n            }                                                  \\\r\n        }                                                      \\\r\n        var event = createCustomEvent('dragstart');            \\\r\n        dispatchEvent(sourceNode, 'dragstart', event);         \\\r\n                                                               \\\r\n        var dropEvent = createCustomEvent('drop');             \\\r\n        dropEvent.dataTransfer = event.dataTransfer;           \\\r\n        dispatchEvent(destinationNode, 'drop', dropEvent);     \\\r\n                                                               \\\r\n        var dragEndEvent = createCustomEvent('dragend');       \\\r\n        dragEndEvent.dataTransfer = event.dataTransfer;        \\\r\n        dispatchEvent(sourceNode, 'dragend', dragEndEvent);    \\\r\n    }                                                          \\\r\n    simulateDragDrop(document.evaluate('\" +\r\n    getXpathOfElement(element) +\r\n    \"', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue, document.evaluate('\" +\r\n    getXpathOfElement(target) +\r\n    \"', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue);\\\r\n    \"\r\n  let win = this.browserbot.getCurrentWindow()\r\n  let doc = win.document\r\n  let scriptTag = doc.createElement('script')\r\n  scriptTag.type = 'text/javascript'\r\n  scriptTag.text = script\r\n  doc.body.appendChild(scriptTag)\r\n}\r\n\r\nBrowserBot.prototype._windowClosed = function(win) {\r\n  try {\r\n    let c = win.closed\r\n    if (c == null) return true\r\n    return c\r\n  } catch (ignored) {\r\n    // Firefox 15+ may already have marked the win dead. Accessing it\r\n    // causes an exception to be thrown. That exception tells us the window\r\n    // is closed.\r\n    return true\r\n  }\r\n}\r\n\r\nBrowserBot.uniqueKey = 1\r\n\r\nBrowserBot.prototype._modifyWindow = function(win) {\r\n  // In proxyInjectionMode, have to suppress //LOG calls in _modifyWindow to avoid an infinite loop\r\n  if (this._windowClosed(win)) {\r\n    if (!this.proxyInjectionMode) {\r\n      //LOG.error(\"modifyWindow: Window was closed!\");\r\n    }\r\n    return null\r\n  }\r\n  if (!this.proxyInjectionMode) {\r\n    //LOG.debug('modifyWindow ' + this.uniqueId + \":\" + win[this.uniqueId]);\r\n  }\r\n\r\n  // Assign a unique label for this window. We set this on a known attribute so we can reliably\r\n  // find it later. This is slightly different from uniqueId.\r\n  win.seleniumKey = BrowserBot.uniqueKey++\r\n\r\n  try {\r\n    this.modifyWindowToRecordPopUpDialogs(win, this)\r\n  } catch (ex) {\r\n    console.error(ex) // eslint-disable-line no-console\r\n  }\r\n\r\n  //Commenting out for issue 1854\r\n  //win[this.uniqueId] = 1;\r\n\r\n  // In proxyInjection mode, we have our own mechanism for detecting page loads\r\n  if (!this.proxyInjectionMode) {\r\n    this.modifySeparateTestWindowToDetectPageLoads(win)\r\n  }\r\n  if (win.frames && win.frames.length && win.frames.length > 0) {\r\n    for (let i = 0; i < win.frames.length; i++) {\r\n      try {\r\n        this._modifyWindow(win.frames[i])\r\n      } catch (e) {} // eslint-disable-line no-empty\r\n      // we're just trying to be opportunistic; don't worry if this doesn't work out\r\n    }\r\n  }\r\n  return win\r\n}\r\n\r\nBrowserBot.prototype.selectWindow = function(target) {\r\n  if (!target || target == 'null') {\r\n    this._selectTopWindow()\r\n    return\r\n  }\r\n  let result = target.match(/^([a-zA-Z]+)=(.*)/)\r\n  if (!result) {\r\n    this._selectWindowByWindowId(target)\r\n    return\r\n  }\r\n  let locatorType = result[1]\r\n  let locatorValue = result[2]\r\n  if (locatorType == 'title') {\r\n    this._selectWindowByTitle(locatorValue)\r\n  }\r\n  // TODO separate name and var into separate functions\r\n  else if (locatorType == 'name') {\r\n    this._selectWindowByName(locatorValue)\r\n  } else if (locatorType == 'var') {\r\n    let win = this.getCurrentWindow().eval(locatorValue)\r\n    if (win) {\r\n      this._selectWindowByName(win.name)\r\n    } else {\r\n      throw new SeleniumError('Window not found by var: ' + locatorValue)\r\n    }\r\n  } else {\r\n    throw new SeleniumError('Window locator not recognized: ' + locatorType)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.selectPopUp = function(windowId) {\r\n  if (!windowId || windowId == 'null') {\r\n    this._selectFirstNonTopWindow()\r\n  } else {\r\n    this._selectWindowByWindowId(windowId)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._selectTopWindow = function() {\r\n  this.currentWindowName = null\r\n  this.currentWindow = this.topWindow\r\n  this.topFrame = this.topWindow\r\n  this.isSubFrameSelected = false\r\n}\r\n\r\nBrowserBot.prototype._selectWindowByWindowId = function(windowId) {\r\n  try {\r\n    this._selectWindowByName(windowId)\r\n  } catch (e) {\r\n    this._selectWindowByTitle(windowId)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._selectWindowByName = function(target) {\r\n  this.currentWindow = this.getWindowByName(target, false)\r\n  this.topFrame = this.currentWindow\r\n  this.currentWindowName = target\r\n  this.isSubFrameSelected = false\r\n}\r\n\r\nBrowserBot.prototype._selectWindowByTitle = function(target) {\r\n  let windowName = this.getWindowNameByTitle(target)\r\n  if (!windowName) {\r\n    this._selectTopWindow()\r\n  } else {\r\n    this._selectWindowByName(windowName)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._selectFirstNonTopWindow = function() {\r\n  let names = this.getNonTopWindowNames()\r\n  if (names.length) {\r\n    this._selectWindowByName(names[0])\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.selectFrame = function(target) {\r\n  let frame\r\n\r\n  if (target.indexOf('index=') == 0) {\r\n    target = target.substr(6)\r\n    frame = this.getCurrentWindow().frames[target]\r\n    if (frame == null) {\r\n      throw new SeleniumError('Not found: frames[' + target + ']')\r\n    }\r\n    if (!frame.document) {\r\n      throw new SeleniumError('frames[' + target + '] is not a frame')\r\n    }\r\n    this.currentWindow = frame\r\n    this.isSubFrameSelected = true\r\n  } else if (target == 'relative=up' || target == 'relative=parent') {\r\n    this.currentWindow = this.getCurrentWindow().parent\r\n    this.isSubFrameSelected = this._getFrameElement(this.currentWindow) != null\r\n  } else if (target == 'relative=top') {\r\n    this.currentWindow = this.topFrame\r\n    this.isSubFrameSelected = false\r\n  } else {\r\n    frame = this.findElement(target)\r\n    if (frame == null) {\r\n      throw new SeleniumError('Not found: ' + target)\r\n    }\r\n    // now, did they give us a frame or a frame ELEMENT?\r\n    let match = false\r\n    if (frame.contentWindow) {\r\n      // this must be a frame element\r\n      if (browserVersion.isHTA) {\r\n        // stupid HTA bug; can't get in the front door\r\n        target = frame.contentWindow.name\r\n      } else {\r\n        this.currentWindow = frame.contentWindow\r\n        this.isSubFrameSelected = true\r\n        match = true\r\n      }\r\n    } else if (frame.document && frame.location) {\r\n      // must be an actual window frame\r\n      this.currentWindow = frame\r\n      this.isSubFrameSelected = true\r\n      match = true\r\n    }\r\n\r\n    if (!match) {\r\n      // neither, let's loop through the frame names\r\n      let win = this.getCurrentWindow()\r\n\r\n      if (win && win.frames && win.frames.length) {\r\n        for (let i = 0; i < win.frames.length; i++) {\r\n          if (win.frames[i].name == target) {\r\n            this.currentWindow = win.frames[i]\r\n            this.isSubFrameSelected = true\r\n            match = true\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if (!match) {\r\n        throw new SeleniumError('Not a frame: ' + target)\r\n      }\r\n    }\r\n  }\r\n  // modifies the window\r\n  this.getCurrentWindow()\r\n}\r\n\r\nBrowserBot.prototype.doesThisFrameMatchFrameExpression = function(\r\n  currentFrameString,\r\n  target\r\n) {\r\n  let isDom = false\r\n  if (target.indexOf('dom=') == 0) {\r\n    target = target.substr(4)\r\n    isDom = true\r\n  } else if (target.indexOf('index=') == 0) {\r\n    target = 'frames[' + target.substr(6) + ']'\r\n    isDom = true\r\n  }\r\n  let t\r\n  //Evalinsandbox\r\n  // eslint-disable-next-line no-undef\r\n  let mySandbox = new Components.utils.Sandbox(this.currentWindow.location.href)\r\n  mySandbox.currentFrameString = currentFrameString\r\n  mySandbox.target = target\r\n  try {\r\n    // eslint-disable-next-line no-undef\r\n    t = Components.utils.evalInSandbox(\r\n      currentFrameString + '.' + target,\r\n      mySandbox\r\n    )\r\n    //eval(\"t=\" + currentFrameString + \".\" + target);\r\n  } catch (e) {} // eslint-disable-line no-empty\r\n  let autWindow = this.browserbot.getCurrentWindow()\r\n  if (t != null) {\r\n    try {\r\n      if (t.window == autWindow) {\r\n        return true\r\n      }\r\n      if (t.window.uniqueId == autWindow.uniqueId) {\r\n        return true\r\n      }\r\n      return false\r\n    } catch (permDenied) {\r\n      // DGF if the windows are incomparable, they're probably not the same...\r\n    }\r\n  }\r\n  if (isDom) {\r\n    return false\r\n  }\r\n  // eslint-disable-next-line no-undef\r\n  let currentFrame = Components.utils.evalInSandbox(\r\n    currentFrameString,\r\n    mySandbox\r\n  )\r\n  //var currentFrame;\r\n  //eval(\"currentFrame=\" + currentFrameString);\r\n  if (target == 'relative=up') {\r\n    if (currentFrame.window.parent == autWindow) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n  if (target == 'relative=top') {\r\n    if (currentFrame.window.top == autWindow) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n  if (currentFrame.window == autWindow.parent) {\r\n    if (autWindow.name == target) {\r\n      return true\r\n    }\r\n    try {\r\n      let element = this.findElement(target, currentFrame.window)\r\n      if (element.contentWindow == autWindow) {\r\n        return true\r\n      }\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n  }\r\n  return false\r\n}\r\n\r\nBrowserBot.prototype.abortXhrRequest = function() {\r\n  if (this.ignoreResponseCode) {\r\n    //LOG.debug(\"XHR response code being ignored. Nothing to abort.\");\r\n  } else {\r\n    if (this.abortXhr == false && this.isXhrSent && !this.isXhrDone) {\r\n      //LOG.info(\"abortXhrRequest(): aborting request\");\r\n      this.abortXhr = true\r\n      this.xhr.abort()\r\n    }\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.onXhrStateChange = function(method) {\r\n  //LOG.info(\"onXhrStateChange(): xhr.readyState = \" + this.xhr.readyState + \" method = \" + method + \" time = \" + new Date().getTime());\r\n  if (this.xhr.readyState == 4) {\r\n    // check if the request got aborted.\r\n    if (this.abortXhr == true) {\r\n      this.xhrResponseCode = 0\r\n      this.xhrStatusText = 'Request Aborted'\r\n      this.isXhrDone = true\r\n      return\r\n    }\r\n\r\n    try {\r\n      if (\r\n        method == 'HEAD' &&\r\n        (this.xhr.status == 501 || this.xhr.status == 405)\r\n      ) {\r\n        //LOG.info(\"onXhrStateChange(): HEAD ajax returned 501 or 405, retrying with GET\");\r\n        // handle 501 response code from servers that do not support 'HEAD' method.\r\n        // send GET ajax request with range 0-1.\r\n        this.xhr = new XMLHttpRequest()\r\n        this.xhr.onreadystatechange = this.onXhrStateChange.bind(this, 'GET')\r\n        this.xhr.open('GET', this.xhrOpenLocation, true)\r\n        this.xhr.setRequestHeader('Range', 'bytes:0-1')\r\n        this.xhr.send('')\r\n        this.isXhrSent = true\r\n        return\r\n      }\r\n      this.xhrResponseCode = this.xhr.status\r\n      this.xhrStatusText = this.xhr.statusText\r\n    } catch (ex) {\r\n      //LOG.info(\"encountered exception while reading xhrResponseCode.\" + ex.message);\r\n      this.xhrResponseCode = -1\r\n      this.xhrStatusText = 'Request Error'\r\n    }\r\n\r\n    this.isXhrDone = true\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.openWindow = function(url, windowID) {\r\n  if (url != '') {\r\n    url = 'https://www.google.com'\r\n  }\r\n  if (browserVersion.isHTA) {\r\n    // in HTA mode, calling .open on the window interprets the url relative to that window\r\n    // we need to absolute-ize the URL to make it consistent\r\n    let child = this.getCurrentWindow().open(url, windowID, 'resizable=yes')\r\n    selenium.browserbot.openedWindows[windowID] = child\r\n  } else {\r\n    this.getCurrentWindow().open(url, windowID, 'resizable=yes')\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.setIFrameLocation = function(iframe, location) {\r\n  iframe.src = location\r\n}\r\n\r\nBrowserBot.prototype.getCurrentPage = function() {\r\n  return this\r\n}\r\n\r\nBrowserBot.prototype.windowNeedsModifying = function(win, uniqueId) {\r\n  // On anything but Firefox, checking the unique id is enough.\r\n  // Firefox 4 introduces a race condition which selenium regularly loses.\r\n\r\n  try {\r\n    // eslint-disable-next-line no-undef\r\n    let appInfo = Components.classes['@mozilla.org/xre/app-info;1'].getService(\r\n      // eslint-disable-next-line no-undef\r\n      Components.interfaces.nsIXULAppInfo\r\n    )\r\n    // eslint-disable-next-line no-undef\r\n    let versionChecker = Components.classes[\r\n      '@mozilla.org/xpcom/version-comparator;1'\r\n      // eslint-disable-next-line no-undef\r\n    ].getService(Components.interfaces.nsIVersionComparator)\r\n\r\n    if (versionChecker.compare(appInfo.version, '4.0b1') >= 0) {\r\n      return win.alert.toString().indexOf('native code') != -1\r\n    }\r\n  } catch (ignored) {} // eslint-disable-line no-empty\r\n  return !win[uniqueId]\r\n}\r\n\r\nBrowserBot.prototype.modifyWindowToRecordPopUpDialogs = function(\r\n  originalWindow,\r\n  browserBot\r\n) {\r\n  let self = this\r\n\r\n  // Apparently, Firefox 4 makes it possible to unwrap an object to find that\r\n  // there's nothing in it.\r\n  let windowToModify = core.firefox.unwrap(originalWindow)\r\n  if (!windowToModify) {\r\n    windowToModify = originalWindow\r\n  }\r\n\r\n  windowToModify.seleniumAlert = windowToModify.alert\r\n\r\n  if (!self.windowNeedsModifying(windowToModify, browserBot.uniqueId)) {\r\n    return\r\n  }\r\n\r\n  windowToModify.alert = function(alert) {\r\n    browserBot.recordedAlerts.push(alert)\r\n    self.relayBotToRC.call(self, 'browserbot.recordedAlerts')\r\n  }\r\n\r\n  windowToModify.confirm = function(message) {\r\n    browserBot.recordedConfirmations.push(message)\r\n    let result = browserBot.nextConfirmResult\r\n    browserBot.nextConfirmResult = true\r\n    self.relayBotToRC.call(self, 'browserbot.recordedConfirmations')\r\n    return result\r\n  }\r\n\r\n  windowToModify.prompt = function(message) {\r\n    browserBot.recordedPrompts.push(message)\r\n    let result = !browserBot.nextConfirmResult\r\n      ? null\r\n      : browserBot.nextPromptResult\r\n    browserBot.nextConfirmResult = true\r\n    browserBot.nextPromptResult = ''\r\n    self.relayBotToRC.call(self, 'browserbot.recordedPrompts')\r\n    return result\r\n  }\r\n\r\n  // Keep a reference to all popup windows by name\r\n  // note that in IE the \"windowName\" argument must be a valid javascript identifier, it seems.\r\n  let originalOpen = windowToModify.open\r\n  let originalOpenReference\r\n  if (browserVersion.isHTA) {\r\n    originalOpenReference = 'selenium_originalOpen' + new Date().getTime()\r\n    windowToModify[originalOpenReference] = windowToModify.open\r\n  }\r\n\r\n  let isHTA = browserVersion.isHTA\r\n\r\n  let newOpen = function(url, windowName, windowFeatures, replaceFlag) {\r\n    let myOriginalOpen = originalOpen\r\n    if (isHTA) {\r\n      myOriginalOpen = this[originalOpenReference]\r\n    }\r\n\r\n    //UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/05/26\r\n    if (\r\n      windowName == '' ||\r\n      windowName == '_blank' ||\r\n      typeof windowName === 'undefined'\r\n    ) {\r\n      windowName = 'win_ser_' + self.count\r\n      self.count += 1\r\n    }\r\n\r\n    let openedWindow = myOriginalOpen(\r\n      url,\r\n      windowName,\r\n      windowFeatures,\r\n      replaceFlag\r\n    )\r\n    //LOG.debug(\"window.open call intercepted; window ID (which you can use with selectWindow()) is \\\"\" +  windowName + \"\\\"\");\r\n    if (windowName != null) {\r\n      openedWindow['seleniumWindowName'] = windowName\r\n    }\r\n    selenium.browserbot.openedWindows[windowName] = openedWindow\r\n    return openedWindow\r\n  }\r\n\r\n  if (browserVersion.isHTA) {\r\n    originalOpenReference = 'selenium_originalOpen' + new Date().getTime()\r\n    const newOpenReference = 'selenium_newOpen' + new Date().getTime()\r\n    let setOriginalRef = \"this['\" + originalOpenReference + \"'] = this.open;\"\r\n\r\n    if (windowToModify.eval) {\r\n      windowToModify.eval(setOriginalRef)\r\n      windowToModify.open = newOpen\r\n    } else {\r\n      // DGF why can't I eval here?  Seems like I'm querying the window at a bad time, maybe?\r\n      setOriginalRef += \"this.open = this['\" + newOpenReference + \"'];\"\r\n      windowToModify[newOpenReference] = newOpen\r\n      windowToModify.setTimeout(setOriginalRef, 0)\r\n    }\r\n  } else {\r\n    windowToModify.open = newOpen\r\n  }\r\n}\r\n\r\n/**\r\n * Call the supplied function when a the current page unloads and a new one loads.\r\n * This is done by polling continuously until the document changes and is fully loaded.\r\n */\r\nBrowserBot.prototype.modifySeparateTestWindowToDetectPageLoads = function(\r\n  windowObject\r\n) {\r\n  // Since the unload event doesn't fire in Safari 1.3, we start polling immediately\r\n  if (!windowObject) {\r\n    //LOG.warn(\"modifySeparateTestWindowToDetectPageLoads: no windowObject!\");\r\n    return\r\n  }\r\n  if (this._windowClosed(windowObject)) {\r\n    //LOG.info(\"modifySeparateTestWindowToDetectPageLoads: windowObject was closed\");\r\n    return\r\n  }\r\n  let oldMarker = this.isPollingForLoad(windowObject)\r\n  if (oldMarker) {\r\n    //LOG.debug(\"modifySeparateTestWindowToDetectPageLoads: already polling this window: \" + oldMarker);\r\n    return\r\n  }\r\n\r\n  let marker = 'selenium' + new Date().getTime()\r\n  //LOG.debug(\"Starting pollForLoad (\" + marker + \"): \" + windowObject.location);\r\n  this.pollingForLoad[marker] = true\r\n  // if this is a frame, add a load listener, otherwise, attach a poller\r\n  let frameElement = this._getFrameElement(windowObject)\r\n  // DGF HTA mode can't attach load listeners to subframes (yuk!)\r\n  let htaSubFrame = this._isHTASubFrame(windowObject)\r\n  if (frameElement && !htaSubFrame) {\r\n    //LOG.debug(\"modifySeparateTestWindowToDetectPageLoads: this window is a frame; attaching a load listener\");\r\n    //addLoadListener(frameElement, this.recordPageLoad); TODO: check if this is necessary\r\n    frameElement[marker] = true\r\n    frameElement['frame' + this.uniqueId] = marker\r\n    //LOG.debug(\"dgf this.uniqueId=\"+this.uniqueId);\r\n    //LOG.debug(\"dgf marker=\"+marker);\r\n    //LOG.debug(\"dgf frameElement['frame'+this.uniqueId]=\"+frameElement['frame'+this.uniqueId]);\r\n    frameElement[this.uniqueId] = marker\r\n    //LOG.debug(\"dgf frameElement[this.uniqueId]=\"+frameElement[this.uniqueId]);\r\n  } else {\r\n    windowObject.location[marker] = true\r\n    windowObject[this.uniqueId] = marker\r\n    this.pollForLoad(\r\n      this.recordPageLoad,\r\n      windowObject,\r\n      windowObject.document,\r\n      windowObject.location,\r\n      windowObject.location.href,\r\n      marker\r\n    )\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._isHTASubFrame = function() {\r\n  if (!browserVersion.isHTA) return false\r\n  // DGF this is wrong! what if \"win\" isn't the selected window?\r\n  return this.isSubFrameSelected\r\n}\r\n\r\nBrowserBot.prototype._getFrameElement = function(win) {\r\n  let frameElement = null\r\n  let caught\r\n  try {\r\n    frameElement = win.frameElement\r\n  } catch (e) {\r\n    caught = true\r\n  }\r\n  if (caught) {\r\n    // on IE, checking frameElement in a pop-up results in a \"No such interface supported\" exception\r\n    // but it might have a frame element anyway!\r\n    let parentContainsIdenticallyNamedFrame = false\r\n    try {\r\n      parentContainsIdenticallyNamedFrame = win.parent.frames[win.name]\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    // this may fail if access is denied to the parent; in that case, assume it's not a pop-up\r\n\r\n    if (parentContainsIdenticallyNamedFrame) {\r\n      // it can't be a coincidence that the parent has a frame with the same name as myself!\r\n      let result\r\n      try {\r\n        result = parentContainsIdenticallyNamedFrame.frameElement\r\n        if (result) {\r\n          return result\r\n        }\r\n      } catch (e) {} // eslint-disable-line no-empty\r\n      // it was worth a try! _getFrameElementsByName is often slow\r\n      result = this._getFrameElementByName(win.name, win.parent.document, win)\r\n      return result\r\n    }\r\n  }\r\n  //LOG.debug(\"_getFrameElement: frameElement=\"+frameElement);\r\n  if (frameElement) {\r\n    //LOG.debug(\"frameElement.name=\"+frameElement.name);\r\n  }\r\n  return frameElement\r\n}\r\n\r\nBrowserBot.prototype._getFrameElementByName = function(name, doc, win) {\r\n  let frames\r\n  let frame\r\n  let i\r\n  frames = doc.getElementsByTagName('iframe')\r\n  for (i = 0; i < frames.length; i++) {\r\n    frame = frames[i]\r\n    if (frame.name === name) {\r\n      return frame\r\n    }\r\n  }\r\n  frames = doc.getElementsByTagName('frame')\r\n  for (i = 0; i < frames.length; i++) {\r\n    frame = frames[i]\r\n    if (frame.name === name) {\r\n      return frame\r\n    }\r\n  }\r\n  // DGF weird; we only call this function when we know the doc contains the frame\r\n  //LOG.warn(\"_getFrameElementByName couldn't find a frame or iframe; checking every element for the name \" + name);\r\n  return BrowserBot.prototype.locateElementByName(win.name, win.parent.document)\r\n}\r\n\r\n/**\r\n * Set up a polling timer that will keep checking the readyState of the document until it's complete.\r\n * Since we might call this before the original page is unloaded, we first check to see that the current location\r\n * or href is different from the original one.\r\n */\r\nBrowserBot.prototype.pollForLoad = function(\r\n  loadFunction,\r\n  windowObject,\r\n  originalDocument,\r\n  originalLocation,\r\n  originalHref,\r\n  marker\r\n) {\r\n  //LOG.debug(\"pollForLoad original (\" + marker + \"): \" + originalHref);\r\n  try {\r\n    //Samit: Fix: open command sometimes fails if current url is chrome and new is not\r\n    windowObject = core.firefox.unwrap(windowObject)\r\n    if (this._windowClosed(windowObject)) {\r\n      //LOG.debug(\"pollForLoad WINDOW CLOSED (\" + marker + \")\");\r\n      delete this.pollingForLoad[marker]\r\n      return\r\n    }\r\n\r\n    let isSamePage = this._isSamePage(\r\n      windowObject,\r\n      originalDocument,\r\n      originalLocation,\r\n      originalHref,\r\n      marker\r\n    )\r\n    let rs = this.getReadyState(windowObject, windowObject.document)\r\n\r\n    if (!isSamePage && rs == 'complete') {\r\n      let currentHref = windowObject.location.href\r\n      //LOG.debug(\"pollForLoad FINISHED (\" + marker + \"): \" + rs + \" (\" + currentHref + \")\");\r\n      delete this.pollingForLoad[marker]\r\n      this._modifyWindow(windowObject)\r\n      let newMarker = this.isPollingForLoad(windowObject)\r\n      if (!newMarker) {\r\n        //LOG.debug(\"modifyWindow didn't start new poller: \" + newMarker);\r\n        this.modifySeparateTestWindowToDetectPageLoads(windowObject)\r\n      }\r\n      newMarker = this.isPollingForLoad(windowObject)\r\n      let currentlySelectedWindow\r\n      let currentlySelectedWindowMarker\r\n      currentlySelectedWindow = this.getCurrentWindow(true)\r\n      currentlySelectedWindowMarker = currentlySelectedWindow[this.uniqueId]\r\n\r\n      //LOG.debug(\"pollForLoad (\" + marker + \") restarting \" + newMarker);\r\n      if (/(TestRunner-splash|Blank)\\.html\\?start=true$/.test(currentHref)) {\r\n        //LOG.debug(\"pollForLoad Oh, it's just the starting page.  Never mind!\");\r\n      } else if (currentlySelectedWindowMarker == newMarker) {\r\n        loadFunction(currentlySelectedWindow)\r\n      } else {\r\n        //LOG.debug(\"pollForLoad page load detected in non-current window; ignoring (currentlySelected=\"+currentlySelectedWindowMarker+\", detection in \"+newMarker+\")\");\r\n      }\r\n      return\r\n    }\r\n    //LOG.debug(\"pollForLoad continue (\" + marker + \"): \" + currentHref);\r\n    this.reschedulePoller(\r\n      loadFunction,\r\n      windowObject,\r\n      originalDocument,\r\n      originalLocation,\r\n      originalHref,\r\n      marker\r\n    )\r\n  } catch (e) {\r\n    //LOG.debug(\"Exception during pollForLoad; this should get noticed soon (\" + e.message + \")!\");\r\n    //DGF this is supposed to get logged later; log it at debug just in case\r\n    ////LOG.exception(e);\r\n    this.pageLoadError = e\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._isSamePage = function(\r\n  windowObject,\r\n  originalDocument,\r\n  originalLocation,\r\n  originalHref,\r\n  marker\r\n) {\r\n  let currentDocument = windowObject.document\r\n  let currentLocation = windowObject.location\r\n  let currentHref = currentLocation.href\r\n\r\n  let sameDoc = this._isSameDocument(originalDocument, currentDocument)\r\n\r\n  let sameLoc = originalLocation === currentLocation\r\n\r\n  // hash marks don't meant the page has loaded, so we need to strip them off if they exist...\r\n  let currentHash = currentHref.indexOf('#')\r\n  if (currentHash > 0) {\r\n    currentHref = currentHref.substring(0, currentHash)\r\n  }\r\n  let originalHash = originalHref.indexOf('#')\r\n  if (originalHash > 0) {\r\n    originalHref = originalHref.substring(0, originalHash)\r\n  }\r\n  //LOG.debug(\"_isSamePage: currentHref: \" + currentHref);\r\n  //LOG.debug(\"_isSamePage: originalHref: \" + originalHref);\r\n\r\n  let sameHref = originalHref === currentHref\r\n  let markedLoc = currentLocation[marker]\r\n\r\n  if (browserVersion.isKonqueror || browserVersion.isSafari) {\r\n    // the mark disappears too early on these browsers\r\n    markedLoc = true\r\n  }\r\n\r\n  // since this is some _very_ important logic, especially for PI and multiWindow mode, we should log all these out\r\n  //LOG.debug(\"_isSamePage: sameDoc: \" + sameDoc);\r\n  //LOG.debug(\"_isSamePage: sameLoc: \" + sameLoc);\r\n  //LOG.debug(\"_isSamePage: sameHref: \" + sameHref);\r\n  //LOG.debug(\"_isSamePage: markedLoc: \" + markedLoc);\r\n\r\n  return sameDoc && sameLoc && sameHref && markedLoc\r\n}\r\n\r\nBrowserBot.prototype._isSameDocument = function(\r\n  originalDocument,\r\n  currentDocument\r\n) {\r\n  return originalDocument === currentDocument\r\n}\r\n\r\nBrowserBot.prototype.getReadyState = function(windowObject, currentDocument) {\r\n  let rs = currentDocument.readyState\r\n  if (rs == null) {\r\n    if (\r\n      (this.buttonWindow != null &&\r\n        this.buttonWindow.document.readyState == null) || // not proxy injection mode (and therefore buttonWindow isn't null)\r\n      top.document.readyState == null\r\n    ) {\r\n      // proxy injection mode (and therefore everything's in the top window, but buttonWindow doesn't exist)\r\n      // uh oh!  we're probably on Firefox with no readyState extension installed!\r\n      // We'll have to just take a guess as to when the document is loaded; this guess\r\n      // will never be perfect. :-(\r\n      if (\r\n        typeof currentDocument.getElementsByTagName != 'undefined' &&\r\n        typeof currentDocument.getElementById != 'undefined' &&\r\n        (currentDocument.getElementsByTagName('body')[0] != null ||\r\n          currentDocument.body != null)\r\n      ) {\r\n        if (\r\n          windowObject.frameElement &&\r\n          windowObject.location.href == 'about:blank' &&\r\n          windowObject.frameElement.src != 'about:blank'\r\n        ) {\r\n          //LOG.info(\"getReadyState not loaded, frame location was about:blank, but frame src = \" + windowObject.frameElement.src);\r\n          return null\r\n        }\r\n        //LOG.debug(\"getReadyState = windowObject.frames.length = \" + windowObject.frames.length);\r\n        for (let i = 0; i < windowObject.frames.length; i++) {\r\n          //LOG.debug(\"i = \" + i);\r\n          if (\r\n            this.getReadyState(\r\n              windowObject.frames[i],\r\n              windowObject.frames[i].document\r\n            ) != 'complete'\r\n          ) {\r\n            //LOG.debug(\"getReadyState aha! the nested frame \" + windowObject.frames[i].name + \" wasn't ready!\");\r\n            return null\r\n          }\r\n        }\r\n\r\n        rs = 'complete'\r\n      } else {\r\n        //LOG.debug(\"pollForLoad readyState was null and DOM appeared to not be ready yet\");\r\n      }\r\n    }\r\n  } else if (rs == 'loading' && browserVersion.isIE) {\r\n    //LOG.debug(\"pageUnloading = true!!!!\");\r\n    this.pageUnloading = true\r\n  }\r\n  //LOG.debug(\"getReadyState returning \" + rs);\r\n  return rs\r\n}\r\n\r\n/** This function isn't used normally, but was the way we used to schedule pollers:\r\n asynchronously executed autonomous units.  This is deprecated, but remains here\r\n for future reference.\r\n */\r\nBrowserBot.prototype.XXXreschedulePoller = function(\r\n  loadFunction,\r\n  windowObject,\r\n  originalDocument,\r\n  originalLocation,\r\n  originalHref,\r\n  marker\r\n) {\r\n  let self = this\r\n  window.setTimeout(function() {\r\n    self.pollForLoad(\r\n      loadFunction,\r\n      windowObject,\r\n      originalDocument,\r\n      originalLocation,\r\n      originalHref,\r\n      marker\r\n    )\r\n  }, 500)\r\n}\r\n\r\n/** This function isn't used normally, but is useful for debugging asynchronous pollers\r\n * To enable it, rename it to \"reschedulePoller\", so it will override the\r\n * existing reschedulePoller function\r\n */\r\nBrowserBot.prototype.XXXreschedulePoller = function(\r\n  loadFunction,\r\n  windowObject,\r\n  originalDocument,\r\n  originalLocation,\r\n  originalHref,\r\n  marker\r\n) {\r\n  let doc = this.buttonWindow.document\r\n  let button = doc.createElement('button')\r\n  let buttonName = doc.createTextNode(marker + ' - ' + windowObject.name)\r\n  button.appendChild(buttonName)\r\n  let tools = doc.getElementById('tools')\r\n  let self = this\r\n  button.onclick = function() {\r\n    tools.removeChild(button)\r\n    self.pollForLoad(\r\n      loadFunction,\r\n      windowObject,\r\n      originalDocument,\r\n      originalLocation,\r\n      originalHref,\r\n      marker\r\n    )\r\n  }\r\n  tools.appendChild(button)\r\n  window.setTimeout(button.onclick, 500)\r\n}\r\n\r\nBrowserBot.prototype.reschedulePoller = function(\r\n  loadFunction,\r\n  windowObject,\r\n  originalDocument,\r\n  originalLocation,\r\n  originalHref,\r\n  marker\r\n) {\r\n  let self = this\r\n  let pollerFunction = function() {\r\n    self.pollForLoad(\r\n      loadFunction,\r\n      windowObject,\r\n      originalDocument,\r\n      originalLocation,\r\n      originalHref,\r\n      marker\r\n    )\r\n  }\r\n  this.windowPollers.push(pollerFunction)\r\n}\r\n\r\nBrowserBot.prototype.runScheduledPollers = function() {\r\n  //LOG.debug(\"runScheduledPollers\");\r\n  let oldPollers = this.windowPollers\r\n  this.windowPollers = new Array()\r\n  for (let i = 0; i < oldPollers.length; i++) {\r\n    oldPollers[i].call()\r\n  }\r\n  //LOG.debug(\"runScheduledPollers DONE\");\r\n}\r\n\r\nBrowserBot.prototype.isPollingForLoad = function(win) {\r\n  let marker\r\n  let frameElement = this._getFrameElement(win)\r\n  let htaSubFrame = this._isHTASubFrame(win)\r\n  if (frameElement && !htaSubFrame) {\r\n    marker = frameElement['frame' + this.uniqueId]\r\n  } else {\r\n    marker = win[this.uniqueId]\r\n  }\r\n  if (!marker) {\r\n    //LOG.debug(\"isPollingForLoad false, missing uniqueId \" + this.uniqueId + \": \" + marker);\r\n    return false\r\n  }\r\n  if (!this.pollingForLoad[marker]) {\r\n    //LOG.debug(\"isPollingForLoad false, this.pollingForLoad[\" + marker + \"]: \" + this.pollingForLoad[marker]);\r\n    return false\r\n  }\r\n  return marker\r\n}\r\n\r\nBrowserBot.prototype.getWindowByName = function(windowName, doNotModify) {\r\n  //LOG.debug(\"getWindowByName(\" + windowName + \")\");\r\n  // First look in the map of opened windows\r\n  let targetWindow = this.openedWindows[windowName]\r\n  if (!targetWindow) {\r\n    targetWindow = this.topWindow[windowName]\r\n  }\r\n  if (!targetWindow && windowName == '_blank') {\r\n    for (let winName in this.openedWindows) {\r\n      // _blank can match selenium_blank*, if it looks like it's OK (valid href, not closed)\r\n      if (/^selenium_blank/.test(winName)) {\r\n        targetWindow = this.openedWindows[winName]\r\n        let ok\r\n        try {\r\n          if (!this._windowClosed(targetWindow)) {\r\n            ok = targetWindow.location.href\r\n          }\r\n        } catch (e) {} // eslint-disable-line no-empty\r\n        if (ok) break\r\n      }\r\n    }\r\n  }\r\n  if (!targetWindow) {\r\n    throw new SeleniumError(\r\n      'Window does not exist. If this looks like a Selenium bug, make sure to read http://seleniumhq.org/docs/02_selenium_ide.html#alerts-popups-and-multiple-windows for potential workarounds.'\r\n    )\r\n  }\r\n  if (browserVersion.isHTA) {\r\n    try {\r\n      targetWindow.location.href\r\n    } catch (e) {\r\n      targetWindow = window.open('', targetWindow.name)\r\n      this.openedWindows[targetWindow.name] = targetWindow\r\n    }\r\n  }\r\n  if (!doNotModify) {\r\n    this._modifyWindow(targetWindow)\r\n  }\r\n  return targetWindow\r\n}\r\n\r\n/**\r\n * Find a window name from the window title.\r\n */\r\nBrowserBot.prototype.getWindowNameByTitle = function(windowTitle) {\r\n  //LOG.debug(\"getWindowNameByTitle(\" + windowTitle + \")\");\r\n\r\n  // First look in the map of opened windows and iterate them\r\n  for (let windowName in this.openedWindows) {\r\n    let targetWindow = this.openedWindows[windowName]\r\n\r\n    // If the target window's title is our title\r\n    try {\r\n      // TODO implement Pattern Matching here\r\n      if (\r\n        !this._windowClosed(targetWindow) &&\r\n        targetWindow.document.title == windowTitle\r\n      ) {\r\n        return windowName\r\n      }\r\n    } catch (e) {\r\n      // You'll often get Permission Denied errors here in IE\r\n      // eh, if we can't read this window's title,\r\n      // it's probably not available to us right now anyway\r\n    }\r\n  }\r\n\r\n  try {\r\n    if (this.topWindow.document.title == windowTitle) {\r\n      return ''\r\n    }\r\n  } catch (e) {} // eslint-disable-line no-empty\r\n  // IE Perm denied\r\n\r\n  throw new SeleniumError('Could not find window with title ' + windowTitle)\r\n}\r\n\r\nBrowserBot.prototype.getNonTopWindowNames = function() {\r\n  let nonTopWindowNames = []\r\n\r\n  for (let windowName in this.openedWindows) {\r\n    let win = this.openedWindows[windowName]\r\n    if (!this._windowClosed(win) && win != this.topWindow) {\r\n      nonTopWindowNames.push(windowName)\r\n    }\r\n  }\r\n\r\n  return nonTopWindowNames\r\n}\r\n\r\nBrowserBot.prototype.getCurrentWindow = function(doNotModify) {\r\n  if (this.proxyInjectionMode) {\r\n    return window\r\n  }\r\n  let testWindow = core.firefox.unwrap(this.currentWindow)\r\n  if (!doNotModify) {\r\n    this._modifyWindow(testWindow)\r\n    //LOG.debug(\"getCurrentWindow newPageLoaded = false\");\r\n    this.newPageLoaded = false\r\n  }\r\n  testWindow = this._handleClosedSubFrame(testWindow, doNotModify)\r\n  bot.window_ = testWindow\r\n  return core.firefox.unwrap(testWindow)\r\n}\r\n\r\n/**\r\n * Offer a method the end-user can reliably use to retrieve the current window.\r\n * This should work even for windows with an XPCNativeWrapper. Returns the\r\n * current window object.\r\n */\r\nBrowserBot.prototype.getUserWindow = function() {\r\n  let userWindow = this.getCurrentWindow(true)\r\n  return userWindow\r\n}\r\n\r\nBrowserBot.prototype._handleClosedSubFrame = function(testWindow, doNotModify) {\r\n  if (this.proxyInjectionMode) {\r\n    return testWindow\r\n  }\r\n\r\n  if (this.isSubFrameSelected) {\r\n    let missing = true\r\n    if (\r\n      testWindow.parent &&\r\n      testWindow.parent.frames &&\r\n      testWindow.parent.frames.length\r\n    ) {\r\n      for (let i = 0; i < testWindow.parent.frames.length; i++) {\r\n        let frame = testWindow.parent.frames[i]\r\n        if (\r\n          frame == testWindow ||\r\n          frame.seleniumKey == testWindow.seleniumKey\r\n        ) {\r\n          missing = false\r\n          break\r\n        }\r\n      }\r\n    }\r\n    if (missing) {\r\n      //LOG.warn(\"Current subframe appears to have closed; selecting top frame\");\r\n      this.selectFrame('relative=top')\r\n      return this.getCurrentWindow(doNotModify)\r\n    }\r\n  } else if (this._windowClosed(testWindow)) {\r\n    //UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/11/25\r\n    /*var closedError = new SeleniumError(\"Current window or frame is closed!\");\r\n        closedError.windowClosed = true;\r\n        throw closedError;*/\r\n    testWindow = this.topWindow //select live object\r\n  }\r\n  return testWindow\r\n}\r\n\r\nBrowserBot.prototype.setShouldHighlightElement = function(shouldHighlight) {\r\n  this.shouldHighlightLocatedElement = shouldHighlight\r\n}\r\n\r\n/*****************************************************************/\r\n/* BROWSER-SPECIFIC FUNCTIONS ONLY AFTER THIS LINE */\r\n\r\nBrowserBot.prototype._registerAllLocatorFunctions = function() {\r\n  // TODO - don't do this in the constructor - only needed once ever\r\n  this.locationStrategies = {}\r\n  for (let functionName in this) {\r\n    let result = /^locateElementBy([A-Z].+)$/.exec(functionName)\r\n    if (result != null) {\r\n      let locatorFunction = this[functionName]\r\n      if (typeof locatorFunction != 'function') {\r\n        continue\r\n      }\r\n      // Use a specified prefix in preference to one generated from\r\n      // the function name\r\n      let locatorPrefix = locatorFunction.prefix || result[1].toLowerCase()\r\n      this.locationStrategies[locatorPrefix] = locatorFunction\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find a locator based on a prefix.\r\n   */\r\n  this.findElementBy = function(locatorType, locator, inDocument, inWindow) {\r\n    let locatorFunction = this.locationStrategies[locatorType]\r\n    if (!locatorFunction) {\r\n      throw new SeleniumError(\r\n        \"Unrecognised locator type: '\" + locatorType + \"'\"\r\n      )\r\n    }\r\n    return locatorFunction.call(this, locator, inDocument, inWindow)\r\n  }\r\n\r\n  /**\r\n   * The implicit locator, that is used when no prefix is supplied.\r\n   */\r\n  this.locationStrategies['implicit'] = function(\r\n    locator,\r\n    inDocument,\r\n    inWindow\r\n  ) {\r\n    if (locator.startsWith('//')) {\r\n      return this.locateElementByXPath(locator, inDocument, inWindow)\r\n    }\r\n    if (locator.startsWith('document.')) {\r\n      return this.locateElementByDomTraversal(locator, inDocument, inWindow)\r\n    }\r\n    return this.locateElementByIdentifier(locator, inDocument, inWindow)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.getDocument = function() {\r\n  return core.firefox.unwrap(this.getCurrentWindow().document)\r\n}\r\n\r\nBrowserBot.prototype.getTitle = function() {\r\n  let t = this.getDocument().title\r\n  if (typeof t == 'string') {\r\n    t = t.trim()\r\n  }\r\n  return t\r\n}\r\n\r\nBrowserBot.prototype.getCookieByName = function(cookieName, doc) {\r\n  if (!doc) doc = this.getDocument()\r\n  let ck = doc.cookie\r\n  if (!ck) return null\r\n  let ckPairs = ck.split(/;/)\r\n  for (let i = 0; i < ckPairs.length; i++) {\r\n    let ckPair = ckPairs[i].trim()\r\n    let ckNameValue = ckPair.split(/=/)\r\n    let ckName = decodeURIComponent(ckNameValue[0])\r\n    if (ckName === cookieName) {\r\n      return decodeURIComponent(ckNameValue.slice(1).join('='))\r\n    }\r\n  }\r\n  return null\r\n}\r\n\r\nBrowserBot.prototype.getAllCookieNames = function(doc) {\r\n  if (!doc) doc = this.getDocument()\r\n  let ck = doc.cookie\r\n  if (!ck) return []\r\n  let cookieNames = []\r\n  let ckPairs = ck.split(/;/)\r\n  for (let i = 0; i < ckPairs.length; i++) {\r\n    let ckPair = ckPairs[i].trim()\r\n    let ckNameValue = ckPair.split(/=/)\r\n    let ckName = decodeURIComponent(ckNameValue[0])\r\n    cookieNames.push(ckName)\r\n  }\r\n  return cookieNames\r\n}\r\n\r\nBrowserBot.prototype.getAllRawCookieNames = function(doc) {\r\n  if (!doc) doc = this.getDocument()\r\n  let ck = doc.cookie\r\n  if (!ck) return []\r\n  let cookieNames = []\r\n  let ckPairs = ck.split(/;/)\r\n  for (let i = 0; i < ckPairs.length; i++) {\r\n    let ckPair = ckPairs[i].trim()\r\n    let ckNameValue = ckPair.split(/=/)\r\n    let ckName = ckNameValue[0]\r\n    cookieNames.push(ckName)\r\n  }\r\n  return cookieNames\r\n}\r\n\r\nfunction encodeURIComponentWithASPHack(uri) {\r\n  let regularEncoding = encodeURIComponent(uri)\r\n  let aggressiveEncoding = regularEncoding.replace('.', '%2E')\r\n  aggressiveEncoding = aggressiveEncoding.replace('_', '%5F')\r\n  return aggressiveEncoding\r\n}\r\n\r\nBrowserBot.prototype.deleteCookie = function(cookieName, domain, path, doc) {\r\n  if (!doc) doc = this.getDocument()\r\n  let expireDateInMilliseconds = new Date().getTime() + -1 * 1000\r\n\r\n  // we can't really be sure if we're dealing with encoded or unencoded cookie names\r\n  let _cookieName\r\n  let rawCookieNames = this.getAllRawCookieNames(doc)\r\n  for (let rawCookieNumber in rawCookieNames) {\r\n    if (rawCookieNames[rawCookieNumber] == cookieName) {\r\n      _cookieName = cookieName\r\n      break\r\n    } else if (\r\n      rawCookieNames[rawCookieNumber] == encodeURIComponent(cookieName)\r\n    ) {\r\n      _cookieName = encodeURIComponent(cookieName)\r\n      break\r\n    } else if (\r\n      rawCookieNames[rawCookieNumber] ==\r\n      encodeURIComponentWithASPHack(cookieName)\r\n    ) {\r\n      _cookieName = encodeURIComponentWithASPHack(cookieName)\r\n      break\r\n    }\r\n  }\r\n\r\n  let cookie = _cookieName + '=deleted; '\r\n  if (path) {\r\n    cookie += 'path=' + path + '; '\r\n  }\r\n  if (domain) {\r\n    cookie += 'domain=' + domain + '; '\r\n  }\r\n  cookie += 'expires=' + new Date(expireDateInMilliseconds).toGMTString()\r\n  //LOG.debug(\"Setting cookie to: \" + cookie);\r\n  doc.cookie = cookie\r\n}\r\n\r\n/** Try to delete cookie, return false if it didn't work */\r\nBrowserBot.prototype._maybeDeleteCookie = function(\r\n  cookieName,\r\n  domain,\r\n  path,\r\n  doc\r\n) {\r\n  this.deleteCookie(cookieName, domain, path, doc)\r\n  return !this.getCookieByName(cookieName, doc)\r\n}\r\n\r\nBrowserBot.prototype._recursivelyDeleteCookieDomains = function(\r\n  cookieName,\r\n  domain,\r\n  path,\r\n  doc\r\n) {\r\n  let deleted = this._maybeDeleteCookie(cookieName, domain, path, doc)\r\n  if (deleted) return true\r\n  let dotIndex = domain.indexOf('.')\r\n  if (dotIndex == 0) {\r\n    return this._recursivelyDeleteCookieDomains(\r\n      cookieName,\r\n      domain.substring(1),\r\n      path,\r\n      doc\r\n    )\r\n  } else if (dotIndex != -1) {\r\n    return this._recursivelyDeleteCookieDomains(\r\n      cookieName,\r\n      domain.substring(dotIndex),\r\n      path,\r\n      doc\r\n    )\r\n  } else {\r\n    // No more dots; try just not passing in a domain at all\r\n    return this._maybeDeleteCookie(cookieName, null, path, doc)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._recursivelyDeleteCookie = function(\r\n  cookieName,\r\n  domain,\r\n  path,\r\n  doc\r\n) {\r\n  let slashIndex = path.lastIndexOf('/')\r\n  let finalIndex = path.length - 1\r\n  if (slashIndex == finalIndex) {\r\n    slashIndex--\r\n  }\r\n  if (slashIndex != -1) {\r\n    const deleted = this._recursivelyDeleteCookie(\r\n      cookieName,\r\n      domain,\r\n      path.substring(0, slashIndex + 1),\r\n      doc\r\n    )\r\n    if (deleted) return true\r\n  }\r\n  return this._recursivelyDeleteCookieDomains(cookieName, domain, path, doc)\r\n}\r\n\r\nBrowserBot.prototype.recursivelyDeleteCookie = function(\r\n  cookieName,\r\n  domain,\r\n  path,\r\n  win\r\n) {\r\n  if (!win) win = this.getCurrentWindow()\r\n  let doc = win.document\r\n  if (!domain) {\r\n    domain = doc.domain\r\n  }\r\n  if (!path) {\r\n    path = win.location.pathname\r\n  }\r\n  let deleted = this._recursivelyDeleteCookie(\r\n    cookieName,\r\n    '.' + domain,\r\n    path,\r\n    doc\r\n  )\r\n  if (deleted) return\r\n  // Finally try a null path (Try it last because it's uncommon)\r\n  deleted = this._recursivelyDeleteCookieDomains(\r\n    cookieName,\r\n    '.' + domain,\r\n    null,\r\n    doc\r\n  )\r\n  if (deleted) return\r\n  throw new SeleniumError(\"Couldn't delete cookie \" + cookieName)\r\n}\r\n\r\n/*\r\n * Finds an element on the current page, using various lookup protocols\r\n */\r\nBrowserBot.prototype.findElementOrNull = function(locator, win) {\r\n  locator = parse_locator(locator)\r\n\r\n  if (win == null) {\r\n    win = this.getCurrentWindow()\r\n  }\r\n  let element = bot.locators.findElement(\r\n    { [locator.type]: locator.string },\r\n    win.document\r\n  )\r\n  element = core.firefox.unwrap(element)\r\n\r\n  // Element was not found by any locator function.\r\n  return element\r\n}\r\n\r\nBrowserBot.prototype.findElement = function(locator, win) {\r\n  let element = this.findElementOrNull(locator, win)\r\n  if (element == null)\r\n    throw new SeleniumError('Element ' + locator + ' not found')\r\n  return core.firefox.unwrap(element)\r\n}\r\n\r\n/**\r\n * Finds a list of elements using the same mechanism as webdriver.\r\n *\r\n * @param {string} how The finding mechanism to use.\r\n * @param {string} using The selector to use.\r\n * @param {Document|Element} root The root of the search path.\r\n */\r\nBrowserBot.prototype.findElementsLikeWebDriver = function(how, using, root) {\r\n  let by = {}\r\n  by[how] = using\r\n\r\n  let all = bot.locators.findElements(by, root)\r\n  let toReturn = ''\r\n\r\n  for (let i = 0; i < all.length - 1; i++) {\r\n    toReturn += bot.inject.cache.addElement(core.firefox.unwrap(all[i])) + ','\r\n  }\r\n  if (all[all.length - 1]) {\r\n    toReturn += bot.inject.cache.addElement(\r\n      core.firefox.unwrap(all[all.length - 1])\r\n    )\r\n  }\r\n\r\n  return toReturn\r\n}\r\n\r\n/**\r\n * In non-IE browsers, getElementById() does not search by name.  Instead, we\r\n * we search separately by id and name.\r\n */\r\nBrowserBot.prototype.locateElementByIdentifier = function(\r\n  identifier,\r\n  inDocument,\r\n  inWindow\r\n) {\r\n  // HBC - use \"this\" instead of \"BrowserBot.prototype\"; otherwise we lose\r\n  // the non-prototype fields of the object!\r\n  return (\r\n    this.locateElementById(identifier, inDocument, inWindow) ||\r\n    BrowserBot.prototype.locateElementByName(\r\n      identifier,\r\n      inDocument,\r\n      inWindow\r\n    ) ||\r\n    null\r\n  )\r\n}\r\n\r\n/**\r\n * Find the element with id - can't rely on getElementById, coz it returns by name as well in IE..\r\n */\r\nBrowserBot.prototype.locateElementById = function(identifier, inDocument) {\r\n  let element = inDocument.getElementById(identifier)\r\n  if (element && element.getAttribute('id') === identifier) {\r\n    return element\r\n  } else if (browserVersion.isIE || browserVersion.isOpera) {\r\n    // SEL-484\r\n    let elements = inDocument.getElementsByTagName('*')\r\n\r\n    for (let i = 0, n = elements.length; i < n; ++i) {\r\n      element = elements[i]\r\n\r\n      if (element.tagName.toLowerCase() == 'form') {\r\n        if (element.attributes['id'].nodeValue == identifier) {\r\n          return element\r\n        }\r\n      } else if (element.getAttribute('id') == identifier) {\r\n        return element\r\n      }\r\n    }\r\n\r\n    return null\r\n  } else {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Find an element by name, refined by (optional) element-filter\r\n * expressions.\r\n */\r\nBrowserBot.prototype.locateElementByName = function(locator, document) {\r\n  let elements = document.getElementsByTagName('*')\r\n  //UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/11/23\r\n  /*\r\n        var filters = locator.split(' ');\r\n        filters[0] = 'name=' + filters[0];\r\n\r\n        while (filters.length) {\r\n            var filter = filters.shift();\r\n            elements = this.selectElements(filter, elements, 'value');\r\n        }\r\n        */\r\n  let filter = 'name=' + locator\r\n  elements = this.selectElements(filter, elements, 'value')\r\n\r\n  if (elements.length > 0) {\r\n    return elements[0]\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Finds an element using by evaluating the specfied string.\r\n */\r\nBrowserBot.prototype.locateElementByDomTraversal = function(domTraversal) {\r\n  let element = null\r\n\r\n  //Evalinsandbox\r\n  // eslint-disable-next-line no-undef\r\n  let mySandbox = new Components.utils.Sandbox(this.currentWindow.location.href)\r\n  mySandbox.domTraversal = domTraversal\r\n  try {\r\n    // eslint-disable-next-line no-undef\r\n    element = Components.utils.evalInSandbox(domTraversal, mySandbox)\r\n    //element = eval(domTraversal);\r\n  } catch (e) {\r\n    return null\r\n  }\r\n\r\n  if (!element) {\r\n    return null\r\n  }\r\n\r\n  return element\r\n}\r\n\r\nBrowserBot.prototype.locateElementByDomTraversal.prefix = 'dom'\r\n\r\nBrowserBot.prototype.locateElementByStoredReference = function(locator) {\r\n  try {\r\n    return core.locators.findElement('stored=' + locator)\r\n  } catch (e) {\r\n    return null\r\n  }\r\n}\r\nBrowserBot.prototype.locateElementByStoredReference.prefix = 'stored'\r\n\r\nBrowserBot.prototype.locateElementByWebDriver = function(locator) {\r\n  try {\r\n    return core.locators.findElement('webdriver=' + locator)\r\n  } catch (e) {\r\n    return null\r\n  }\r\n}\r\nBrowserBot.prototype.locateElementByWebDriver.prefix = 'webdriver'\r\n\r\n/**\r\n * Finds an element identified by the xpath expression. Expressions _must_\r\n * begin with \"//\".\r\n */\r\nBrowserBot.prototype.locateElementByXPath = function(xpath, inDocument) {\r\n  return this.xpathEvaluator.selectSingleNode(\r\n    inDocument,\r\n    xpath,\r\n    null,\r\n    inDocument.createNSResolver\r\n      ? inDocument.createNSResolver(inDocument.documentElement)\r\n      : this._namespaceResolver\r\n  )\r\n}\r\n\r\n/**\r\n * Find many elements using xpath.\r\n *\r\n * @param {string} xpath XPath expression to search for.\r\n * @param {=Document} inDocument The document to search in.\r\n * @param {=Window} inWindow The window the document is in.\r\n */\r\nBrowserBot.prototype.locateElementsByXPath = function(xpath, inDocument) {\r\n  return this.xpathEvaluator.selectNodes(\r\n    inDocument,\r\n    xpath,\r\n    null,\r\n    inDocument.createNSResolver\r\n      ? inDocument.createNSResolver(inDocument.documentElement)\r\n      : this._namespaceResolver\r\n  )\r\n}\r\n\r\nBrowserBot.prototype._namespaceResolver = function(prefix) {\r\n  if (prefix == 'html' || prefix == 'xhtml' || prefix == 'x') {\r\n    return 'http://www.w3.org/1999/xhtml'\r\n  } else if (prefix == 'mathml') {\r\n    return 'http://www.w3.org/1998/Math/MathML'\r\n  } else if (prefix == 'svg') {\r\n    return 'http://www.w3.org/2000/svg'\r\n  } else {\r\n    throw new Error('Unknown namespace: ' + prefix + '.')\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the number of xpath results.\r\n */\r\nBrowserBot.prototype.evaluateXPathCount = function(selector, inDocument) {\r\n  let locator = parse_locator(selector)\r\n  if (locator.type == 'xpath' || locator.type == 'implicit') {\r\n    return bot.locators.findElements({ xpath: locator.string }, inDocument)\r\n      .length\r\n  } else {\r\n    //LOG.error(\"Locator does not use XPath strategy: \" + selector);\r\n    return 0\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the number of css results.\r\n */\r\nBrowserBot.prototype.evaluateCssCount = function(selector, inDocument) {\r\n  let locator = parse_locator(selector)\r\n  if (locator.type == 'css' || locator.type == 'implicit') {\r\n    return bot.locators.findElements({ css: locator.string }, inDocument).length\r\n  } else {\r\n    //LOG.error(\"Locator does not use CSS strategy: \" + selector);\r\n    return 0\r\n  }\r\n}\r\n\r\n/**\r\n * Finds a link element with text matching the expression supplied. Expressions must\r\n * begin with \"link:\".\r\n */\r\nBrowserBot.prototype.locateElementByLinkText = function(linkText, inDocument) {\r\n  let links = inDocument.getElementsByTagName('a')\r\n  for (let i = 0; i < links.length; i++) {\r\n    let element = links[i]\r\n    if (PatternMatcher.matches(linkText, bot.dom.getVisibleText(element))) {\r\n      return element\r\n    }\r\n  }\r\n  return null\r\n}\r\n\r\nBrowserBot.prototype.locateElementByLinkText.prefix = 'link'\r\n\r\n/**\r\n * Returns an attribute based on an attribute locator. This is made up of an element locator\r\n * suffixed with @attribute-name.\r\n */\r\nBrowserBot.prototype.findAttribute = function(locator) {\r\n  // Split into locator + attributeName\r\n  let attributePos = locator.lastIndexOf('@')\r\n  let elementLocator = locator.slice(0, attributePos)\r\n  let attributeName = locator.slice(attributePos + 1)\r\n\r\n  // Find the element.\r\n  let element = this.findElement(elementLocator)\r\n  let attributeValue = bot.dom.getAttribute(element, attributeName)\r\n  return goog.isDefAndNotNull(attributeValue) ? attributeValue.toString() : null\r\n}\r\n\r\n/*\r\n * Select the specified option and trigger the relevant events of the element.\r\n */\r\nBrowserBot.prototype.selectOption = function(element, optionToSelect) {\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n  let changed = false\r\n  for (let i = 0; i < element.options.length; i++) {\r\n    let option = element.options[i]\r\n    if (option.selected && option != optionToSelect) {\r\n      option.selected = false\r\n      changed = true\r\n    } else if (!option.selected && option == optionToSelect) {\r\n      option.selected = true\r\n      changed = true\r\n    }\r\n  }\r\n\r\n  if (changed) {\r\n    bot.events.fire(element, bot.events.EventType.CHANGE)\r\n  }\r\n}\r\n\r\n/*\r\n * Select the specified option and trigger the relevant events of the element.\r\n */\r\nBrowserBot.prototype.addSelection = function(element, option) {\r\n  this.checkMultiselect(element)\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n  if (!option.selected) {\r\n    option.selected = true\r\n    bot.events.fire(element, bot.events.EventType.CHANGE)\r\n  }\r\n}\r\n\r\n/*\r\n * Select the specified option and trigger the relevant events of the element.\r\n */\r\nBrowserBot.prototype.removeSelection = function(element, option) {\r\n  this.checkMultiselect(element)\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n  if (option.selected) {\r\n    option.selected = false\r\n    bot.events.fire(element, bot.events.EventType.CHANGE)\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.checkMultiselect = function(element) {\r\n  if (!element.multiple) {\r\n    throw new SeleniumError('Not a multi-select')\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.replaceText = function(element, stringValue) {\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n  bot.events.fire(element, bot.events.EventType.SELECT)\r\n  let maxLengthAttr = element.getAttribute('maxLength')\r\n  let actualValue = stringValue\r\n  if (maxLengthAttr != null) {\r\n    let maxLength = parseInt(maxLengthAttr)\r\n    if (stringValue.length > maxLength) {\r\n      actualValue = stringValue.substr(0, maxLength)\r\n    }\r\n  }\r\n\r\n  if (getTagName(element) == 'body') {\r\n    if (element.ownerDocument && element.ownerDocument.designMode) {\r\n      let designMode = new String(\r\n        element.ownerDocument.designMode\r\n      ).toLowerCase()\r\n      if (designMode == 'on') {\r\n        // this must be a rich text control!\r\n        element.innerHTML = actualValue\r\n      }\r\n    }\r\n  } else {\r\n    element.value = actualValue\r\n  }\r\n  // DGF this used to be skipped in chrome URLs, but no longer.  Is xpcnativewrappers to blame?\r\n  try {\r\n    bot.events.fire(element, bot.events.EventType.CHANGE)\r\n  } catch (e) {} // eslint-disable-line no-empty\r\n}\r\n\r\nBrowserBot.prototype.clickElement = function(element, clientX, clientY) {\r\n  this._fireEventOnElement('click', element, clientX, clientY)\r\n}\r\n\r\nBrowserBot.prototype.doubleClickElement = function(element, clientX, clientY) {\r\n  this._fireEventOnElement('dblclick', element, clientX, clientY)\r\n}\r\n\r\n// The contextmenu event is fired when the user right-clicks to open the context menu\r\nBrowserBot.prototype.contextMenuOnElement = function(\r\n  element,\r\n  clientX,\r\n  clientY\r\n) {\r\n  this._fireEventOnElement('contextmenu', element, clientX, clientY)\r\n}\r\n\r\n//UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/05/26\r\n//UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/11/17\r\nBrowserBot.prototype._modifyElementTarget = function(e) {\r\n  let element = this.findClickableElement(e) || e\r\n  if (element.target) {\r\n    if (element.target == '_blank' || /^selenium_blank/.test(element.target)) {\r\n      let tagName = getTagName(element)\r\n      if (tagName == 'a' || tagName == 'form') {\r\n        const newTarget = 'win_ser_' + this.count\r\n        this.count += 1\r\n        this.browserbot.openWindow('', newTarget)\r\n        element.target = newTarget\r\n      }\r\n    } else {\r\n      const newTarget = element.target\r\n      this.browserbot.openWindow('', newTarget)\r\n      element.target = newTarget\r\n    }\r\n  }\r\n}\r\n\r\n//UnnamedWinIFrameExt, Jie-Lin You, SELAB, CSIE, NCKU, 2016/11/17\r\nBrowserBot.prototype.findClickableElement = function(e) {\r\n  if (!e.tagName) return null\r\n  let tagName = e.tagName.toLowerCase()\r\n  let type = e.type\r\n  if (\r\n    e.hasAttribute('onclick') ||\r\n    e.hasAttribute('href') ||\r\n    e.hasAttribute('url') ||\r\n    tagName == 'button' ||\r\n    (tagName == 'input' &&\r\n      (type == 'submit' ||\r\n        type == 'button' ||\r\n        type == 'image' ||\r\n        type == 'radio' ||\r\n        type == 'checkbox' ||\r\n        type == 'reset'))\r\n  ) {\r\n    return e\r\n  } else {\r\n    if (e.parentNode != null) {\r\n      return this.findClickableElement(e.parentNode)\r\n    } else {\r\n      return null\r\n    }\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._handleClickingImagesInsideLinks = function(\r\n  targetWindow,\r\n  element\r\n) {\r\n  let itrElement = element\r\n  while (itrElement != null) {\r\n    if (itrElement.href) {\r\n      targetWindow.location.href = itrElement.href\r\n      break\r\n    }\r\n    itrElement = itrElement.parentNode\r\n  }\r\n}\r\n\r\nBrowserBot.prototype._getTargetWindow = function(element) {\r\n  let targetWindow = element.ownerDocument.defaultView\r\n  if (element.target) {\r\n    targetWindow = this._getFrameFromGlobal(element.target)\r\n  }\r\n  return targetWindow\r\n}\r\n\r\nBrowserBot.prototype._getFrameFromGlobal = function(target) {\r\n  if (target == '_self') {\r\n    return this.getCurrentWindow()\r\n  }\r\n  if (target == '_top') {\r\n    return this.topFrame\r\n  } else if (target == '_parent') {\r\n    return this.getCurrentWindow().parent\r\n  } else if (target == '_blank') {\r\n    // TODO should this set cleverer window defaults?\r\n    return this.getCurrentWindow().open('', '_blank')\r\n  }\r\n  let frameElement = this.findElementBy(\r\n    'implicit',\r\n    target,\r\n    this.topFrame.document,\r\n    this.topFrame\r\n  )\r\n  if (frameElement) {\r\n    return frameElement.contentWindow\r\n  }\r\n  let win = this.getWindowByName(target)\r\n  if (win) return win\r\n  return this.getCurrentWindow().open('', target)\r\n}\r\n\r\nBrowserBot.prototype.bodyText = function() {\r\n  if (!this.getDocument().body) {\r\n    throw new SeleniumError(\r\n      \"Couldn't access document.body.  Is this HTML page fully loaded?\"\r\n    )\r\n  }\r\n  return bot.dom.getVisibleText(this.getDocument().body)\r\n}\r\n\r\nBrowserBot.prototype.getAllButtons = function() {\r\n  let elements = this.getDocument().getElementsByTagName('input')\r\n  let result = []\r\n\r\n  for (let i = 0; i < elements.length; i++) {\r\n    if (\r\n      elements[i].type == 'button' ||\r\n      elements[i].type == 'submit' ||\r\n      elements[i].type == 'reset'\r\n    ) {\r\n      result.push(elements[i].id)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nBrowserBot.prototype.getAllFields = function() {\r\n  let elements = this.getDocument().getElementsByTagName('input')\r\n  let result = []\r\n\r\n  for (let i = 0; i < elements.length; i++) {\r\n    if (elements[i].type == 'text') {\r\n      result.push(elements[i].id)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nBrowserBot.prototype.getAllLinks = function() {\r\n  let elements = this.getDocument().getElementsByTagName('a')\r\n  let result = []\r\n\r\n  for (let i = 0; i < elements.length; i++) {\r\n    result.push(elements[i].id)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction isDefined(value) {\r\n  return typeof value != undefined\r\n}\r\n\r\nBrowserBot.prototype.goBack = function() {\r\n  this.getCurrentWindow().history.back()\r\n}\r\n\r\nBrowserBot.prototype.goForward = function() {\r\n  this.getCurrentWindow().history.forward()\r\n}\r\n\r\nBrowserBot.prototype.close = function() {\r\n  if (browserVersion.isIE) {\r\n    // fix \"do you want to close this window\" warning in IE\r\n    // You can only close windows that you have opened.\r\n    // So, let's \"open\" it.\r\n    try {\r\n      this.topFrame.name = new Date().getTime()\r\n      window.open('', this.topFrame.name, '')\r\n      this.topFrame.close()\r\n      return\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n  }\r\n  if (\r\n    browserVersion.isChrome ||\r\n    browserVersion.isSafari ||\r\n    browserVersion.isOpera\r\n  ) {\r\n    this.topFrame.close()\r\n  } else {\r\n    this.getCurrentWindow().eval('window.top.close();')\r\n  }\r\n}\r\n\r\nBrowserBot.prototype.refresh = function() {\r\n  this.getCurrentWindow().location.reload(true)\r\n}\r\n\r\n/**\r\n * Refine a list of elements using a filter.\r\n */\r\nBrowserBot.prototype.selectElementsBy = function(filterType, filter, elements) {\r\n  let filterFunction = BrowserBot.filterFunctions[filterType]\r\n  if (!filterFunction) {\r\n    throw new SeleniumError(\r\n      \"Unrecognised element-filter type: '\" + filterType + \"'\"\r\n    )\r\n  }\r\n\r\n  return filterFunction(filter, elements)\r\n}\r\n\r\nBrowserBot.filterFunctions = {}\r\n\r\nBrowserBot.filterFunctions.name = function(name, elements) {\r\n  let selectedElements = []\r\n  for (let i = 0; i < elements.length; i++) {\r\n    if (elements[i].name === name) {\r\n      selectedElements.push(elements[i])\r\n    }\r\n  }\r\n  return selectedElements\r\n}\r\n\r\nBrowserBot.filterFunctions.value = function(value, elements) {\r\n  let selectedElements = []\r\n  for (let i = 0; i < elements.length; i++) {\r\n    if (elements[i].value === value) {\r\n      selectedElements.push(elements[i])\r\n    }\r\n  }\r\n  return selectedElements\r\n}\r\n\r\nBrowserBot.filterFunctions.index = function(index, elements) {\r\n  index = Number(index)\r\n  if (isNaN(index) || index < 0) {\r\n    throw new SeleniumError('Illegal Index: ' + index)\r\n  }\r\n  if (elements.length <= index) {\r\n    throw new SeleniumError('Index out of range: ' + index)\r\n  }\r\n  return [elements[index]]\r\n}\r\n\r\nBrowserBot.prototype.selectElements = function(\r\n  filterExpr,\r\n  elements,\r\n  defaultFilterType\r\n) {\r\n  let filterType = defaultFilterType || 'value'\r\n\r\n  // If there is a filter prefix, use the specified strategy\r\n  let result = filterExpr.match(/^([A-Za-z]+)=(.+)/)\r\n  if (result) {\r\n    filterType = result[1].toLowerCase()\r\n    filterExpr = result[2]\r\n  }\r\n\r\n  return this.selectElementsBy(filterType, filterExpr, elements)\r\n}\r\n\r\n/**\r\n * Find an element by css selector\r\n */\r\nBrowserBot.prototype.locateElementByCss = function(locator, document) {\r\n  let elements = bot.locators.findElements({ css: locator }, document)\r\n  if (elements.length != 0) return elements[0]\r\n  return null\r\n}\r\n\r\n/* prompt */\r\nBrowserBot.prototype.cancelNextPrompt = function() {\r\n  return this.setNextPromptResult(null)\r\n}\r\n\r\nBrowserBot.prototype.setNextPromptResult = function(result) {\r\n  this.promptResponse = false\r\n  let self = this\r\n\r\n  window.postMessage(\r\n    {\r\n      direction: 'from-content-script',\r\n      command: 'setNextPromptResult',\r\n      target: result,\r\n    },\r\n    '*'\r\n  )\r\n\r\n  let response = new Promise(function(resolve, reject) {\r\n    let count = 0\r\n    let interval = setInterval(function() {\r\n      if (!self.promptResponse) {\r\n        count++\r\n        if (count > 60) {\r\n          reject('No response')\r\n          clearInterval(interval)\r\n        }\r\n      } else {\r\n        resolve()\r\n        self.promptResponse = false\r\n        clearInterval(interval)\r\n      }\r\n    }, 500)\r\n  })\r\n  return response\r\n}\r\n\r\nBrowserBot.prototype.getPromptMessage = function() {\r\n  this.promptResponse = false\r\n  this.promptMessage = null\r\n  let self = this\r\n  window.postMessage(\r\n    {\r\n      direction: 'from-content-script',\r\n      command: 'getPromptMessage',\r\n    },\r\n    '*'\r\n  )\r\n  let response = new Promise(function(resolve, reject) {\r\n    let count = 0\r\n    let interval = setInterval(function() {\r\n      if (!self.promptResponse) {\r\n        count++\r\n        if (count > 60) {\r\n          reject('No response')\r\n          clearInterval(interval)\r\n        }\r\n      } else {\r\n        resolve(self.promptMessage)\r\n        self.promptResponse = false\r\n        self.promptMessage = null\r\n        clearInterval(interval)\r\n      }\r\n    }, 500)\r\n  })\r\n  return response\r\n}\r\n\r\n// confirm\r\nBrowserBot.prototype.setNextConfirmationResult = function(result) {\r\n  this.confirmationResponse = false\r\n  let self = this\r\n  window.postMessage(\r\n    {\r\n      direction: 'from-content-script',\r\n      command: 'setNextConfirmationResult',\r\n      target: result,\r\n    },\r\n    '*'\r\n  )\r\n  let response = new Promise(function(resolve, reject) {\r\n    let count = 0\r\n    let interval = setInterval(function() {\r\n      if (!self.confirmationResponse) {\r\n        count++\r\n        if (count > 60) {\r\n          reject('No response')\r\n          clearInterval(interval)\r\n        }\r\n      } else {\r\n        resolve()\r\n        self.confirmationResponse = false\r\n        clearInterval(interval)\r\n      }\r\n    }, 500)\r\n  })\r\n  return response\r\n}\r\n\r\nBrowserBot.prototype.getConfirmationMessage = function() {\r\n  this.confirmationResponse = false\r\n  this.confirmationMessage = null\r\n  let self = this\r\n  window.postMessage(\r\n    {\r\n      direction: 'from-content-script',\r\n      command: 'getConfirmationMessage',\r\n    },\r\n    '*'\r\n  )\r\n  let response = new Promise(function(resolve, reject) {\r\n    let count = 0\r\n    let interval = setInterval(function() {\r\n      if (!self.confirmationResponse) {\r\n        count++\r\n        if (count > 60) {\r\n          reject('No response')\r\n          clearInterval(interval)\r\n        }\r\n      } else {\r\n        resolve(self.confirmationMessage)\r\n        self.confirmationResponse = false\r\n        self.confirmationMessage = null\r\n        clearInterval(interval)\r\n      }\r\n    }, 500)\r\n  })\r\n  return response\r\n}\r\n\r\nBrowserBot.prototype.getAlertMessage = function() {\r\n  let self = this\r\n  let response = new Promise(function(resolve, reject) {\r\n    let count = 0\r\n    let interval = setInterval(function() {\r\n      if (!self.alertResponse) {\r\n        count++\r\n        if (count > 60) {\r\n          reject('No response!!!!')\r\n          clearInterval(interval)\r\n        }\r\n      } else {\r\n        resolve(self.alertMessage)\r\n        self.alertResponse = false\r\n        self.alertMessage = null\r\n        clearInterval(interval)\r\n      }\r\n    }, 500)\r\n  })\r\n  return response\r\n}\r\n\r\n/*****************************************************************/\r\n/* BROWSER-SPECIFIC FUNCTIONS ONLY AFTER THIS LINE */\r\n\r\nexport class MozillaBrowserBot extends BrowserBot {\r\n  constructor(frame) {\r\n    super(frame)\r\n  }\r\n}\r\n\r\nexport class KonquerorBrowserBot extends BrowserBot {\r\n  constructor(frame) {\r\n    super(frame)\r\n  }\r\n}\r\n\r\nKonquerorBrowserBot.prototype.setIFrameLocation = function(iframe, location) {\r\n  // Window doesn't fire onload event when setting src to the current value,\r\n  // so we set it to blank first.\r\n  iframe.src = 'about:blank'\r\n  iframe.src = location\r\n}\r\n\r\nKonquerorBrowserBot.prototype._isSameDocument = function(\r\n  originalDocument,\r\n  currentDocument\r\n) {\r\n  // under Konqueror, there may be this case:\r\n  // originalDocument and currentDocument are different objects\r\n  // while their location are same.\r\n  if (originalDocument) {\r\n    return originalDocument.location == currentDocument.location\r\n  } else {\r\n    return originalDocument === currentDocument\r\n  }\r\n}\r\n\r\nexport class SafariBrowserBot extends BrowserBot {\r\n  constructor(frame) {\r\n    super(frame)\r\n  }\r\n}\r\n\r\nSafariBrowserBot.prototype.setIFrameLocation =\r\n  KonquerorBrowserBot.prototype.setIFrameLocation\r\n\r\nexport class OperaBrowserBot extends BrowserBot {\r\n  constructor(frame) {\r\n    super(frame)\r\n  }\r\n}\r\n\r\nOperaBrowserBot.prototype.setIFrameLocation = function(iframe, location) {\r\n  if (iframe.src == location) {\r\n    iframe.src = location + '?reload'\r\n  } else {\r\n    iframe.src = location\r\n  }\r\n}\r\n\r\nexport class IEBrowserBot extends BrowserBot {\r\n  constructor(frame) {\r\n    super(frame)\r\n  }\r\n}\r\n\r\nIEBrowserBot.prototype._handleClosedSubFrame = function(\r\n  testWindow,\r\n  doNotModify\r\n) {\r\n  if (this.proxyInjectionMode) {\r\n    return testWindow\r\n  }\r\n\r\n  try {\r\n    testWindow.location.href\r\n    this.permDenied = 0\r\n  } catch (e) {\r\n    this.permDenied++\r\n  }\r\n  if (this._windowClosed(testWindow) || this.permDenied > 4) {\r\n    if (this.isSubFrameSelected) {\r\n      //LOG.warn(\"Current subframe appears to have closed; selecting top frame\");\r\n      this.selectFrame('relative=top')\r\n      return this.getCurrentWindow(doNotModify)\r\n    } else {\r\n      let closedError = new SeleniumError('Current window or frame is closed!')\r\n      closedError.windowClosed = true\r\n      throw closedError\r\n    }\r\n  }\r\n  return testWindow\r\n}\r\n\r\nIEBrowserBot.prototype.modifyWindowToRecordPopUpDialogs = function(\r\n  windowToModify,\r\n  browserBot\r\n) {\r\n  BrowserBot.prototype.modifyWindowToRecordPopUpDialogs(\r\n    windowToModify,\r\n    browserBot\r\n  )\r\n\r\n  // we will call the previous version of this method from within our own interception\r\n  let oldShowModalDialog = windowToModify.showModalDialog\r\n\r\n  windowToModify.showModalDialog = function(url, args, features) {\r\n    // Get relative directory to where TestRunner.html lives\r\n    // A risky assumption is that the user's TestRunner is named TestRunner.html\r\n    let doc_location = document.location.toString()\r\n    let end_of_base_ref = doc_location.indexOf('TestRunner.html')\r\n    let base_ref = doc_location.substring(0, end_of_base_ref)\r\n    let runInterval = ''\r\n\r\n    // Only set run interval if options is defined\r\n    if (typeof window.runOptions != 'undefined') {\r\n      runInterval = '&runInterval=' + runOptions.runInterval // eslint-disable-line no-undef\r\n    }\r\n\r\n    let testRunnerURL =\r\n      'TestRunner.html?auto=true&singletest=' +\r\n      escape(browserBot.modalDialogTest) +\r\n      '&autoURL=' +\r\n      escape(url) +\r\n      runInterval\r\n    let fullURL = base_ref + testRunnerURL\r\n    browserBot.modalDialogTest = null\r\n\r\n    // If using proxy injection mode\r\n    if (this.proxyInjectionMode) {\r\n      fullURL = url\r\n    }\r\n    let returnValue = oldShowModalDialog(fullURL, args, features)\r\n    return returnValue\r\n  }\r\n}\r\n\r\nIEBrowserBot.prototype.modifySeparateTestWindowToDetectPageLoads = function(\r\n  windowObject\r\n) {\r\n  this.pageUnloading = false\r\n  let self = this\r\n  let pageUnloadDetector = function() {\r\n    self.pageUnloading = true\r\n  }\r\n  if (windowObject.addEventListener) {\r\n    windowObject.addEventListener('beforeunload', pageUnloadDetector, true)\r\n  } else {\r\n    windowObject.attachEvent('onbeforeunload', pageUnloadDetector)\r\n  }\r\n  BrowserBot.prototype.modifySeparateTestWindowToDetectPageLoads.call(\r\n    this,\r\n    windowObject\r\n  )\r\n}\r\n\r\nIEBrowserBot.prototype.pollForLoad = function(\r\n  loadFunction,\r\n  windowObject,\r\n  originalDocument,\r\n  originalLocation,\r\n  originalHref,\r\n  marker\r\n) {\r\n  //LOG.debug(\"IEBrowserBot.pollForLoad: \" + marker);\r\n  if (!this.permDeniedCount[marker]) this.permDeniedCount[marker] = 0\r\n  BrowserBot.prototype.pollForLoad.call(\r\n    this,\r\n    loadFunction,\r\n    windowObject,\r\n    originalDocument,\r\n    originalLocation,\r\n    originalHref,\r\n    marker\r\n  )\r\n  if (this.pageLoadError) {\r\n    if (this.pageUnloading) {\r\n      //LOG.debug(\"pollForLoad UNLOADING (\" + marker + \"): caught exception while firing events on unloading page: \" + this.pageLoadError.message);\r\n      this.reschedulePoller(\r\n        loadFunction,\r\n        windowObject,\r\n        originalDocument,\r\n        originalLocation,\r\n        originalHref,\r\n        marker\r\n      )\r\n      this.pageLoadError = null\r\n      return\r\n    } else if (\r\n      (this.pageLoadError.message == 'Permission denied' ||\r\n        /^Access is denied/.test(this.pageLoadError.message)) &&\r\n      this.permDeniedCount[marker]++ < 8\r\n    ) {\r\n      if (this.permDeniedCount[marker] > 4) {\r\n        let canAccessThisWindow\r\n        let canAccessCurrentlySelectedWindow\r\n        try {\r\n          windowObject.location.href\r\n          canAccessThisWindow = true\r\n        } catch (e) {} // eslint-disable-line no-empty\r\n        try {\r\n          this.getCurrentWindow(true).location.href\r\n          canAccessCurrentlySelectedWindow = true\r\n        } catch (e) {} // eslint-disable-line no-empty\r\n        if (canAccessCurrentlySelectedWindow & !canAccessThisWindow) {\r\n          //LOG.debug(\"pollForLoad (\" + marker + \") ABORTING: \" + this.pageLoadError.message + \" (\" + this.permDeniedCount[marker] + \"), but the currently selected window is fine\");\r\n          // returning without rescheduling\r\n          this.pageLoadError = null\r\n          return\r\n        }\r\n      }\r\n\r\n      //LOG.debug(\"pollForLoad (\" + marker + \"): \" + this.pageLoadError.message + \" (\" + this.permDeniedCount[marker] + \"), waiting to see if it goes away\");\r\n      this.reschedulePoller(\r\n        loadFunction,\r\n        windowObject,\r\n        originalDocument,\r\n        originalLocation,\r\n        originalHref,\r\n        marker\r\n      )\r\n      this.pageLoadError = null\r\n      return\r\n    }\r\n    //handy for debugging!\r\n    //throw this.pageLoadError;\r\n  }\r\n}\r\n\r\nIEBrowserBot.prototype._windowClosed = function(win) {\r\n  try {\r\n    let c = win.closed\r\n    // frame windows claim to be non-closed when their parents are closed\r\n    // but you can't access their document objects in that case\r\n    if (!c) {\r\n      try {\r\n        win.document\r\n      } catch (de) {\r\n        if (de.message == 'Permission denied') {\r\n          // the window is probably unloading, which means it's probably not closed yet\r\n          return false\r\n        } else if (/^Access is denied/.test(de.message)) {\r\n          // rare variation on \"Permission denied\"?\r\n          //LOG.debug(\"IEBrowserBot.windowClosed: got \" + de.message + \" (this.pageUnloading=\" + this.pageUnloading + \"); assuming window is unloading, probably not closed yet\");\r\n          return false\r\n        } else {\r\n          // this is probably one of those frame window situations\r\n          //LOG.debug(\"IEBrowserBot.windowClosed: couldn't read win.document, assume closed: \" + de.message + \" (this.pageUnloading=\" + this.pageUnloading + \")\");\r\n          return true\r\n        }\r\n      }\r\n    }\r\n    if (c == null) {\r\n      //LOG.debug(\"IEBrowserBot.windowClosed: win.closed was null, assuming closed\");\r\n      return true\r\n    }\r\n    return c\r\n  } catch (e) {\r\n    //LOG.debug(\"IEBrowserBot._windowClosed: Got an exception trying to read win.closed; we'll have to take a guess!\");\r\n\r\n    if (browserVersion.isHTA) {\r\n      if (e.message == 'Permission denied') {\r\n        // the window is probably unloading, which means it's not closed yet\r\n        return false\r\n      } else {\r\n        // there's a good chance that we've lost contact with the window object if it is closed\r\n        return true\r\n      }\r\n    } else {\r\n      // the window is probably unloading, which means it's not closed yet\r\n      return false\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * In IE, getElementById() also searches by name - this is an optimisation for IE.\r\n */\r\nIEBrowserBot.prototype.locateElementByIdentifer = function(\r\n  identifier,\r\n  inDocument\r\n) {\r\n  return inDocument.getElementById(identifier)\r\n}\r\n\r\nSafariBrowserBot.prototype.modifyWindowToRecordPopUpDialogs = function(\r\n  windowToModify,\r\n  browserBot\r\n) {\r\n  BrowserBot.prototype.modifyWindowToRecordPopUpDialogs(\r\n    windowToModify,\r\n    browserBot\r\n  )\r\n\r\n  let originalOpen = windowToModify.open\r\n  /*\r\n   * Safari seems to be broken, so that when we manually trigger the onclick method\r\n   * of a button/href, any window.open calls aren't resolved relative to the app location.\r\n   * So here we replace the open() method with one that does resolve the url correctly.\r\n   */\r\n  windowToModify.open = function(url, windowName, windowFeatures, replaceFlag) {\r\n    if (\r\n      url.startsWith('http://') ||\r\n      url.startsWith('https://') ||\r\n      url.startsWith('/')\r\n    ) {\r\n      return originalOpen(url, windowName, windowFeatures, replaceFlag)\r\n    }\r\n\r\n    // Reduce the current path to the directory\r\n    let currentPath = windowToModify.location.pathname || '/'\r\n    currentPath = currentPath.replace(/\\/[^\\/]*$/, '/') // eslint-disable-line no-useless-escape\r\n\r\n    // Remove any leading \"./\" from the new url.\r\n    url = url.replace(/^\\.\\//, '')\r\n\r\n    const newUrl = currentPath + url\r\n\r\n    let openedWindow = originalOpen(\r\n      newUrl,\r\n      windowName,\r\n      windowFeatures,\r\n      replaceFlag\r\n    )\r\n    //LOG.debug(\"window.open call intercepted; window ID (which you can use with selectWindow()) is \\\"\" +  windowName + \"\\\"\");\r\n    if (windowName != null) {\r\n      openedWindow['seleniumWindowName'] = windowName\r\n    }\r\n    return openedWindow\r\n  }\r\n}\r\n\r\nMozillaBrowserBot.prototype._fireEventOnElement = function(\r\n  eventType,\r\n  element,\r\n  clientX,\r\n  clientY\r\n) {\r\n  let win = this.getCurrentWindow()\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n\r\n  // Add an event listener that detects if the default action has been prevented.\r\n  // (This is caused by a javascript onclick handler returning false)\r\n  // we capture the whole event, rather than the getPreventDefault() state at the time,\r\n  // because we need to let the entire event bubbling and capturing to go through\r\n  // before making a decision on whether we should force the href\r\n  element.addEventListener(eventType, function() {}, false)\r\n\r\n  //this._modifyElementTarget(element);\r\n\r\n  // Trigger the event.\r\n  this.browserbot.triggerMouseEvent(element, eventType, true, clientX, clientY)\r\n\r\n  if (this._windowClosed(win)) {\r\n    return\r\n  }\r\n\r\n  // Perform the link action if preventDefault was set.\r\n  // In chrome URL, the link action is already executed by triggerMouseEvent.\r\n  //if (!browserVersion.isChrome && savedEvent != null && savedEvent.getPreventDefault && !savedEvent.getPreventDefault()) {\r\n  /*\r\n    if (!browserVersion.isChrome && savedEvent != null && savedEvent.defaultPrevented && !savedEvent.defaultPrevented()) {\r\n        var targetWindow = this.browserbot._getTargetWindow(element);\r\n        if (element.href) {\r\n            targetWindow.location.href = element.href;\r\n        } else {\r\n            this.browserbot._handleClickingImagesInsideLinks(targetWindow, element);\r\n        }\r\n    }\r\n    */\r\n}\r\n\r\nOperaBrowserBot.prototype._fireEventOnElement = function(\r\n  eventType,\r\n  element,\r\n  clientX,\r\n  clientY\r\n) {\r\n  let win = this.getCurrentWindow()\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n\r\n  this._modifyElementTarget(element)\r\n\r\n  // Trigger the click event.\r\n  this.browserbot.triggerMouseEvent(element, eventType, true, clientX, clientY)\r\n\r\n  if (this._windowClosed(win)) {\r\n    return\r\n  }\r\n}\r\n\r\nKonquerorBrowserBot.prototype._fireEventOnElement = function(\r\n  eventType,\r\n  element,\r\n  clientX,\r\n  clientY\r\n) {\r\n  let win = this.getCurrentWindow()\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n\r\n  this._modifyElementTarget(element)\r\n\r\n  if (element[eventType]) {\r\n    element[eventType]()\r\n  } else {\r\n    this.browserbot.triggerMouseEvent(\r\n      element,\r\n      eventType,\r\n      true,\r\n      clientX,\r\n      clientY\r\n    )\r\n  }\r\n\r\n  if (this._windowClosed(win)) {\r\n    return\r\n  }\r\n}\r\n\r\nSafariBrowserBot.prototype._fireEventOnElement = function(\r\n  eventType,\r\n  element,\r\n  clientX,\r\n  clientY\r\n) {\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n  this._modifyElementTarget(element)\r\n\r\n  // For form element it is simple.\r\n  if (element[eventType]) {\r\n    element[eventType]()\r\n  }\r\n  // For links and other elements, event emulation is required.\r\n  else {\r\n    // todo: deal with anchors?\r\n    this.browserbot.triggerMouseEvent(\r\n      element,\r\n      eventType,\r\n      true,\r\n      clientX,\r\n      clientY\r\n    )\r\n  }\r\n}\r\n\r\nSafariBrowserBot.prototype.refresh = function() {\r\n  let win = this.getCurrentWindow()\r\n  if (win.location.hash) {\r\n    // DGF Safari refuses to refresh when there's a hash symbol in the URL\r\n    win.location.hash = ''\r\n    let actuallyReload = function() {\r\n      win.location.reload(true)\r\n    }\r\n    window.setTimeout(actuallyReload, 1)\r\n  } else {\r\n    win.location.reload(true)\r\n  }\r\n}\r\n\r\nIEBrowserBot.prototype._fireEventOnElement = function(\r\n  eventType,\r\n  element,\r\n  clientX,\r\n  clientY\r\n) {\r\n  let win = this.getCurrentWindow()\r\n  bot.events.fire(element, bot.events.EventType.FOCUS)\r\n\r\n  let wasChecked = element.checked\r\n\r\n  // Set a flag that records if the page will unload - this isn't always accurate, because\r\n  // <a href=\"javascript:alert('foo'):\"> triggers the onbeforeunload event, even thought the page won't unload\r\n  let pageUnloading = false\r\n  let pageUnloadDetector = function() {\r\n    pageUnloading = true\r\n  }\r\n  if (win.addEventListener) {\r\n    win.addEventListener('beforeunload', pageUnloadDetector, true)\r\n  } else {\r\n    win.attachEvent('onbeforeunload', pageUnloadDetector)\r\n  }\r\n  this._modifyElementTarget(element)\r\n  if (element[eventType]) {\r\n    element[eventType]()\r\n  } else {\r\n    this.browserbot.triggerMouseEvent(\r\n      element,\r\n      eventType,\r\n      true,\r\n      clientX,\r\n      clientY\r\n    )\r\n  }\r\n\r\n  // If the page is going to unload - still attempt to fire any subsequent events.\r\n  // However, we can't guarantee that the page won't unload half way through, so we need to handle exceptions.\r\n  try {\r\n    if (win.removeEventListener) {\r\n      win.removeEventListener('onbeforeunload', pageUnloadDetector, true)\r\n    } else {\r\n      win.detachEvent('onbeforeunload', pageUnloadDetector)\r\n    }\r\n\r\n    if (this._windowClosed(win)) {\r\n      return\r\n    }\r\n\r\n    // Onchange event is not triggered automatically in IE.\r\n    if (isDefined(element.checked) && wasChecked != element.checked) {\r\n      bot.events.fire(element, bot.events.EventType.CHANGE)\r\n    }\r\n  } catch (e) {\r\n    // If the page is unloading, we may get a \"Permission denied\" or \"Unspecified error\".\r\n    // Just ignore it, because the document may have unloaded.\r\n    if (pageUnloading) {\r\n      //LOG.logHook = function() {\r\n      //};\r\n      //LOG.warn(\"Caught exception when firing events on unloading page: \" + e.message);\r\n      return\r\n    }\r\n    throw e\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/selenium-browserbot.js","// Licensed to the Software Freedom Conservancy (SFC) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The SFC licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport SeleniumError from './SeleniumError'\r\n\r\nexport default function PatternMatcher(pattern) {\r\n  this.selectStrategy(pattern)\r\n}\r\n\r\nPatternMatcher.prototype = {\r\n  selectStrategy: function(pattern) {\r\n    this.pattern = pattern\r\n    let strategyName = 'glob'\r\n    // by default\r\n    if (/^([a-z-]+):(.*)/.test(pattern)) {\r\n      const possibleNewStrategyName = RegExp.$1\r\n      const possibleNewPattern = RegExp.$2\r\n      if (PatternMatcher.strategies[possibleNewStrategyName]) {\r\n        strategyName = possibleNewStrategyName\r\n        pattern = possibleNewPattern\r\n      }\r\n    }\r\n    const matchStrategy = PatternMatcher.strategies[strategyName]\r\n    if (!matchStrategy) {\r\n      throw new SeleniumError(\r\n        'cannot find PatternMatcher.strategies.' + strategyName\r\n      )\r\n    }\r\n    this.strategy = matchStrategy\r\n    this.matcher = new matchStrategy(pattern)\r\n  },\r\n\r\n  matches: function(actual) {\r\n    return this.matcher.matches(actual + '')\r\n    // Note: appending an empty string avoids a Konqueror bug\r\n  },\r\n}\r\n\r\n/**\r\n * A \"static\" convenience method for easy matching\r\n */\r\nPatternMatcher.matches = function(pattern, actual) {\r\n  return new PatternMatcher(pattern).matches(actual)\r\n}\r\n\r\nPatternMatcher.strategies = {\r\n  /**\r\n   * Exact matching, e.g. \"exact:***\"\r\n   */\r\n  exact: function(expected) {\r\n    this.expected = expected\r\n    this.matches = function(actual) {\r\n      return actual == this.expected\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Match by regular expression, e.g. \"regexp:^[0-9]+$\"\r\n   */\r\n  regexp: function(regexpString) {\r\n    this.regexp = new RegExp(regexpString)\r\n    this.matches = function(actual) {\r\n      return this.regexp.test(actual)\r\n    }\r\n  },\r\n\r\n  regex: function(regexpString) {\r\n    this.regexp = new RegExp(regexpString)\r\n    this.matches = function(actual) {\r\n      return this.regexp.test(actual)\r\n    }\r\n  },\r\n\r\n  regexpi: function(regexpString) {\r\n    this.regexp = new RegExp(regexpString, 'i')\r\n    this.matches = function(actual) {\r\n      return this.regexp.test(actual)\r\n    }\r\n  },\r\n\r\n  regexi: function(regexpString) {\r\n    this.regexp = new RegExp(regexpString, 'i')\r\n    this.matches = function(actual) {\r\n      return this.regexp.test(actual)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * \"globContains\" (aka \"wildmat\") patterns, e.g. \"glob:one,two,*\",\r\n   * but don't require a perfect match; instead succeed if actual\r\n   * contains something that matches globString.\r\n   * Making this distinction is motivated by a bug in IE6 which\r\n   * leads to the browser hanging if we implement *TextPresent tests\r\n   * by just matching against a regular expression beginning and\r\n   * ending with \".*\".  The globcontains strategy allows us to satisfy\r\n   * the functional needs of the *TextPresent ops more efficiently\r\n   * and so avoid running into this IE6 freeze.\r\n   */\r\n  globContains: function(globString) {\r\n    this.regexp = new RegExp(PatternMatcher.regexpFromGlobContains(globString))\r\n    this.matches = function(actual) {\r\n      return this.regexp.test(actual)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * \"glob\" (aka \"wildmat\") patterns, e.g. \"glob:one,two,*\"\r\n   */\r\n  glob: function(globString) {\r\n    this.regexp = new RegExp(PatternMatcher.regexpFromGlob(globString))\r\n    this.matches = function(actual) {\r\n      return this.regexp.test(actual)\r\n    }\r\n  },\r\n}\r\n\r\nPatternMatcher.convertGlobMetaCharsToRegexpMetaChars = function(glob) {\r\n  let re = glob\r\n  re = re.replace(/([.^$+(){}\\[\\]\\\\|])/g, '\\\\$1') // eslint-disable-line no-useless-escape\r\n  re = re.replace(/\\?/g, '(.|[\\r\\n])')\r\n  re = re.replace(/\\*/g, '(.|[\\r\\n])*')\r\n  return re\r\n}\r\n\r\nPatternMatcher.regexpFromGlobContains = function(globContains) {\r\n  return PatternMatcher.convertGlobMetaCharsToRegexpMetaChars(globContains)\r\n}\r\n\r\nPatternMatcher.regexpFromGlob = function(glob) {\r\n  return '^' + PatternMatcher.convertGlobMetaCharsToRegexpMetaChars(glob) + '$'\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/PatternMatcher.js","// Licensed to the Software Freedom Conservancy (SFC) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The SFC licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\n// Modified in tools.js from selenium-IDE\r\n\r\nexport function exactMatchPattern(string) {\r\n  if (\r\n    string != null &&\r\n    (string.match(/^\\w*:/) ||\r\n      string.indexOf('?') >= 0 ||\r\n      string.indexOf('*') >= 0)\r\n  ) {\r\n    return 'exact:' + string\r\n  } else {\r\n    return string\r\n  }\r\n}\r\n\r\nclass TargetSelector {\r\n  constructor(callback, cleanupCallback) {\r\n    this.callback = callback\r\n    this.cleanupCallback = cleanupCallback\r\n    // This is for XPCOM/XUL addon and can't be used\r\n    //var wm = Components.classes[\"@mozilla.org/appshell/window-mediator;1\"].getService(Components.interfaces.nsIWindowMediator);\r\n    //this.win = wm.getMostRecentWindow('navigator:browser').getBrowser().contentWindow;\r\n\r\n    // Instead, we simply assign global content window to this.win\r\n    this.win = window\r\n    const doc = this.win.document\r\n    const div = doc.createElement('div')\r\n    div.setAttribute('style', 'display: none;')\r\n    doc.body.insertBefore(div, doc.body.firstChild)\r\n    this.div = div\r\n    this.e = null\r\n    this.r = null\r\n    this.banner = doc.createElement('div')\r\n    this.banner.setAttribute(\r\n      'style',\r\n      'position: fixed;top: 0;left: 0;bottom: 0;right: 0;background: trasparent;z-index: 10000;'\r\n    )\r\n    const header = doc.createElement('div')\r\n    header.setAttribute(\r\n      'style',\r\n      \"pointer-events: none;display: flex;align-items: center;justify-content: center;flex-direction: row;position: fixed;top: 20%;left: 50%;transform: translateX(-50%);background: #f7f7f7;color: #114990;font-size: 22px;font-weight: 200;z-index: 10001;font-family: system, -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;box-shadow: 0 7px 10px 0 rgba(0,0,0,0.1);border: 1px black solid; border-radius: 50px;padding: 10px;\"\r\n    )\r\n    const img = doc.createElement('img')\r\n    img.src = browser.runtime.getURL('/icons/icon_light128.png')\r\n    img.setAttribute('style', 'width: 28px;margin: 0 10px;')\r\n    header.appendChild(img)\r\n    const span = doc.createElement('span')\r\n    span.setAttribute(\r\n      'style',\r\n      'border-left: 1px solid #c6c6c6;padding: 3px 10px;'\r\n    )\r\n    span.innerText = 'Select an element'\r\n    header.appendChild(span)\r\n    setTimeout(() => {\r\n      // this has to happen after a timeout, since adding it sync will add the event\r\n      // before the window is focused which will case mousemove to fire before the\r\n      // user actually moves the mouse\r\n      this.banner.addEventListener(\r\n        'mousemove',\r\n        () => {\r\n          setTimeout(() => {\r\n            this.banner.style.visibility = 'hidden'\r\n          }, 300)\r\n        },\r\n        false\r\n      )\r\n    }, 300)\r\n    this.banner.appendChild(header)\r\n    doc.body.insertBefore(this.banner, div)\r\n    doc.addEventListener('mousemove', this, true)\r\n    doc.addEventListener('click', this, true)\r\n  }\r\n\r\n  cleanup() {\r\n    try {\r\n      if (this.div) {\r\n        if (this.div.parentNode) {\r\n          this.div.parentNode.removeChild(this.div)\r\n        }\r\n        this.div = null\r\n      }\r\n      if (this.header) {\r\n        if (this.header.parentNode) {\r\n          this.header.parentNode.removeChild(this.header)\r\n        }\r\n        this.header = null\r\n      }\r\n      if (this.win) {\r\n        const doc = this.win.document\r\n        doc.removeEventListener('mousemove', this, true)\r\n        doc.removeEventListener('click', this, true)\r\n      }\r\n    } catch (e) {\r\n      if (e != \"TypeError: can't access dead object\") {\r\n        throw e\r\n      }\r\n    }\r\n    this.win = null\r\n    if (this.cleanupCallback) {\r\n      this.cleanupCallback()\r\n    }\r\n  }\r\n\r\n  handleEvent(evt) {\r\n    switch (evt.type) {\r\n      case 'mousemove':\r\n        this.highlight(evt.target.ownerDocument, evt.clientX, evt.clientY)\r\n        break\r\n      case 'click':\r\n        if (evt.button == 0 && this.e && this.callback) {\r\n          this.callback(this.e, this.win)\r\n        } //Right click would cancel the select\r\n        evt.preventDefault()\r\n        evt.stopPropagation()\r\n        this.cleanup()\r\n        break\r\n    }\r\n  }\r\n\r\n  highlight(doc, x, y) {\r\n    if (doc) {\r\n      const e = doc.elementFromPoint(x, y)\r\n      if (e && e != this.e) {\r\n        this.highlightElement(e)\r\n      }\r\n    }\r\n  }\r\n\r\n  highlightElement(element) {\r\n    if (element && element != this.e && element !== this.banner) {\r\n      this.e = element\r\n    } else {\r\n      return\r\n    }\r\n    const r = element.getBoundingClientRect()\r\n    const or = this.r\r\n    if (r.left >= 0 && r.top >= 0 && r.width > 0 && r.height > 0) {\r\n      if (\r\n        or &&\r\n        r.top == or.top &&\r\n        r.left == or.left &&\r\n        r.width == or.width &&\r\n        r.height == or.height\r\n      ) {\r\n        return\r\n      }\r\n      this.r = r\r\n      const style =\r\n        'pointer-events: none; position: absolute; background-color: rgb(78, 171, 230); opacity: 0.4; border: 1px solid #0e0e0e; z-index: 1000000;'\r\n      const pos = `top:${r.top + this.win.scrollY}px; left:${r.left +\r\n        this.win.scrollX}px; width:${r.width}px; height:${r.height}px;`\r\n      this.div.setAttribute('style', style + pos)\r\n    } else if (or) {\r\n      this.div.setAttribute('style', 'display: none;')\r\n    }\r\n  }\r\n}\r\n\r\nexport default TargetSelector\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/targetSelector.js","// Licensed to the Software Freedom Conservancy (SFC) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The SFC licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nconst coords = {\r\n  startX: 0,\r\n  startY: 0,\r\n  endX: 0,\r\n  endY: 0,\r\n}\r\n\r\nconst mouseOffset = {\r\n  x: 0,\r\n  y: 0,\r\n}\r\n\r\nconst STATES = {\r\n  create: 1,\r\n  update: 2,\r\n  resize: 3,\r\n}\r\n\r\nlet state = STATES.create\r\nlet canvasExists = false\r\n\r\nexport function editRegion(rect, cb) {\r\n  if (canvasExists) {\r\n    return cb(false)\r\n  }\r\n  const container = document.createElement('div')\r\n  container.id = 'selenium-container'\r\n  const canvas = document.createElement('div')\r\n  canvas.id = 'selenium-canvas'\r\n  const region = createRegion()\r\n  setStyle(canvas, region)\r\n  setEvents(container)\r\n  const buttonContainer = createButtons(cb)\r\n  buttonContainer.style.zIndex = '10002'\r\n  if (rect) {\r\n    region.style.left = `${rect.x}px`\r\n    region.style.top = `${rect.y}px`\r\n    region.style.width = `${rect.width}px`\r\n    region.style.height = `${rect.height}px`\r\n  }\r\n  container.appendChild(buttonContainer)\r\n  container.appendChild(canvas)\r\n  container.appendChild(region)\r\n  document.body.appendChild(container)\r\n  canvasExists = true\r\n}\r\n\r\nexport function removeRegion() {\r\n  if (canvasExists) {\r\n    document.body.removeChild(document.getElementById('selenium-container'))\r\n  }\r\n  canvasExists = false\r\n}\r\n\r\nfunction setStyle(canvas, region) {\r\n  canvas.style.position = 'fixed'\r\n  canvas.style.top = 0\r\n  canvas.style.bottom = 0\r\n  canvas.style.right = 0\r\n  canvas.style.left = 0\r\n  canvas.style.zIndex = '10000'\r\n  canvas.style.cursor = 'crosshair'\r\n\r\n  region.style.position = 'absolute'\r\n  region.style.zIndex = '10001'\r\n  region.style.backgroundColor = 'rgb(78, 171, 230)'\r\n  region.style.opacity = '0.4'\r\n  region.style.border = '1px solid #0e0e0e'\r\n}\r\n\r\nfunction setEvents(container) {\r\n  container.addEventListener('mousedown', mousedown)\r\n  container.addEventListener('mouseup', mouseup)\r\n}\r\n\r\nfunction mousedown(e) {\r\n  const container = document.getElementById('selenium-container')\r\n  const canvas = document.getElementById('selenium-canvas')\r\n  const region = document.getElementById('selenium-region')\r\n  e.stopPropagation()\r\n  if (e.target.tagName === 'BUTTON') return\r\n  if (e.target === canvas) {\r\n    updateRegion(e.pageX, e.pageY, e.pageX, e.pageY)\r\n    state = STATES.create\r\n    region.style.cursor = 'crosshair'\r\n  } else if (e.target === region) {\r\n    state = STATES.update\r\n    mouseOffset.x = e.pageX\r\n    mouseOffset.y = e.pageY\r\n    region.style.cursor = 'move'\r\n  } else if (e.target.parentElement === region) {\r\n    state = STATES.resize\r\n  }\r\n  container.addEventListener('mousemove', mousemove)\r\n}\r\n\r\nfunction mousemove(e) {\r\n  e.stopPropagation()\r\n  if (e.target.tagName === 'BUTTON') return\r\n  if (state === STATES.create || state === STATES.resize) {\r\n    updateRegion(undefined, undefined, e.pageX, e.pageY)\r\n  } else if (state === STATES.update) {\r\n    moveRegion(e.pageX, e.pageY)\r\n  }\r\n}\r\n\r\nfunction mouseup(e) {\r\n  const container = document.getElementById('selenium-container')\r\n  const canvas = document.getElementById('selenium-canvas')\r\n  const region = document.getElementById('selenium-region')\r\n  e.stopPropagation()\r\n  region.style.cursor = 'move'\r\n  canvas.style.cursor = 'crosshair'\r\n  container.removeEventListener('mousemove', mousemove)\r\n  showButtons()\r\n}\r\n\r\nfunction calculateRectFromCoords(coords) {\r\n  return calculateRect(\r\n    { x: coords.startX, y: coords.startY },\r\n    { x: coords.endX, y: coords.endY }\r\n  )\r\n}\r\n\r\nfunction calculateRect(p1, p2) {\r\n  return {\r\n    left: Math.min(p1.x, p2.x),\r\n    top: Math.min(p1.y, p2.y),\r\n    width: Math.abs(p1.x - p2.x),\r\n    height: Math.abs(p1.y - p2.y),\r\n  }\r\n}\r\n\r\nfunction updateRegion(startX, startY, endX, endY) {\r\n  hideButtons()\r\n  const region = document.getElementById('selenium-region')\r\n  if (startX) {\r\n    coords.startX = startX\r\n  }\r\n  if (startY) {\r\n    coords.startY = startY\r\n  }\r\n  if (endX) {\r\n    coords.endX = endX\r\n  }\r\n  if (endY) {\r\n    coords.endY = endY\r\n  }\r\n  const rect = calculateRectFromCoords(coords)\r\n  region.style.left = `${rect.left}px`\r\n  region.style.top = `${rect.top}px`\r\n  region.style.width = `${rect.width}px`\r\n  region.style.height = `${rect.height}px`\r\n}\r\n\r\nfunction moveRegion(mouseX, mouseY) {\r\n  let dx = mouseOffset.x - mouseX\r\n  let dy = mouseOffset.y - mouseY\r\n  mouseOffset.x = mouseX\r\n  mouseOffset.y = mouseY\r\n  if (coords.startX - dx < 5 || coords.endX - dx < 5) dx = 0\r\n  if (coords.startY - dy < 5 || coords.endY - dy < 5) dy = 0\r\n  updateRegion(\r\n    coords.startX - dx,\r\n    coords.startY - dy,\r\n    coords.endX - dx,\r\n    coords.endY - dy\r\n  )\r\n}\r\n\r\nfunction createRegion() {\r\n  const region = document.createElement('div')\r\n  region.id = 'selenium-region'\r\n\r\n  const cornerSize = 20\r\n\r\n  const tlc = createHotCorner(cornerSize)\r\n  tlc.style.top = '-5px'\r\n  tlc.style.left = '-5px'\r\n  tlc.style.cursor = 'nw-resize'\r\n\r\n  tlc.addEventListener('mousedown', () => {\r\n    const canvas = document.getElementById('selenium-canvas')\r\n    const region = document.getElementById('selenium-region')\r\n    canvas.style.cursor = 'nw-resize'\r\n    region.style.cursor = 'nw-resize'\r\n    updateRegion(\r\n      Math.max(coords.startX, coords.endX),\r\n      Math.max(coords.startY, coords.endY),\r\n      Math.min(coords.startX, coords.endX),\r\n      Math.min(coords.startY, coords.endY)\r\n    )\r\n  })\r\n\r\n  region.appendChild(tlc)\r\n\r\n  const trc = createHotCorner(cornerSize)\r\n  trc.style.top = '-5px'\r\n  trc.style.right = '-5px'\r\n  trc.style.cursor = 'ne-resize'\r\n\r\n  trc.addEventListener('mousedown', () => {\r\n    const canvas = document.getElementById('selenium-canvas')\r\n    const region = document.getElementById('selenium-region')\r\n    canvas.style.cursor = 'ne-resize'\r\n    region.style.cursor = 'ne-resize'\r\n    updateRegion(\r\n      Math.min(coords.startX, coords.endX),\r\n      Math.max(coords.startY, coords.endY),\r\n      Math.max(coords.startX, coords.endX),\r\n      Math.min(coords.startY, coords.endY)\r\n    )\r\n  })\r\n\r\n  region.appendChild(trc)\r\n\r\n  const blc = createHotCorner(cornerSize)\r\n  blc.style.bottom = '-5px'\r\n  blc.style.left = '-5px'\r\n  blc.style.cursor = 'sw-resize'\r\n\r\n  blc.addEventListener('mousedown', () => {\r\n    const canvas = document.getElementById('selenium-canvas')\r\n    const region = document.getElementById('selenium-region')\r\n    canvas.style.cursor = 'sw-resize'\r\n    region.style.cursor = 'sw-resize'\r\n    updateRegion(\r\n      Math.max(coords.startX, coords.endX),\r\n      Math.min(coords.startY, coords.endY),\r\n      Math.min(coords.startX, coords.endX),\r\n      Math.max(coords.startY, coords.endY)\r\n    )\r\n  })\r\n\r\n  region.appendChild(blc)\r\n\r\n  const brc = createHotCorner(cornerSize)\r\n  brc.style.bottom = '-5px'\r\n  brc.style.right = '-5px'\r\n  brc.style.cursor = 'se-resize'\r\n\r\n  brc.addEventListener('mousedown', () => {\r\n    const canvas = document.getElementById('selenium-canvas')\r\n    const region = document.getElementById('selenium-region')\r\n    canvas.style.cursor = 'se-resize'\r\n    region.style.cursor = 'se-resize'\r\n    updateRegion(\r\n      Math.min(coords.startX, coords.endX),\r\n      Math.min(coords.startY, coords.endY),\r\n      Math.max(coords.startX, coords.endX),\r\n      Math.max(coords.startY, coords.endY)\r\n    )\r\n  })\r\n\r\n  region.appendChild(brc)\r\n\r\n  return region\r\n}\r\n\r\nfunction createHotCorner(size) {\r\n  const c = document.createElement('div')\r\n  c.style.position = 'absolute'\r\n  c.style.height = `${size}px`\r\n  c.style.width = `${size}px`\r\n\r\n  return c\r\n}\r\n\r\nfunction showButtons() {\r\n  const canvasRect = document\r\n    .getElementById('selenium-canvas')\r\n    .getBoundingClientRect()\r\n  const buttonContainer = document.getElementById('region-control-panel')\r\n  let top = coords.startY\r\n  let bottom = coords.endY\r\n  let left = coords.startX\r\n  let right = coords.endX\r\n  let width = right - left\r\n  if (canvasRect.bottom - bottom <= 100) bottom = top\r\n  if (width < 0) left = coords.endX\r\n  right = coords.startX\r\n  width = Math.abs(width)\r\n  if (width < 225) width = 225\r\n  buttonContainer.style.position = 'absolute'\r\n  buttonContainer.style.top = bottom + 'px'\r\n  buttonContainer.style.left = left + 'px'\r\n  buttonContainer.style.right = right + 'px'\r\n  buttonContainer.style.width = width + 'px'\r\n  buttonContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.55)'\r\n  buttonContainer.style.visibility = 'visible'\r\n}\r\n\r\nfunction hideButtons() {\r\n  const buttonContainer = document.getElementById('region-control-panel')\r\n  buttonContainer.style.visibility = 'hidden'\r\n}\r\n\r\nfunction createButtons(cb) {\r\n  const container = document.createElement('div')\r\n  container.id = 'region-control-panel'\r\n  const buttons = document.createElement('div')\r\n  const confirm = document.createElement('button')\r\n  confirm.innerText = 'Confirm'\r\n  confirm.addEventListener('click', () => {\r\n    hideButtons()\r\n    removeRegion()\r\n    const rect = calculateRectFromCoords(coords)\r\n    cb(\r\n      `x: ${rect.left}, y: ${rect.top}, width: ${rect.width}, height: ${\r\n        rect.height\r\n      }`\r\n    )\r\n  })\r\n  const cancel = document.createElement('button')\r\n  cancel.innerText = 'Cancel'\r\n  cancel.addEventListener('click', () => {\r\n    hideButtons()\r\n    removeRegion()\r\n    cb(false)\r\n  })\r\n\r\n  container.style.visibility = 'hidden'\r\n  buttons.style.display = 'flex'\r\n  buttons.style.alignItems = 'center'\r\n  buttons.style.justifyContent = 'center'\r\n\r\n  styleButton(confirm)\r\n  styleButton(cancel)\r\n\r\n  buttons.appendChild(cancel)\r\n  buttons.appendChild(confirm)\r\n  container.appendChild(buttons)\r\n  return container\r\n}\r\n\r\nfunction styleButton(button) {\r\n  button.style.color = '#656565'\r\n  button.style.backgroundColor = '#F5F5F5'\r\n  button.style.padding = '10px 20px'\r\n  button.style.margin = '5px 8px'\r\n  button.style.borderRadius = '4px'\r\n  button.style.outline = '0'\r\n  button.style.textTransform = 'capitalize'\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/region.js","// Licensed to the Software Freedom Conservancy (SFC) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The SFC licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport browser from 'webextension-polyfill'\r\n\r\nlet handler, elementForInjectingScript\r\nexport function attach(selenium) {\r\n  elementForInjectingScript = document.createElement('script')\r\n  elementForInjectingScript.src = browser.runtime.getURL('/assets/prompt.js')\r\n  ;(document.head || document.documentElement).appendChild(\r\n    elementForInjectingScript\r\n  )\r\n\r\n  if (window === window.top) {\r\n    handler = e => {\r\n      return handleMessage(e, selenium)\r\n    }\r\n    window.addEventListener('message', handler)\r\n  }\r\n}\r\n\r\nexport function detach() {\r\n  window.postMessage(\r\n    {\r\n      direction: 'from-content-script',\r\n      detach: true,\r\n    },\r\n    '*'\r\n  )\r\n  elementForInjectingScript.parentNode.removeChild(elementForInjectingScript)\r\n  window.removeEventListener('message', handler)\r\n}\r\n\r\nfunction handleMessage(event, selenium) {\r\n  if (\r\n    event.source &&\r\n    event.source.top == window &&\r\n    event.data &&\r\n    event.data.direction == 'from-page-script'\r\n  ) {\r\n    if (event.data.response) {\r\n      switch (event.data.response) {\r\n        case 'prompt':\r\n          selenium.browserbot.promptResponse = true\r\n          if (event.data.value)\r\n            selenium.browserbot.promptMessage = event.data.value\r\n          break\r\n        case 'confirm':\r\n          selenium.browserbot.confirmationResponse = true\r\n          if (event.data.value)\r\n            selenium.browserbot.confirmationMessage = event.data.value\r\n          break\r\n        case 'alert':\r\n          selenium.browserbot.alertResponse = true\r\n          if (event.data.value)\r\n            selenium.browserbot.alertMessage = event.data.value\r\n          break\r\n      }\r\n    }\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./content/prompt-injector.js"],"sourceRoot":""}